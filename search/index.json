[{"content":"2021 年国家公祭日有感 我是一个南方人，一直以来，都不太愿意去了解这些同胞受难的事情，不愿意面对；同时，也不知道该以什么样的心情去面对。\n我不确定一个人、一个军队，在祖国强盛、自己满怀荣光的情况下，如何能够做出这样的事情。 一个人为之，或许可以称之为堕落；一个军队，大概是集体兽化了吧。\n何为人？这个提问出自《一人之下》。\n“张三”说：法律是道德的最低标准，我们不应该以不违法来标榜自己。 我也是这么认为的。 但是对于我个人来说，我希望我更有原则，更加旗帜鲜明：\n 旗帜鲜明地表达自己的立场——我热爱自己、热爱家人、热爱祖国、热爱这片土地； 旗帜鲜明地反对屠杀之类禽兽行为；  牢记历史，热爱和平。\n","date":"2021-12-13T13:45:24-04:00","image":"https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/iscream_hub8c91bfe3ab4a8b0a897e9f951468ee1_48729_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/","title":"个人感悟 —— 国家公祭日有感"},{"content":"中断 1. 硬件中断注册 #include \u0026lt;linux/interrupt.h\u0026gt; static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)  作用：申请一个中断线。 参数：  irq: 中断线号 handler: 中断处理函数 flags: name: dev:    2. 硬件中断释放 #include \u0026lt;linux/interrupt.h\u0026gt; const void *free_irq(unsigned int irq, void *dev_id);  作用：释放一个中断线。如果没有其他设备注册该IRQ线，就关闭该IRQ。 参数：  irq: 中断线号。 dev_id: 设备标识。    3. 中断类型 网络设备常见的中断事件类型：\n 接收一帧：最常见、标准的情况。 传输失败； DMA传输已成功完成；  drivers/net/3c59x.c有相关范例。   设备有足够内存处理新传输；  4. 中断共享 IRQ线是有限的资源；允许系统能容纳设备数目的简单方式就是：允许多台设备共享一个IRQ线。 一组设备共享一条IRQ线时，所有这些设备的设备驱动程序都必须有能力处理共享的IRQ。换言之，设备注册IRQ时，需要说明其是否支持中断共享。\n5. IRQ处理函数映射（中断向量表） 相关结构：详见\u0026lt;include/linux/interrupt.h\u0026gt;\n struct irq_desc struct irqaction  irq_desc ----\u0026gt;+---------+ | | | +---------+ | | *action | --------------------\u0026gt; +---------------+ +---------+ | *next | | | | | | | | +---------------+ | +---------+ struct irqaction NR_IRQS | *action | --------------------\u0026gt; +---------------+ ------\u0026gt; +---------------+ | +---------+ | *next | | *next | | | | SA_SHIRQ | | | | | | +---------------+ +---------------+ +---------+ -- struct irqaction struct irqaction | | | | -\u0026gt; struct irq_desc -----+---------+ -- ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image_hu3d03a01dcc18bc5be0e67db3d8d209a6_109779_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/","title":"Linux 内核 —— 中断"},{"content":"gdb gdb - GNU调试器。\n调试器(如GDB)的目的是允许你查看其他程序在执行时的\u0026quot;内部\u0026quot;的内容，或者程序奔溃的时候正在做什么。 GDB可以做4种主要的事情来帮助你捕捉bug：\n 启动你的程序，指定任何可能影响程序行为的内容。 使程序在指定条件下停止。 检查你程序停止时，正在发生的事情。 更改程序中的内容，以便你可以尝试纠正一个错误的影响并继续了解另一个错误。  你可以用GDB来调试C、C++、Fortran、Modula-2编写的程序。 使用gdb命令来调用GDB。一旦启动，它会从中断读取命令，直到你用GDB命令\u0026quot;exit\u0026quot;告诉它退出。你可以用GDB命令help来查看帮助（不用退出gdb）。 你可以运行没有参数或选项的gdb ; 但是最常用的启动GDB的方法是使用一个或两个参数，将可执行程序指定为参数：\n gdb program\n 您还可以从可执行程序和指定的core文件开始：\n gdb program core\n 如果要调试正在运行的进程，则可以将进程ID指定为第二个参数：\n gdb program 1234 gdb -p 1234\n 将GDB附加(attach)到1234进程（除非你由一个名字为1234的core文件，gdb会先查找core文件）。 以下是一些常用的GDB命令:\nbreak [file:]function 在函数(文件)中设置断点。 缩写：b。 用法： b \u0026lt;行号\u0026gt;，如：b 8 b \u0026lt;函数名称\u0026gt;，如：b main b *\u0026lt;函数名称\u0026gt;，如：b *main（在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”） b *\u0026lt;代码地址\u0026gt;，如：b *0x804835c。 d [breakpoint number] 删除断点 run [arglist] 开始你的程序（arglist是参数列表） 缩写：r bt 回溯(backtrace)：显示程序堆栈。 print expr 显示表达式expr的值。 缩写：p c 继续运行你的程序（在停止后，例如断电）。continue的缩写。 next 继续下一行(在停止后)；不进入函数的单步调试。 缩写：n edit [file:]function 查看程序当前停止的行。 list [file:]function 在当前停止的位置附近键入程序的文本。 step 继续下一行(在停止后)；进入函数的单步调试。 缩写：s i 显示各类信息。如：i r，显示寄存器的信息 help [name] 显示GDB命令name的信息，或有关使用GDB的一般信息。 quit 退出GDB。 缩写：q 有关GDB的完整详细信息，请参阅：A Guide to the GNU Source-Level Debugger\n用法 gdb [-help] [-nh] [-nx] [-q] [-batch] [-cd=dir] [-f] [-b bps] [-tty=dev] [-s symfile] [-e prog] [-se prog] [-c core] [-p procID] [-x cmds] [-d dir] [prog|prog procID|prog core] 选项 选项之外的任何参数都需要指定可执行文件和核心文件（或进程ID）。 所有选项和命令行参数都按顺序处理。使用' -x \u0026lsquo;选项时，顺序会有所不同。\n-help -h 列出所有选项，并提供简要说明。 -symbols=file -s file 从file文件中读取符号表（symbol table）。 -write 允许写入可执行文件和core文件。 -exec=file -e file 使用file文件作为可执行文件在适当时执行，并与核心转储一起检查纯数据。 -se=file 从file文件中读取符号表并将file用作可执行文件。 -core=file -c file 指定core文件。 -command=file -x file 执行file文件中的GDB命令。（自动化？） -ex command 执行给定的GDB命令。 -directory=directory -d directory 将目录添加到路径(path)以搜索源文件。 -nh 不要执行~/.gdbinit中的命令。 -nx -n 不要执行任何\u0026#39;.gdbinit\u0026#39;初始化文件中的命令。 -quiet -q \u0026#34;Quiet\u0026#34;. 不要打印介绍性和版权信息。这些消息也在批处理模式下被抑制。 -batch 以批处理模式运行。 在执行完用-x选项指定的所有命令文件(如果不禁止，则为.gdbinit)后，以0退出。 如果在运行命令文件中的GDB命令时发生错误，则以非0退出。 批处理模式可用于将GDB作为过滤器运行，例如在另一台计算机上下载并运行程序; 为了使这个更有用，消息程序正常退出。【？？？】 -cd=directory 使用directory作用GDB的工作目录（而不是用当前目录） -fullname -f Emacs在将GDB作为子进程运行时设置此选项。 它告诉GDB每次显示堆栈帧时都以标准的，可识别的方式输出完整的文件名和行号（包括每次程序停止时）。 这种可识别的格式看起来像两个\u0026#39;\\032\u0026#39;字符，后跟文件名，行号和以冒号分隔的字符位置，以及换行符。 Emacs-to-GDB接口程序使用两个\u0026#39;\\032\u0026#39;字符作为信号来显示帧的源代码。 -b bps 设置GDB用于远程调试的任何串行接口的线性速度（波特率或每秒位数）。 -tty=device 使用device运行程序的标准输入和输出。 示例 编译并跟踪 gcc test.c -o test -g gdb test \u0026lt;gdb命令\u0026gt; \u0026lt;b main\u0026gt;: 断点 \u0026lt;b 10\u0026gt;: 第10行设置断点 \u0026lt;d 10\u0026gt;: 删除第10行的断点 \u0026lt;info b\u0026gt;: 查看断点信息 \u0026lt;c\u0026gt;: 继续 \u0026lt;n\u0026gt;: 下一行 \u0026lt;s\u0026gt;: 下一行，进入函数。 \u0026lt;r\u0026gt;: 执行 \u0026lt;c\u0026gt;: 继续执行 \u0026lt;i r\u0026gt;: 显示寄存器的信息 \u0026lt;bt\u0026gt;: 显示堆栈 \u0026lt;list 10\u0026gt;: 从第10行开始显示代码 疑问 拓展  shell命令：info gdb gdb在线文档  A Guide to the GNU Source-Level Debugger    参考  https://man.linuxde.net/gdb  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/image_hu890b4a84832ec272513434c344ebda9b_82374_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/","title":"Linux 命令 —— gdb"},{"content":"git submodule 添加submodule： git submodule add \u0026lt;subproject URL\u0026gt; \u0026gt; git submodule add https://github.com/isshe/gitsubproject 查看subproject的commit： git diff --cached \u0026lt;subproject dir\u0026gt; \u0026gt; git diff --cached gitsubproject/ 查看subproject的.gitmodules： git diff --cached --submodule 自动clone每个submodule： git clone --recursive \u0026lt;your repository url\u0026gt; \u0026gt; git clone --recursive https://github.com/isshe/gitproject 拉取子模块： git submodule init git submodule update \u0026gt; 更常用的是：递归更新 git submodule update --init --recursive 子模块的后续更新：\ngit submodule update --remote 调整submodule的commit： git pull origin xxx 切submodule的分支： git config -f .gitmodules submodule.\u0026lt;submodule dir\u0026gt;.branch \u0026lt;submodule target branch name\u0026gt; \u0026gt; git config -f .gitmodules submodule.DbConnector.branch stable 更新到相应的分支：\ngit checkout -b \u0026lt;branch name\u0026gt; --track origin/\u0026lt;branch name\u0026gt; \u0026gt; git checkout -b chudai --track origin/chudai 删除一个submodule：  Delete the relevant section from the .gitmodules file. Stage the .gitmodules changes git add .gitmodules Delete the relevant section from .git/config. Run git rm --cached path_to_submodule (no trailing slash). Run rm -rf .git/modules/path_to_submodule Commit git commit -m \u0026quot;Removed submodule \u0026lt;name\u0026gt;\u0026quot; Delete the now untracked submodule filesrm -rf path_to_submodule  使用示例 显示某次提交修改的文件 git show --name-only HEAD git merge squash git checkout \u0026lt;your-dev-branch\u0026gt; # -i 后跟 commit id，要合并的提交的前一个，如果你要合并两次提交，那个出来的编辑器里应该有两条记录 git rebase -i HEAD~2 # 编辑框出来后，可以把后面的提交的 pick 改为 squash git pull --rebase origin master git push -f origin \u0026lt;your-dev-branch\u0026gt; # git checkout master git pull origin master git merge \u0026lt;your-dev-branch\u0026gt; git push origin master git tag  打 tag  git tag -a {tag name} {commit id}  推送 tag 到远端  git push origin {tag name} ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/image_hu276afff563da1172921906a0b027a02a_24849_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/","title":"Linux 命令 —— git"},{"content":"ip 显示/操纵路由、设备、策略路由、隧道。\n概要 ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics } OPTIONS := { -V[ersion] | -h[uman-readable] | -s[tatistics] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -n[etns] name | -a[ll] | -c[olor] } OBJECT:\n address - 一个设备的IPv4/IPv6地址。（缩写：a 或 addr） addrlabel - 协议地址选择的标签配置。 （缩写：addrl） l2tp - IP隧道以太网(L2TPv3). link - 网络设备。如eth0。 （ 缩写：l） maddress - 多播地址。 （缩写：m 或 maddr） monitor - 监测netlink消息 mroute - 组播路由缓存条目。 （缩写：mr） mrule - 组播路由策略数据库中的规则。 neighbour - 管理 ARP 或 NDISC 缓存条目。（缩写：n or neigh） netns - 管理网络命名空间。 ntable - 管理邻居缓存的操作。 route - 路由表中的路由规则。 （缩写：r） rule - 路由策略数据库中的规则。 （缩写：ru tcp_metrics/tcpmetrics - 管理 TCP Metrics。 tunnel - IP隧道。 （缩写：t） tuntap - 管理 TUN/TAP 设备。 xfrm - 管理 IPSec 策略。 （缩写：x）  选项 -V, -Version 打印ip实用工具/iproute2的版本。 -h, -human, -human-readable 输出具有人类可读值的后跟后缀的统计信息。 -b, -batch \u0026lt;FILENAME\u0026gt; 从提供的文件或标准输入中读取命令并调用它们。首次失败将导致ip终止。 -force 不在批处理模式出错时终止ip。如果在执行命令期间出现任何错误，则应用程序返回代码将不为零。 -s, -stats, -statistics 输出更多信息。如果选项出现两次或更多次，则信息量会增加。通常，信息是统计信息或某些时间值。 -d, -details 输出更多细节信息。 -l, -loops \u0026lt;COUNT\u0026gt; 指定\u0026#39;ip address flush\u0026#39;逻辑在放弃之前将尝试的最大循环次数。默认值为10。零(0)表示一直循环到删除所有地址。 -f, -family \u0026lt;FAMILY\u0026gt; 指定要使用的协议族。 协议族标识符可以是inet，inet6，bridge，ipx，dnet，mpls或link之一。 如果此选项不存在，则从其他参数中猜出协议族。 如果命令行的其余部分没有提供足够的信息来猜测，则ip会使用一个默认值，通常是inet或any。 link是一个特殊的系列标识符，表示不涉及任何网络协议。 -4 -family inet 的简写. -6 -family inet6 的简写. -B -family bridge 的简写. -D -family decnet 的简写. -I -family ipx 的简写. -M -family mpls 的简写. -0 -family link 的简写. -o, -oneline 将每条记录输出到单一的行，用\u0026#39;\\\u0026#39;字符替换换行符。 当您想要使用wc或grep输出计数记录时，这很方便。 -r, -resolve 使用系统的名称解析程序来打印DNS名称而不是主机地址。 -n, -netns \u0026lt;NETNS\u0026gt; 将ip切换到指定的网络命名空间NETNS。 实际上它只是简化执行： ip netns exec NETNS ip [ OPTIONS ] OBJECT { COMMAND | help } 到 ip -n[etns] NETNS [ OPTIONS ] OBJECT { COMMAND | help } -a, -all 对所有对象执行指定的命令，它取决于命令是否支持此选项。 -c, -color 使用颜色输出。 -t, -timestamp 使用monitor选项时显示当前时间。 示例 查看详细的接口信息  ip -c -d -s -s link show ip -c -d -s -s link show ens33\n 查看接口地址  ip addr shwo ens33 ip -4 addr show ens33 ip -6 addr show ens33\n 为接口添加地址  ip addr add \u0026lt;IP 地址/前缀长度\u0026gt; [broadcast \u0026lt;广播地址\u0026gt;] dev \u0026lt;接口名\u0026gt; ip addr add 192.168.2.102/24 dev ens33 IPv6地址加-6即可。\n 删除接口地址  sudo ip addr del 192.168.2.102/24 dev ens33\n 启用接口  ip link set ens33 up\n 禁用接口  ip link set ens33 down\n 设置接口MAC地址 设置前需要先禁用接口\n ip link set ens33 address 00:0c:29:a5:ce:35\n 设置接口MTU  ip link set ens33 mtu 1500\n 添加802.1Q VLAN接口  ip link add link \u0026lt;接口名\u0026gt; name \u0026lt;子接口名\u0026gt; type vlan id sudo ip link add link ens33 name ens33.1 type vlan id 10\n 删除一个接口  sudo ip link del ens33.1\n 查看路由表  sudo ip route show\n 查看指定目标地址用的那条路由规则  ip route get 192.168.2.103\n 添加默认路由  ip route add default via \u0026lt;默认网关\u0026gt; [dev \u0026lt;出接口\u0026gt;]\n 添加路由表项  ip route add \u0026lt;目标 IP 地址/前缀长度\u0026gt; via \u0026lt;下一跳\u0026gt; [dev \u0026lt;出接口\u0026gt;] sudo ip route add 192.168.2.0/24 via 192.168.2.1 dev ens33\n 删除路由表项  sudo ip route del 192.168.3.0/24 dev ens33\n 查看ARP表  ip neigh show dev ens33\n 添加永久ARP条目  ip neigh add \u0026lt;IP 地址\u0026gt; lladdr \u0026lt;以冒号分割的 MAC 地址\u0026gt; dev \u0026lt;接口名\u0026gt; nud permanent ip neigh add 192.168.2.149 lladdr e0:d5:5e:a1:d0:d1 dev ens33 nud permanent\n 把动态ARP条目转换为永久ARP条目  ip neigh change \u0026lt;IP 地址\u0026gt; dev \u0026lt;接口名\u0026gt; nud permanent\n 删除ARP条目  ip neigh del \u0026lt;IP 地址\u0026gt; dev \u0026lt;接口名\u0026gt; ip neigh del 192.168.2.149 dev ens33\n 清空ARP表（不影响永久条目）  ip neigh flush all\n 参考  https://zhuanlan.zhihu.com/p/28155886 https://ss64.com/bash/ip.html linux man page  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/image_hu890b4a84832ec272513434c344ebda9b_82374_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/","title":"Linux 命令 —— ip"},{"content":"modprobe modprobe - 向Linux内核添加或从内核移除模块。\nmodprobe智能地从Linux内核添加或删除模块：\n 注意，模块名称中-和_没有区别（自动执行下划线转换）。 modprobe在模块目录/lib/modules/'uname -r'(符号冲突了，用'代替)中查找所有模块和其他文件。  除了/etc/modprobe.d目录是的可选配置文件。详见modprobe.d   modprobe还将以\u0026lt;module\u0026gt;.\u0026lt;option\u0026gt;的形式使用内核命令行上指定的模块选项。  modprobe.blacklist=\u0026lt;module\u0026gt;的形式使用黑名单。   如果在modulename之后给出了任何参数，它们将被传递给内核。  除了配置文件中列出的选项。    用法 modprobe [-v] [-V] [-C config-file] [-n] [-i] [-q] [-b] [modulename] [module parameters...] modprobe [-r] [-v] [-n] [-i] [modulename...] modprobe [-c] modprobe [--dump-modversions] [filename] 选项 -a, --all 加载命令行中指定的所有模块。 -b, --use-blacklist 此选项使modprobe将配置文件（如果有）中的黑名单命令也应用于模块名称。 它通常由udev(7)使用。 -C, --config 此选项会覆盖缺省配置目录（/etc/modprobe.d） 此选项通过安装或删除命令传递给 MODPROBE_OPTIONS环境变量中 的其他modprobe命令。 -c, --showconfig 输出config目录中的有效配置并退出。 --dump-modversions 打印出模块所需的模块版本信息列表。 分发版通常使用此选项，以便使用模块版本控制deps(依赖？)打包Linux内核模块。 -d, --dirname 模块的根目录，默认是`/`。 --first-time 通常，如果告知插入已存在的模块或删除不存在的模块，modprobe将成功（并且不执行任何操作）。 这是简单脚本的理想选择; 然而，更复杂的脚本通常想知道modprobe是否真的做了一些事情： 这个选项使modprobe失败，因为它实际上没有做任何事情。 --force-vermagic 每个模块都包含一个包含重要信息的小字符串，例如内核和编译器版本。 如果模块无法加载并且内核抱怨`version magic`不匹配，则可以使用此选项将其删除(抱怨)。 当然，这个检查是为了保护你的，所以这个使用选项是危险的，除非你知道你在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 --force-modversion 当使用CONFIG_MODVERSIONS集编译模块时，会创建模块使用（或由模块提供）的每个接口的版本的详细说明。 如果模块无法加载并且内核抱怨模块不同意某个接口的版本，则可以使用“--force-modversion”来完全删除版本信息。 当然，这项检查是为了保护您的，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -f, --force 尝试从模块中删除任何可能阻止加载的版本信息：这与使用--force-vermagic和--force-modversion相同。 当然，这些检查是为了您的保护，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -i, --ignore-install, --ignore-remove 此选项使modprobe忽略命令行中，指定的模块的配置文件（如果有）中的安装和删除命令（任何相关模块仍然受配置文件中为它们设置的命令的限制）。 当使用此选项时，无论是否仅使用--ignore-install或--ignore-remove中的一个或其他（而不是两个）更具体地进行请求，将忽略安装和删除命令。 详见modprobe.d(5)。 -n, --dry-run, --show 除了实际插入或删除模块（或运行安装或删除命令）之外，此选项可以执行所有操作。 与-v结合使用，可用于调试问题。 由于历史原因，--dry-run和--show实际上意味着相同的事情并且可以互换。 -q, --quiet 使用此标志，如果您尝试删除或插入无法找到的模块（并且不是别名或安装/删除命令），modprobe将不会打印错误消息。 但是，它仍将以非零退出状态返回。 内核使用它来机会性地探测可能存在的正在使用request_module的模块。 -R, --resolve-alias 打印与别名匹配的所有模块名称。这对于调试模块别名问题很有用。 -r, --remove 这个选项使modprobe删除而不是插入一个模块。 如果它依赖的模块也没有使用，modprobe讲尝试移除它们。 不像插入可以在命令行上指定多个模块。（意思是-r指定移除一个？） （在删除模块时指定模块参数没有意义） 通常没有理由删除模块，但有些错误的(buggy)模块需要它。 您的发行版内核可能尚未构建为支持删除模块。 -S, --set-version 设置内核版本，而不是使用uname(2)来决定内核版本（它决定了在哪里找到模块）。 --show-depends 显示模块的依赖，包括模块它自己。 列出模块（或别名）的依赖关系，包括模块本身。 这会生成一组(可能为空)模块文件名，每行一个，每个以“insmod”开头，通常由发行版使用，以确定生成initrd/initramfs映像时要包含哪些模块。 应用的安装命令以“install”为前缀。 它不运行任何安装命令。 请注意，modinfo(8) 可用于从模块本身提取模块的依赖关系，但不知道别名或安装命令。 -s, --syslog 此选项会导致错误消息通过syslog机制（如级别为LOG_NOTICE的LOG_DAEMON）而不是标准错误。 当stderr不可用时，也会自动启用此功能。 此选项通过安装或删除命令传递给MODPROBE_OPTIONS环境变量中的其他modprobe命令。 -V, --version 显示此程序的版本并退出。 -v, --verbose 打印程序正在做什么的信息。 通常modprobe只打印出错的信息。 此选项通过安装或删除命令传递给MODPROBE_OPTIONS环境变量中的其他modprobe命令。 示例 加载模块  modprobe vfat\n 卸载模块  modprobe -r vfat\n 查看模块的配置文件  modprobe -r\n 输出类似：\nalias ip6t_conntrack xt_conntrack alias ip_conntrack nf_conntrack_ipv4 alias symbol:__nf_conntrack_confirm nf_conntrack alias symbol:ct_sip_parse_request nf_conntrack_sip  symbol：应该是说这个是nf_conntrack中的符号（也就是函数）。【？？？】  疑问  modprobe -r输出的含义？  相关  modprobe.d insmod rmmod lsmod modinfo  参考 ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/image_huf81ae40bd4462c9a52fbc7063d25c656_36524_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/","title":"Linux 命令 —— modprobe"},{"content":"netstat 显示当前的连接情况。（UDP、TCP、UNIX、ICMP等） 显示路由表、网络接口列表、网络统计信息、多播信息、伪装连接等。\n1. 介绍 1.1 用法 netstat [-vWeenNcCF] [\u0026lt;Af\u0026gt;] -r netstat {-V|--version|-h|--help} netstat [-vWnNcaeol] [\u0026lt;Socket\u0026gt; ...] netstat { [-vWeenNac] -i | [-cWnNe] -M | -s } 1.2 选项 -r, --route 显示路由表 -i, --interfaces 显示接口列表 -g, --groups 显示多播组成员 -s, --statistics 显示网络统计信息 -M, --masquerade display masqueraded connections【？？？】 -v, --verbose 详细 -W, --wide 不要截断IP地址 -n, --numeric 不要解析IP成域名（直接使用IP，不经过域名服务器） --numeric-hosts 不要解析主机名 --numeric-ports 不要解析端口名 --numeric-users 不要解析用户名 -N, --symbolic 解析硬件名 【？？？】 -e, --extend 显示更多信息 -p, --programs 显示进程ID和进程名 -c, --continuous 持续列出网络状态 -l, --listening 显示LISTENING状态的连接 -a, --all, --listening 显示所有连接(默认: 显示CONNECTED的连接) -o, --timers 显示计时器 【netstat -to】 -F, --fib 显示转发信息库（Forwarding Information Base），默认显示 -C, --cache 显示路由缓存(routing cache)而不是FIB -t, --tcp 显示TCP信息 -u, --udp 显示UDP信息 -w, --raw 实现raw信息 -x, --unix 显示unix信息 --ax25 显示AMPR AX.25信息 --ipx 显示Novell IPX信息 --ddp 显示Appletalk DDP信息 \u0026lt;Socket\u0026gt;={-t|--tcp} {-u|--udp} {-w|--raw} {-x|--unix} --ax25 --ipx --netrom \u0026lt;AF\u0026gt;=Use \u0026#39;-6|-4\u0026#39; or \u0026#39;-A \u0026lt;af\u0026gt;\u0026#39; or \u0026#39;--\u0026lt;af\u0026gt;\u0026#39;; default: inet 可能的地址系列列表（支持路由）: inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) x25 (CCITT X.25) 2. 示例 查看端口是否被占用 netstat -tuanp | grep 53 获取进程ID/进程名 netstat -ap 显示网络统计数据 netstat -s 显示路由表 netstat -r 显示网络接口 netstat -i netstat -ie 显示LISTENING(监听)状态的连接 netstat -l 3. 疑问 masqueraded connections是什么？ ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/image_hueab6931f1bf6a7e35ac75d72182b8879_71547_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/","title":"Linux 命令 —— netstat"},{"content":"ssh 隧道 场景：家里内网机器 A 想要访问公司的内网机器 B。 条件：需要一个公网机器 C （假设IP是 1.1.1.1）。\n  打开公网机器的转发\n  在 B 上执行:\n  ssh -p 22 -NR 0.0.0.0:10443:0.0.0.0:443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：C 的信息 # 后面部分 0.0.0.0:443：B 的信息 注意：此时链接会一直保持，终端不会返回。\n 在 A 上执行:  ssh -p 22 -NL 0.0.0.0:10443:0.0.0.0:10443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：A 的信息 # 后面部分 0.0.0.0:10443：C 的信息 注意：此时链接会一直保持，终端不会返回。\n此时，在 A 上通过 localhost:10443 即可访问 B 的 443。\n端口映射 此方法相比上面的更为简化，直接把内网端口映射到外网设备上，直接访问外网设备映射的端口即可。\n 修改公网设备的 ssh 配置  sudo vi /etc/ssh/sshd_config # 设置 GatewayPorts yes # 重启 ssh 服务 sudo systemctl restart sshd  进行端口映射  在内网机器上：\nssh -p 22 -NR 0.0.0.0:10443:0.0.0.0:443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：公网机器信息 # 后面部分 0.0.0.0:443：内网机器信息 注意：此时链接会一直保持，终端不会返回。\n至此，端口映射完成，可以从任意可访问外网的机器上，访问 1.1.1.1:10443 即可访问到 内网机器的 443 端口。\n","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/image_hu771cd80d939141067a79c024c62c95e0_18175_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/","title":"Linux 命令 —— ssh"},{"content":"strace strace - 跟踪系统调用和信号。\n在最简单的情况下，strace运行指定的命令直到它退出。 它拦截并记录由进程调用的系统调用和进程接收的信号。 每个系统调用的名称，其参数和返回值都打印在标准错误或使用-o选项指定的文件上。 strace是一种有用的诊断，指导和调试工具。 跟踪中的每一行都包含系统调用名称，后跟括号中的参数及其返回值。如：\nopen(\u0026#34;/dev/null\u0026#34;, O_RDONLY) = 3 系统调用错误，如：(返回 -1，并打印出错原因)\nopen(\u0026#34;/foo/bar\u0026#34;, O_RDONLY) = -1 ENOENT (No such file or directory) 信号，如：\nsigsuspend([] \u0026lt;unfinished ...\u0026gt; --- SIGINT (Interrupt) --- +++ killed by SIGINT +++ 正在执行系统调用的同时，另一个线程/进程调用另一个系统调用，则strace将尝试保留这些事件的顺序并将正在进行的调用标记为未完成。 当调用返回时，它将被标记为已恢复：\n[pid 28772] select(4, [3], NULL, NULL, NULL \u0026lt;unfinished ...\u0026gt; [pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0 [pid 28772] \u0026lt;... select resumed\u0026gt; ) = 1 (in [3]) 系统调用被中断后重启，如：\nread(0, 0x7ffff72cf5cf, 1) = ? ERESTARTSYS (To be restarted) --- SIGALRM (Alarm clock) @ 0 (0) --- rt_sigreturn(0xe) = 0 read(0, \u0026#34;\u0026#34;..., 1) = 0 解引用结构指针，并根据需要显示成员。 在所有情况下，参数都以尽可能类似C的方式格式化。 例如“ls -l /dev/null”：\nlstat(\u0026#34;/dev/null\u0026#34;, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0 解引用字符指针：\nread(3, \u0026#34;root::0:0:System Administrator:/\u0026#34;..., 1024) = 422 用法 strace [-CdffhiqrtttTvVxxy] [-In] [-bexecve] [-eexpr]... [-acolumn] [-ofile] [-sstrsize] [-Ppath]... -ppid... / [-D] [-Evar[=val]]... [-uusername] command [args] strace -c[df] [-In] [-bexecve] [-eexpr]... [-Ooverhead] [-Ssortby] -ppid... / [-D] [-Evar[=val]]... [-uusername] command [args] 选项 -c 统计系统调用的次数、出错次数。在Linux上，这会尝试显示系统时间（在内核中运行的CPU时间），与墙上时间无关。 如果 -c 和 -f 或 -F 一起使用，仅保留所有跟踪进程的聚合总计。 -C 与-c类似，但在进程运行时也会打印常规输出。 -D 将跟踪器进程作为分离的孙子(detached grandchild)进程运行，而不是作为tracee的父进程。 这通过将tracee保持为调用进程的直接子进程来减少strace的可见效果 -d 在标准错误上输出strace的debug信息。 -f 跟踪由fork/vfork/clone调用所产生的子进程。 注意，如果是多线程，则\u0026#34;-p PID -f\u0026#34;将附加到PID进程的所有线程，而不仅是附加到带有 \u0026#34;thread_id = PID\u0026#34; 的线程。 -ff 如果\u0026#34;-o filename\u0026#34;选项生效，则每个进程的跟踪信息都将写入filename.pid中，其中pid是每个进程的进程ID。 这与-c不兼容，因为不保留每进程计数。 -F 此选项现已过时，它具有与-f相同的功能。 -h 打印帮助。 -i 在系统调用时打印指令指针。 -q 不显示有关附加/分离(attaching/detaching)的消息。 当输出重定向到文件并且命令是直接运行的(而不是附加(attaching))的，会自动发生这种情况。 -qq 不显示有关进程退出状态的消息。 -r 在进入每个系统调用时打印相对时间戳。 这记录了连续系统调用开始之间的时间差。 -t 在每一行跟踪信息前面添加时间（一天中的时间），最小单位是秒。 -tt 在每一行跟踪信息前面添加时间（一天中的时间），最小单位是毫秒。 -ttt 打印的时间将包括微秒，并且前导部分将被打印为自纪元以来的秒数。 -T 显示系统调用花费的时间。 这记录了每个系统调用的开始和结束之间的时间差。 -v 打印environment、stat、termios等调用的未缩写版本。 这些结构在调用中非常常见，因此默认行为显示结构成员的合理子集。 使用此选项可获得所有细节。 -V 打印strace的版本. -x 以十六进制字符串格式打印所有非ASCII字符串。 -xx 以十六进制字符串格式打印所有字符串。 -y 打印与文件描述符参数关联的路径。 -a column 对齐特定列中的返回值（默认列40）。 -b syscall 如果到达指定的系统调用，则从跟踪的进程中分离。 目前，仅支持execve系统调用。 这个选项很有用，如果你想要跟踪多线程的进程(需要-f)，但不想跟踪其（可能非常复杂的）孩子。 -e expr 用于修改要跟踪的事件或如何跟踪它们的一个限定表达式。 表达式的格式是： [qualifier=][!]value1[,value2]... qualifier是trace，abbrev，verbose，raw，signal，read，write之一，value是依赖于限定符的符号或数字。 默认限定符是trace。使用感叹号会取消该组值。 例如，\u0026#34;-e open\u0026#34;表示字面意思\u0026#34;-e trace=open\u0026#34;，这意味着仅跟踪“open”的系统调用。 相比之下，“-e trace=open”表示跟踪除open之外的每个系统调用。 此外，特殊值all和none都有明显的含义。 请注意，即使在引用的参数中，某些shell也会使用感叹号进行历史记录扩展。 注意，有些shell使用\u0026#34;!\u0026#34;来执行历史记录里的命令，如果是这样，您必须使用反斜杠转义感叹号。 -e trace=set 只跟踪指定的系统调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认为set=all。 -e trace=file 只跟踪有关文件操作的系统调用。（跟踪所有以一个文件名作为参数的系统调用） 你可以看做是：-e trace=open,stat,chmod,unlink,... 这对于查看进程引用的文件很有用。 此外，使用缩写将确保您不会意外忘记在列表中包含类似lstat的调用。 -e trace=process 只跟踪有关进程控制的系统调用。 这对于查看进程的fork，wait和exec步骤非常有用。 -e trace=network 跟踪所有与网络相关的系统调用. -e trace=signal 跟踪所有与信号相关的系统调用. -e trace=ipc 跟踪所有与IPC相关的系统调用. -e trace=desc 跟踪所有与文件描述符相关的系统调用. -e trace=memory 跟踪与内存映射相关的所有系统调用. -e abbrev=set 设定strace输出的系统调用的结果集。\u0026#34;-v\u0026#34;选项等于“abbrev=none”，默认为“abbrev=all”. -e verbose=set 对指定系统调用集的结构进行解引用。 默认值为 \u0026#34;verbose=all\u0026#34;。 -e raw=set 将指定的系统调用的参数以十六进制显示。（为指定的系统调用集打印原始的，未解码的参数。） 如果您不信任解码或者您需要知道参数的实际数值，这将非常有用。 -e signal=set 指定跟踪的系统信号.默认为all.如\u0026#34;signal=!SIGIO\u0026#34;(或者signal=!io),表示不跟踪SIGIO信号. -e read=set 以完整的16进制或ASCII形式，输出所有从指定文件描述符集中读取的数据。例如: \u0026#34;-e read=3,5\u0026#34;，读文件描述符3和5上的所有输入活动。 请注意请注意，这与read(2)系统调用的正常跟踪无关，该调用由选项\u0026#34;-e trace=read\u0026#34;控制。 -e write=set 以完整的16进制或ASCII形式，输出所有写到指定文件描述符集的数据。 -I interruptible 当strace可以被信号中断（例如按^C） 1：没有信号被阻挡; 2：解码系统调用时阻塞致命信号（默认）; 3：致命信号总是被阻止（默认为\u0026#39;-o FILE PROG\u0026#39;）; 4：致命信号和SIGTSTP（^Z）始终被阻止（有助于使strace -o FILE PROG不在^Z上停止）。 -o filename 把跟踪信息输出到filename指定的文件而不是输出到stderr。 如果指定\u0026#34;-ff\u0026#34;则会使用filename.pid。 如果参数以\u0026#34;|\u0026#34;或\u0026#34;!\u0026#34;开始，则参数的其余部分会被视作一个命令，并且所有输出都会通过管道给它(此命令)。【？？？】 这样可以方便地将调试输出传递给程序，而不会影响已执行程序的重定向。【？？？】 [If the argument begins with `|\u0026#39; or with `!\u0026#39; then the rest of the argument is treated as a command and all output is piped to it. This is convenient for piping the debugging output to a program without affecting the redirections of executed programs.] -O overhead 将跟踪系统调用的overhead（开销）设置为overhead微秒。 这对于覆盖默认启发式方法非常有用，可以猜测在使用-c选项进行计时系统调用时仅花费多少时间。 可以通过在没有跟踪的情况下对给定程序运行进行计时（使用time(1)）并将累积的系统调用时间与使用-c产生的总数进行比较来测量启发式的准确性。 -p pid 使用进程ID pid附加到进程并开始跟踪。 可以通过键盘中断信号（CTRL-C）随时终止跟踪。 strace会通过将自己从跟踪过程中分离出来而让它（它们）继续运行。 多个-p选项可用于附加到许多进程。 支持-p\u0026#34;`pidof PROG`\u0026#34;语法。 -P path 仅跟踪系统调用访问的路径。 多个-P选项可用于指定多个路径。 -s strsize 指定要打印的最大字符串大小（默认值为32）。 请注意，文件名不被视为字符串，并且始终完整打印。 -S sortby 按指定条件对-c选项打印的直方图的输出进行排序。 合法值是时间(time)，系统调用(call)，名称(name)，默认为时间。(根据什么来排序的意思) -u username 使用用户名所在的\u0026#34;用户ID\u0026#34;，“组ID“和”补充组“来运行命令。 此选项仅在以root身份运行，并且能够正确执行setuid（和/或）setgid二进制文件时有用。 除非使用此选项，否则setuid和setgid程序在没有有效权限的情况下执行。 -E var=val 在其环境变量列表中运行带有var=val的命令。 -E var 在将var传递给命令前，从继承的环境变量列表中将var删除。 示例 显示每个系统调用的相对时间  strace -r ls ls表示ls命令\n 显示系统调用时间（一天当中的时间/纪元时间）  strace -t ls strace -tt ls strace -ttt ls\n 打印与文件描述符相关联的路径  strace -y ls\n 跟踪指定进程  strace -p 123\n 把输出存在文件中  strace -o ls.log ls\n 相关  ltrace(1) time(1) ptrace(2) proc(5)  参考  https://man.linuxde.net/strace Linux man page  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/image_hu75bfb8e699f04dc0c75c201fe548798b_46326_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/","title":"Linux 命令 —— strace"},{"content":"tcpdump tcpdump - dump traffic on a network（转储网络上的流量）。\n用法 tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ -Q in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ --time-stamp-precision=tstamp_precision ] [ --immediate-mode ] [ --version ] [ expression ] 选项 -A 以ASCII格式打印每个数据包（减去其链接级别标题）。方便捕获网页。 -b 以ASDOT表示法而不是ASPLAIN表示法打印BGP数据包中的AS编号。 -B buffer_size --buffer-size=buffer_size 将操作系统捕获缓冲区大小设置为buffer_size。 -c count 收到count个包后退出。 -C file_size 在将原始数据包写入保存文件之前，检查该文件当前是否大于file_size，如果是，关闭当前保存文件并打开一个新文件。 第一个文件之后的文件将使用 -w 标志指定名称 ，后面带一个数字，从1开始向上。 file_size的单位是数百万字节（1,000,000字节，而不是1,048,576字节）。 -d 将编译后的数据包匹配代码以人类可读的形式转储到标准输出并停止。 -dd 将数据包匹配代码转储为 C 程序片段。 -ddd 将数据包匹配代码转储为十进制数字（以计数开头）。 -D --list-interfaces 打印系统上可用的网络接口列表以及 tcpdump 可以捕获数据包的列表。 对于每个网络接口，打印数字和接口名称，可能后跟接口的文本描述。 可以将接口名称或编号提供给 -i 标志以指定要捕获的接口。 这对于没有列出命令的系统很有用。 如果tcpdump是用缺少pcap_findalldevs()的libpcap建立的，则不支持此选项(-D)。 -e 在每个转储行上打印链接级标题。例如，这可以用于打印诸如以太网和IEEE 802.11之类的协议的MAC层地址。 -E 使用 spi@ipaddr algo:secret来解密发送到addr并包含安全参数索引值 spi的 IPsec ESP数据包。 可以用逗号或换行符分隔重复该组合。 请注意，此时支持为IPv4 ESP数据包设置机密。 算法可以是 des-cbc， 3des-cbc， blowfish-cbc， rc3-cbc， cast128-cbc或 none。默认为des-cbc。 只有在启用加密编译tcpdump的情况下才能解密数据包。 secret是ESP密钥的ASCII文本。如果前面带有0x，则将读取十六进制值。 此选项在RFC2406提出，不是在RFC1827。 该选项仅用于调试目的，不鼓励使用此选项和真正的“secret”密钥。通过在命令行上显示IPsec密钥，您可以通过ps和其他场合将其显示给其他人。 除了上面的语法之外，语法文件名可以用来让tcpdump读取提供的文件。 文件在收到第一个ESP数据包后打开，所以tcpdump应该具备所有可能需要的特殊权限。 -f 以数字方式而不是符号方式打印“外来(foreign)”IPv4地址。 “外部”IPv4地址的测试是使用正在进行捕获的接口的IPv4地址和网络掩码完成的。 -F file 使用file作为过滤器表达式的输入。命令行上给出的附加表达式将被忽略。 -G rotate_seconds 如果指定，每rotate_second秒回转(rotate)-w指定的文件。【回转？？？】 保存文件将具有-w指定的名称，该名称 应包含strftime定义的时间格式。 如果未指定时间格式，则每个新文件都将覆盖前一个。 每当生成的文件名不唯一时，tcpdump将覆盖预先存在的数据; 因此，不建议提供比捕获周期更粗糙的时间规范。 如果与 -C 选项一起使用，文件名将采用\u0026#34;file\u0026lt;count\u0026gt;\u0026#34;的形式。 -h --help 打印tcpdump和libpcap版本字符串，打印用法消息，然后退出。 --version 打印tcpdump和libpcap版本字符串并退出。 -H 尝试检测802.11s草图网格标头。 -i interface --interface=interface 指定监听的接口。 如果未指定，tcpdump将在系统接口列表中搜索编号最小的已配置接口（不包括环回），这可能会变成例如“eth0”。 在具有2.2或更高版本内核的Linux系统上， 可以使用“any” 的 接口参数来捕获来自所有接口的数据包。 请注意，“any”设备上的捕获将不会以混杂模式完成。 如果 支持-D标志，则如果系统上没有任何接口将该数字作为名称，则该标志打印的接口号可用作 接口参数。 -I --monitor-mode 将接口置于“监控模式(monitor mode)”; 这仅在IEEE 802.11 Wi-Fi接口上受支持，并且仅在某些操作系统上受支持。 请注意，在监视器模式下，适配器可能与与其关联的网络取消关联，因此您将无法使用具有该适配器的任何无线网络。 如果您在监视器模式下捕获并且未使用其他适配器连接到另一个网络，则可能会无法访问网络服务器上的文件或解析主机名或网络地址。 该标志将影响-L 标志的输出 。 如果未指定-I，则仅显示未处于监控模式时可用的链路层类型; 如果指定-I，则仅显示处于监视模式时可用的链接层类型。 --immediate-mode 在“立即模式(immediate mode)”下进行数据包捕获。 在此模式下，数据包一到达就会传送到tcpdump，而不是为了提高效率而进行缓冲。 这是打印数据包时的默认设置。 -j tstamp_type --time-stamp-type=tstamp_type 将捕获的时间戳类型设置为tstamp_type。 pcap-tstamp中给出时间戳类型的名称; 并非所有列出的类型都必须对任何给定的接口有效。 -J --list-time-stamp-types 列出接口支持的时间戳类型并退出。如果无法为接口设置时间戳类型，则不会列出时间戳类型。 --time-stamp-precision=tstamp_precision 捕获时，将捕获的时间戳精度设置为 tstamp_precision。 请注意，高精度时间戳（纳秒）的可用性及其实际精度取决于平台和硬件。 还要注意，当以纳秒级精度将捕获写入保存文件时，时间戳以纳秒分辨率写入，并且文件使用不同的幻数编写，以指示时间戳以秒和纳秒为单位; 并非所有读取pcap文件的程序都能读取这些捕获。 读取保存文件时，将时间戳转换为timestamp_precision指定的精度，并以该分辨率显示它们。 如果指定的精度小于文件中时间戳的精度，则转换将失去精度。 为支持的值timestamp_precision是微为微秒分辨率和纳米为十亿分之一秒分辨率。 默认值为微秒分辨率。 -K --dont-verify-checksums 不尝试验证IP，TCP或UDP校验和。 这对于在硬件中执行部分或全部校验和计算的接口非常有用; 否则，所有传出的TCP校验和都将被标记为错误。 -l 使stdout行缓冲。 如果您想在捕获数据时查看数据，则非常有用。 例如：tcpdump -l | tee dat 或： tcpdump -l \u0026gt; dat \u0026amp; tail -f dat 请注意，在Windows上，“行缓冲”意味着“无缓冲”，因此如果指定了-l，WinDump将单独写入每个字符。 -U 在其行为上类似于 -l，但它会导致输出为“数据包缓冲” 因此输出在每个数据包的末尾而不是在每行的末尾写入stdout; 这是在所有平台上缓冲的，包括Windows。 -L --list-data-link-types 在指定模式下列出接口的已知数据链接类型，然后退出。 已知数据链接类型列表可能取决于指定的模式; 例如，在某些平台上，Wi-Fi接口可能在不处于监控模式时支持一组数据链路类型和处于监控模式时的另一组数据链路类型。 -m module 从文件模块加载SMI MIB模块定义。可以多次使用此选项将多个MIB模块加载到tcpdump中。 -M secret 使用secret作为共享密钥，使用TCP-MD5选项（RFC 2385）验证TCP段中的摘要（如果存在）。 -n 不要将地址（即主机地址，端口号等）转换为名称。 -N 不要打印主机名的域名限定。例如，如果你指定这个标记，那么tcpdump将打印\u0026#34;nic\u0026#34;而不是\u0026#34;nic.ddn.mil\u0026#34;。 -# --number 在行的开头打印一个可选的包号。 -O --no-optimize 不要运行数据包匹配代码优化器。仅当您怀疑优化器中存在错误时，此选项才有用。 -p --no-promiscuous-mode 不要将接口置于混杂模式。 请注意，由于某些其他原因，接口可能处于混杂模式; 因此，\u0026#34;-p\u0026#34;不能用作\u0026#34;ether host {local-hw-addr}\u0026#34;或\u0026#34;ether broadcast\u0026#34;的缩写。 -Q direction --direction=direction 选择发送/接收方向上的哪些数据包应该被捕获。可能的值是“in”，“out”和“inout”。并非适用于所有平台。 -q 快速（安静？）输出。打印较少的协议信息，因此输出线更短。 -r file 从文件读取数据包（使用 -w 选项或其他编写pcap或pcapng文件的工具创建 ）。如果文件是\u0026#34;-\u0026#34;，则使用标准输入。 -S --absolute-tcp-sequence-numbers 打印绝对而非相对的TCP序列号(sequence numbers)。默认是相对。 -s snaplen --snapshot-length=snaplen Snarf snaplen来自每个数据包的数据字节而不是默认值262144字节。 由于快照有限而被截断的数据包在输出中用\u0026#34;[|proto]\u0026#34;，其中proto 是发生截断的协议级别的名称。 请注意，拍摄较大的快照会增加处理数据包所需的时间，并有效地减少数据包缓冲量。这可能会导致数据包丢失。 另请注意，拍摄较小的快照会丢弃传输层上方协议的数据，这会丢失可能很重要的信息。 例如，NFS和AFS请求和回复非常大，如果选择了太短的快照长度，则很多细节将不可用。 如果您需要将快照大小减小到默认值以下，则应将snaplen限制为捕获您感兴趣的协议信息的最小数量。 将snaplen设置 为0会将其设置为默认值262144，以便向后兼容最近的旧版本tcpdump的版本 。 -T type 强制将\u0026#34;expression\u0026#34;选择的数据包解释为指定的类型。 目前已知的类型是 aodv（Ad-hoc按需距离矢量协议），carp（通用地址冗余协议）， cnfp（Cisco NetFlow协议）， lmp（链路管理协议）， pgm（实用通用多播）， pgm_zmtp1（ZMTP/1.0内部PGM/EPGM），resp（REdis序列化协议）， radius（RADIUS）， rpc（远程过程调用）， rtp（实时应用程序协议）， rtcp（实时应用程序控制协议）， snmp（简单网络管理协议）， tftp（普通文件传输协议）， 增值税（视觉音频工具）， wb（分布式白板）， zmtp1（ZeroMQ消息传输协议1.0）和 vxlan（虚拟可扩展局域网）。 请注意，上面的pgm类型仅影响UDP解释，无论如何，本机PGM始终被识别为IP协议113。 UDP封装的PGM通常称为\u0026#34;EPGM\u0026#34;或\u0026#34;PGM/UDP\u0026#34;。 请注意，上面的pgm_zmtp1类型会同时影响本机PGM和UDP的解释。 在本机PGM解码期间，ODATA/RDATA分组的应用数据将被解码为具有ZMTP/1.0帧的ZeroMQ数据报。 在UDP解码期间，除了任何UDP分组之外，任何UDP分组都将被视为封装的PGM分组。 -t 不在每个转储行上打印时间戳。 -tt 打印时间戳，自1970年1月1日00:00:00，UTC以及自该时间以来的每秒分数，在每个转储行上。 -ttt 在每个转储行上的当前行和上一行之间 打印增量（微秒或纳秒分辨率，具体取决于--time-stamp-precision选项）。 默认值为微秒分辨率。 -tttt 在每个转储行上打印一个时间戳，以小时，分钟，秒和从午夜开始的一小时一秒为止。 -ttttt 在每个转储行上的当前行和第一行之间打印增量（微秒或纳秒分辨率，具体取决于 --time-stamp-precision选项）。默认值为微秒分辨率。 -u 打印未解码的NFS句柄。 -U --packet-buffered 如果未指定 -w 选项，或者如果指定了 -w 选项但是也指定了 --print 标志，则使打印的数据包输出\u0026#34;packet-buffered\u0026#34;； 即，当打印每个数据包的内容的描述时，它将被写入标准输出，而不是，在不写入终端时，仅在输出缓冲器填满时写入。 ( i.e., as the description of the contents of each packet is printed, it will be written to the standard output, rather than, when not writing to a terminal, being written only when the output buffer fills.) 如果指定了 -w 选项，则保存的原始数据包输出\u0026#34;packet-buffered\u0026#34;; 即，在保存每个数据包时，它将被写入输出文件，而不是仅在输出缓冲区填满时才写入。 该 -U 如果标志将不被支持, 如果旧版本tcpdump内置的libpcap缺少pcap_dump_flush（3PCAP） 函数。 -v 解析和打印时，产生（略多）详细输出。 例如，打印IP包中的生存时间，标识，总长度和选项。 还可以启用其他数据包完整性检查，例如验证IP和ICMP标头校验和。 使用-w 选项写入文件时 ，每秒报告一次捕获的数据包数。 -vv 更详细的输出。例如，从NFS回复数据包打印其他字段，并完全解码SMB数据包。 -vvv 更详细的输出。例如，telnet SB ... SE选项全部打印。与 -X 的Telnet选项被印刷在十六进制为好。 -V file 从文件中读取文件名列表。如果文件是\u0026#34;-\u0026#34;，则使用标准输入。 -w file 将原始数据包写入文件而不是解析并打印出来。 稍后可以使用-r选项打印它们。如果文件是“ - ”，则使用标准输出。 如果写入文件或管道，则此输出将被缓冲，因此从文件或管道读取的程序在收到后可能无法在任意时间内看到数据包。 使用 -U 标志可以在收到数据包后立即写入数据包。 MIME类型application/vnd.tcpdump.pcap已在IANA注册pcap文件。 文件扩展名.pcap是最常用的。 但是，许多操作系统和应用程序将使用扩展（如果存在）并建议添加一个（例如.pcap） 读取捕获文件时Tcpdump本身不检查扩展名，并且在写入时不添加扩展名（它在文件头中使用幻数）。 有关文件格式的说明，请参阅 pcap-savefile。 -W 与 -C 选项一起使用时 ，这将限制创建的文件数量达到指定的数量，并从头开始覆盖文件，从而创建一个“旋转”缓冲区。 此外，它会将具有足够前导0的文件命名为支持最大文件数，从而允许它们正确排序。 与 -G 选项一起使用时 ，这将限制创建的旋转转储文件的数量，在达到限制时退出状态0。 如果两者配合使用 -C 和 -G， 该 -W 选项将目前被忽略，并且只会影响的文件名。 -x 解析和打印时，除了打印每个数据包的标头外，还要以十六进制格式打印每个数据包的数据（减去其链接级别标题）。 将打印整个数据包或snaplen字节中较小的一个 。 请注意，这是整个链路层数据包，因此对于填充（例如以太网）的链路层，当较高层数据包短于所需填充时，也将打印填充字节。 -xx 解析和打印时，除了打印每个数据包的标头外，还要打印每个数据包的数据， 包括其链接级别标题，以十六进制表示。 -X 解析和打印时，除了打印每个数据包的标题外，还要以十六进制和ASCII格式打印每个数据包的数据（减去其链接级别标题）。 这对于分析新协议非常方便。 -XX 解析和打印时，除了打印每个数据包的标头外，还要以 十六进制和ASCII格式打印每个数据包的数据， 包括其链接级别标题。 -y datalinktype --linktype=datalinktype 设置要在将数据包捕获到datalinktype时使用的数据链接类型。 -z postrotate-command 与-C 或 -G 选项一起使用时 ，这将使 tcpdump 运行\u0026#34;postrotate-command file\u0026#34;， 其中 file 是每次轮换后关闭的savefile（保存文件，-w创建）。 例如，指定 -z gzip 或 -z bzip2 将使用gzip或bzip2压缩每个savefile。 请注意，tcpdump将使用最低优先级并行执行命令，以便不会干扰捕获过程。 如果您想使用一个本身带有标志或不同参数的命令，您总是可以编写一个shell脚本， 它将保存文件名作为唯一参数，制作标志和参数排列并执行您想要的命令。 -Z user --relinquish-privileges=user 如果 tcpdump 以root运行，打开所述捕获装置或输入savefiles之后， 但在打开任何savefiles输出之前，将用户ID改为user和组ID改为user的主组。 默认情况下，在编译时也可以启用此行为。 expression 选择要转储的数据包。如果没有给出表达式(expression)，则网络上的所有数据包都将被转储。 否则，只会转储表达式为\u0026#34;true\u0026#34;的数据包。 有关表达式语法，请参阅 pcap-filter。 该表达式(expression)参数可被传递给和tcpdump作为单一壳牌参数，或作为多个shell参数，取其更方便。 通常，如果表达式包含Shell元字符，例如用于转义协议名称的反斜杠，则更容易将其作为单个引用参数传递， 而不是转义Shell元字符。在解析之前，多个参数与空格连接在一起。 示例 指定接口+主机，写到文件  tcpdump -i br-lan1 -w x_xxxx.cap -v host xx.xx.xx.xx\n 指定端口范围  tcpdump -i ens33 udp portrange 67-68 -v\n 捕获和指定主机相关的数据包  tcpdump host sundown\n 打印指定主机间的流量  tcpdump host helios and ( hot or ace )\n  helios 和 hot 、 helios 和 ace之间的流量。  打印所有本地主机和Berkeley主机间的流量  tcpdump net ucb-ether\n 通过互联网网关snup打印所有ftp流量(请注意，引用该表达式是为了防止shell（错误地）解释括号）  tcpdump \u0026lsquo;gateway snup and (port ftp or ftp-data)\u0026rsquo;\n 要打印既不是来自本地主机也不是发往本地主机的流量(如果你通往另一个网络，那么这些东西永远不应该进入你的本地网络)  tcpdump ip and not net localnet\n 打印涉及非本地主机的每个TCP对话的开始和结束数据包（SYN和FIN数据包）  tcpdump \u0026lsquo;tcp[tcpflags] \u0026amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet\u0026rsquo;\n 打印与端口80之间的所有IPv4 HTTP数据包  仅打印包含数据的数据包，而不打印例如SYN和FIN数据包以及仅ACK数据包 tcpdump \u0026lsquo;tcp port 80 and (((ip[2:2] - ((ip[0]\u0026amp;0xf)\u0026laquo;2)) - ((tcp[12]\u0026amp;0xf0)\u0026raquo;2)) != 0)\u0026rsquo;\n 打印通过网关snup发送的长度超过576字节的IP数据包  tcpdump \u0026lsquo;gateway snup and ip[2:2] \u0026gt; 576\u0026rsquo;\n 打印未通过以太网广播或多播发送的IP广播或多播数据包  tcpdump \u0026lsquo;ether[0] \u0026amp; 1 = 0 and ip[16] \u0026gt;= 224\u0026rsquo;\n 打印所有不是回应请求/回复的ICMP数据包（即不ping数据包）  tcpdump \u0026lsquo;icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply\u0026rsquo;\n 参考  https://www.tcpdump.org/manpages/tcpdump.1.html linux man page\n ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/image_hu0e90a58acef5f9348c08b73e09b51191_56903_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/","title":"Linux 命令 —— tcpdump"},{"content":"vmstat 报告虚拟内存统计信息：进程，内存，分页，块IO，陷阱(traps)、磁盘和cpu活动。\n用法 vmstat [options] [delay [count]] vmstat [-f] [-s] [-m] vmstat [-S unit] vmstat [-d] vmstat [-p disk partition] vmstat [-V] 选项 delay 更新之间的延迟，以秒为单位。如果未指定延迟，则仅打印一个报告：自引导以来的平均值。 count 更新次数。如果未指定计数且指定了延迟(delay)，则count默认为无穷大。 -a, --active 显示活动和非活动内存（2.5.41及之后的版本） -f, --forks 显示自引导以来的fork数。 这包括fork，vfork和clone系统调用，并且是相当于创建的任务总数。 每个进程由一个或多个任务表示，具体取决于线程用法。此显示不重复（也就是只显示一次）。 -m, --slabs 显示slabinfo。【相关字段含义见下面部分】 -n, --one-header 标题仅显示一次而不是定期显示。 -s, --stats 显示各种事件计数器和内存统计信息。此显示不重复（也就是只显示一次）。 -d, --disk 报告磁盘信息（2.5.70及之后版本） -D, --disk-sum 报告一些有关磁盘活动的摘要统计信息。 -p, --partition device 分区的详细统计信息。 (2.5.70及之后版本). -S, --unit character 更换输出的单位：1000(k)，1024(K)，1000000(m)，1048576(M) 字节。 注意，这不会改变交换(si/so)或块(bi/bo)字段。 -t, --timestamp 为每一行附加时间戳。 -w, --wide 宽屏输出模式（对于具有较高内存量的系统非常有用，其中默认输出模式会受到不必要的列断裂影响）。 输出宽度会超过每行80个字符。 -V, --version 显示版本信息并退出。 -h, --help 显示帮助信息并退出。 字段描述 VM 模式字段描述  进程  r: 可运行进程的数量 (正在运行+就绪状态)。 b: 处于不可中断睡眠的进程数量。   内存  swpd: 使用的虚拟内存量。 free: 空闲内存量。(idle) buff: 用作缓冲区(buffer)的内存量。 cache: 用作缓存(cache)的内存量。 inact: 非活动内存量。（-a选项） active: 活动内存量。（-a选项）   交换内存  si: 从磁盘交换的内存量（/s）。 so: 交换到磁盘的内存量（/s）。   IO  bi: 从块设备接收的块数（blocks/s）。 bo: 发送到块设备的块数（blocks/ s）。   系统  in: 每秒的中断数，包括时钟。 cs: 每秒上下文切换次数。   CPU  这些是总CPU时间的占比。 us: 运行非内核代码所花费的时间。 (用户时间, 包括nice时间) sy: 运行内核代码所花费的时间。 (系统时间) id: 空闲时间。在2.5.41版本之前，这包括IO等待时间。 wa: 等待IO的时间。在2.5.41版本之前，包含在空闲状态。 st: 从虚拟机中窃取的时间。在Linux 2.6.11之前，未知。【？？？】    DISK 模式字段描述  读(reads)  total: 完全成功的读总数（次数还是字节？应该是次数，因为换单位(K或M)，数值也不改变）。 merged: 分组(groups)读取(导致一个I/O)。 sectors: 成功读取的扇区数。 ms: 花在读上的毫秒数。   写(writes)  total: 完全成功的写总数。 merged: 分组写 (导致一个I/O)。 sectors: 成功写的扇区数。 ms: 花在写上的毫秒数。   IO(input/output)  cur: 正在处理的IO。 s: 花在I/O上的秒数。    DISK PARTITION 模式字段描述  reads: 发送到此分区上的读的总数。 read sectors: 分区上读的扇区总数。 writes: 发送到此分区上的写的总数。 requested writes: 此分区发出的写请求总数。  SLAB 模式字段描述  cache: 缓存名称。 num: 当前活动对象数量。 total: 有效/可用对象总数。 size: 每个对象的大小。 pages: 具有至少一个活动对象的页面数。  示例 显示内存、CPU、中断、fork等总览信息  vmstat -s\n 保持更新固定次数  vmstat -a 2 // 每2s更新一次，一直更新 vmstat -a 1 100 // 每1s更新一次，更新100次\n 显示启动以来的fork数量  vmstat -f\n 显示某个分区统计信息  vmstat -p sda1\n 更换输出单位  vmstat -s -S M\n 显示slab内存对象信息  vmstat -m\n 疑问  st: 从虚拟机中窃取的时间？ 磁盘分区的相关字段不理解？  参考  Linux man page  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/image_hu9cf09c1c436f94f04ea86d28afa0e688_52288_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/","title":"Linux 命令 —— vmstat"},{"content":"信号  一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为：  1.信号发送和信号接收  待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数:  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; // 发送sig指定信号到pid进程 int kill(pid_t pid, int sig); // 向自己发送SIGALRM信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题   待处理信号被阻塞。\n 例如：一个进程捕获一个信号SIGINT然后去处理程序处理信号，此时又来一个SIGINT信号，此信号会被阻塞。[疑问][1] （第2个信号不是SIGINT信号，那是否也还是阻塞？）    待处理信号不会排队等待。\n 任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？）    系统调用可以被中断。\n 如read、wait、accept这样的慢速系统调用被信号打断，但是信号处理函数返回后不再继续被打断的系统调用，而是立即返回错误，errno为EINTR。    详见ex_SIGCHLD.c\n  教训：不可以用信号来对其他进程中发生的时间计数\n  3. 显式地阻塞和取消阻塞信号 这2个操作在某些情况下也是什么有用的，且必须的，能消除一些竞争条件。（详见ex3和ex4）\n 相关函数  #include \u0026lt;signal.h\u0026gt;// 设置阻塞、不阻塞、添加到阻塞 int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); // 添加signo到set中 int sigaddset(sigset_t *set, int signo); // 吧signo从set中删除 int sigdelset(sigset_t *set, int signo); // 初始化set为空集 int sigemptyset(sigset_t *set); // 将每个(所有？)信号添加到set中 int sigfillset(sigset_t *set); // 判断signo是否是set的成员，是返回1，否则0 int sigismember(const sigset_t *set, int signo); A.拓展  进程组。详见1.进程 Linux信号  Linux信号  回收子进程的方式：用SIGCHLD信号。子进程终止时，会发送SIGCHLD信号给其父进程。【详见ex_SIGCHILD.c】 可移植的signal函数。【详见isshe_signal.h和isshe_signal.c】 非本地跳转：可和信号一起实现程序重启功能。【详见ex_restart，macOS上行为和书本有所不同】  相关函数  #include \u0026lt;setjmp.h\u0026gt;int setjmp(jmp_buf env); void logjmp(jmp_buf env, int retval); // 下面两个可以和信号一起用 int sigsetjmp(sigjmp_buf env, int savesige); void siglongjmp(sigjmp_buf env, int retval);   B.疑问  2.信号处理问题中： [1]第2个信号不是SIGINT信号，那是否也还是阻塞？ [2]不同类型的信号就可以有多个吗？  C.参考  《深入理解计算机系统》  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/Linux_signal_huec7bd37c00e9f0f66a7da81ead81d61e_182649_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/","title":"操作系统 —— 信号"},{"content":"进程 进程是操作系统中最核心的概念。\n 定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象：  一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。   逻辑流(逻辑控制流）：程序计数器PC值的序列。  异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。   并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发(concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。  1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程；    1.进程地址空间 1.1 典型进程地址空间1  典型进程地址空间1 \n 代码段起始地址：  32位：0x08048000 64位：0x00400000   进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。  1.2 典型进程地址空间2  典型进程地址空间2 \n2. 进程状态 2.1 状态转换图   状态转换图   2.2 基本状态  1）运行态：进程实际占用CPU； 2）就绪态：可运行； 3）阻塞态：除非某种外部事件发生(使进程满足运行条件)，否则进程不能运行。  2.3 引入的状态：  创建状态； 终止状态； 挂起状态；（图中没有）  3. 进程控制 3.1 进程创建与终止  导致进程创建的主要事件：  1）系统初始化； 2）正在运行的程序执行了创建进程的系统调用； 3）用户请求创建一个新进程； 4）一个批处理作业的初始化；   导致进程终止的主要事件：  1）正常退出（自愿的）  A.从main返回； B.调用exit； C.调用_exit或_Exit; D.最后一个线程从其启动例程返回； E.从最后一个线程调用pthread_exit()；   2）出错退出（自愿的）  调用abort   3）严重错误/被其他进程杀死（非自愿）  接到终止信号； 最后一个线程对取消(cancellation)请求做出响应；     相关函数  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; // 进程创建 pid_t fork(void); // 进程退出 // 进行一些清理（关闭文件描述符之类的）,然后返回内核 void exit(int status); // 下面两个直接返回内核 void _Exit(int status); void _exit(int status);  fork失败的主要原因：  系统中已经有太多进程。 该实际用户ID的进程数超过了系统限制。    4. 守护进程  守护进程：  一种生存期长的进程。 后台运行； 没有控制终端；    4.1 编程规则  1）调用umask将文件模式创建屏蔽字设置为一个已知的值（通常是0）；【疑问？！】 2）调用fork，然后使父进程exit； 3）调用setsid创建一个新会话；  a）进程成为新会话的首进程； b）成为一个新进程组的组长进程； c）没有控制终端；   4）将当前工作目录更改为根目录； 5）关闭不再需要的文件描述符； 6）[选]打开/dev/null使进程具有文件描述符0/1/2。  使所有读标准输入，写标准输出/错误输出的库例程都不会产生效果。    4.2 示例  见守护进程示例  4.3 守护进程的惯例  锁文件放/var/run目录，命名为name.pid。 配置放/etc目录，命名为name.conf。 可用命令行启动。  通常由/etc/rc*或/etc/init.d/*启动。 守护进程终止时，应当自动重启。(/etc/inittab中为守护进程添加respawn记录项【macOS没有此文件！】)   守护进程可通过SIGHUP信号，重新读取配置（当配置更新时）。  5. 进程实现  进程表：操作系统维护的一张表格——一个结构数组。 进程表项：也称进程控制块，是进程表的表项。 典型系统中的一些关键字段：     进程管理 存储管理 文件管理     寄存器 正文段指针 根目录   程序计数器 数据段指针 工作目录   程序状态字 堆栈段指针 文件描述符   堆栈指针  用户ID   进程状态  组ID   优先级     调度参数     进程ID     父进程     进程组     信号     \u0026hellip;      A.拓展 A.1 进程组  进程组：在类UNIX系统中，进程和它的所有子进程以及后裔进程共同组成一个进程组。 进程组相关函数:  #include \u0026lt;unistd.h\u0026gt; // 获取进程组ID pid_t getpgrp(void); // 改变自己或其他进程的进程组 // pid == 0: 使用当前进程 // pgid== 0: pid进程的PID作为进程组ID。 int setpgid(pid_t pid, pid_t pgid);  僵死进程/僵尸进程：终止，但未被回收的进程。  进程已经终止了，但内核仍保留它的某些状态直到父进程回收它为止。   相关函数:  #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; pid_t waitpid(pid_t pid, int *status, int options); pid_t wait(int *status); unsigned int sleep(unsigned int secs); int pause(void); A.2 子进程回收方式  回收子进程的方式：用SIGCHLD信号。子进程终止时，会发送SIGCHLD信号给其父进程。 【详见ex_SIGCHLD.c】  A.3 C程序的启动和终止  C程序的启动和终止 \n 内核使程序执行的唯一方法：exec!  A.4 进程资源限制  见《Unix环境高级编程》p175  A.5 7个exec的关系  7个exec的关系 \nA.6 ps命令中进程状态  R: TASK_RUNNING，可执行状态。 S: TASK_INTERRUPTIBLE，可中断的睡眠状态。 D: TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。 T: TASK_STOPPED/TASK_TRACED，暂停状态或跟踪状态。 Z: TASK_DEAD – EXIT_ZOMBIE，退出状态，进程成为僵尸进程。 X: TASK_DEAD – EXIT_DEAD，退出状态，进程即将被销毁。  B.疑问/不懂  孤儿进程组? 文件模式创建屏蔽字是什么？有何作用？(umask()设置的那个))  C.参考  https://blog.csdn.net/i_scream_/article/details/51569355 《Unix环境高级编程》 《现代操作系统》 《深入理解计算机系统》  ","date":"2021-12-13T02:51:23-04:00","image":"https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/process_address_map_hu575c6395d5e84185e674e7125c58f205_133704_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/","title":"操作系统 —— 进程"},{"content":"VLAN VLAN - 虚拟局域网（Virtual Local Area Network）。 在IEEE 802.1Q中，给定以太网上的最大VLAN数为4094。（12位VID。减去头尾的0和4095）\n作用  VLAN可以为网络提供以下作用：  广播控制 带宽利用 降低延迟 安全性（非设计作用，本身功能所附加出的）   采用虚拟局域网技术实现交换机以太网的广播隔离。 一个VLAN相当于OSI模型第2层的广播域，它能将广播控制在一个VLAN内部。 不同VLAN之间或VLAN与LAN/WAN的数据通信必须通过第3层（网络层）完成。  原理（划分方式） 物理层(physical layer)  以交换机端口作为划分VLAN的基础。 适合规模不大的组织。  数据链路层(data link layer)  以每台主机的MAC地址作为划分VLAN的基础。 实现方法：  创建一个MAC与VLAN映射的数据库。 当网络设备连接到端口后，交换机向VMPS(VLAN管理策略服务器)请求这个数据库。 找到相应的映射，完成VLAN的分配。   优点：  计算机物理位置的不同，也不影响VLAN的运作。   缺点：  人为建立MAC与VLAN的映射关系；因此导致管理复杂度增加。    网络层  以IP地址作为划分VLAN的基础；以子网视为VLAN设置的依据。【？？？】 优点：  网管人员已经将内部网段做好规划与分配后，将可大辐降低规划并设置VLANs架构的复杂度。   缺点：  交换机需要对帧进行处理（原本不需要），降低交换机接收和分派分组的效率。    ","date":"2021-12-12T11:35:47-04:00","image":"https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/image_hu1ddfb084b38ca84c30bb52cb3ae9d2f0_60039_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/","title":"VLAN 介绍"},{"content":"ARP协议 ARP（Address Resolution Protocol）：地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。\n工作过程 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析成主机B的MAC地址(如果A/B不同网段，则A解析的应该是下一跳的MAC地址)，以下为工作流程：\n 第1步：主机A根据路由表内容，确定用于访问主机B的转发IP地址。主机A在本地ARP缓存中查找与主机B的IP匹配MAC地址。 第2步：如果主机A没有找到映射，则将ARP请求帧广播到本地网络上的所有主机。  收到请求的主机检查自己的IP是否匹配，不匹配就丢弃此ARP请求。   第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。  问题 什么是ARP欺骗？  地址解析协议是建立在网络中各个主机可互相信任的基础上的，收到应答报文的主机，不会校验报文的真实性，就会加到ARP缓存中。 由此，攻击者可以向某一主机发送伪ARP应答报文，使此主机发送的信息无法到达预期的主机或者到达错误的主机，这就是ARP欺骗。  ","date":"2021-12-12T11:35:47-04:00","image":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/image_hucd6041f2c8064f45bbea052ae228c089_60588_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/","title":"网络协议 —— ARP"},{"content":"DHCP DHCP - 动态主机设置协议（Dynamic Host Configuration Protocol）。 DHCP是一个应用层协议。基于UDP。\n作用  用于内网或网络服务供应商自动分配IP给用户。 作为内部管理员对所有计算机进行中央管理的手段。  历史  DHCP在1993年10月成为标准协议，它的前身是BOOTP协议。 BOOTP：BOOTP是一种网络协议，让电脑或其他周边仪器可以从服务器下载启动程序。  数据包类型  DHCP发现（DISCOVER）：client在物理子网上发送广播来寻找可用的服务器。 DHCP提供（OFFER）：当DHCP服务器收到一个来自客户的IP租约请求时，它会提供一个IP租约。 DHCP请求（REQUEST）：当客户PC收到一个IP租约提供时，它必须告诉所有其他的DHCP服务器它已经接受了一个租约提供。 DHCP确认（Acknowledge，ACK）：确认租约，包含租期和客户可能请求的其他所有配置信息。 DHCP释放(RELEASE)：客户端向DHCP服务器发送一个请求以释放DHCP资源，并注销其IP地址。 DHCP NAK：服务器回复客户，客户要求的网址不能被分配。  原理/流程  客户主机发送DHCP服务器发现(DISCOVER)广播包。 服务器收到DISCOVER包后，回复OFFER单播或广播包。【疑问？】 客户主机收到OFFER包后，发送REQUEST广播包。 服务器回复ACK单播或广播包。包含分配的IP及网关IP(next server IP)、租约等。   典型DHCP会话的模式 \n协议结构  +-------+--------+--------+--------+ |8 bits | 8 bits | 8 bits | 8 bits | +-------+--------+--------+--------+ | Op | Htype | Hlen | Hops | +-------+--------+--------+--------+ | Xid | +----------------------------------+ | Secs | Flags | +----------------+-----------------+ | Ciaddr | +----------------------------------+ | Yiaddr | +----------------------------------+ | Siaddr | +----------------------------------+ | Giaddr | +----------------------------------+ | Chaddr (16 bytes) | +----------------------------------+ | Sname (64 bytes) | +----------------------------------+ | File (128 bytes) | +----------------------------------+ | Option (variable) | +----------------------------------+  Op: 信息类型。如：客户端请求为1，服务器回复为2。 Htype：硬件类型。如：Ethernet(0x01) Hlen: 硬件地址长度。如：6。（MAC地址） Hops: 跳数。 Xid：传输ID。 Secs: 过去的时间。【疑问】 Flags：标记。 Ciaddr：客户端IP地址。（这里应该是续约的时候用的） Siaddr：下一个服务器IP地址。 Yiaddr：你的IP。（分配给客户机的IP） Giaddr：中继代理IP。【？？？】 Chaddr：客户机硬件地址。（Ethernet中就是Mac地址） Sname：服务器主机名称。 File：文件名。 Options：选项。详见rfc2132  1：子网掩码； 3：路由(网关)； 12：主机名 50：请求的IP地址 51：租约时间 53：DHCP消息类型。即上面的几种类型。 54：服务器标识。    疑问 DHCP服务器是否可以把一台主机拉黑？  这个应该由DHCP软件提供。  服务器回复为什么是单播或广播包？  Flags中设置BROADCAST = 0时，则是单播；否则是广播。这是为了健壮性，同时兼容单播和多播。  Secs字段是哪一个时间段？  从获取到IP地址或者续约过程开始到现在所消耗的时间。  Giaddr字段作用是什么？  giaddr: 中继代理地址。 中继代理相关详见：博客  相关  DHCP: RFC 2131 DHCP6: RFC 3315 DHCP wiki DHCP wiki中文 rfc2132  ","date":"2021-12-12T11:35:47-04:00","image":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/dhcp_hudbf177609d4e03da36b00b06f63101bd_20695_120x120_fill_box_smart1_3.png","permalink":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/","title":"网络协议 —— DHCP"},{"content":"DNS DNS - 域名系统（Domain Name System）。\n 是一个将域名和IP地址进行映射的分布式数据库。 DNS是应用层协议，使用TCP和UDP的53端口。 每一级域名长度的限制是63个字符，域名总长度不能超过253个字符。  作用  将对人友好的域名转换为对计算机友好的IP地址。  原理/过程 域名层级\n主机名.次级域名.顶级域名.根域名 host.sld.tld.root www.isshe.xyz.root abc.isshe.xyz.root 分级查询：从根域名开始，依次查询每一级域名的NS记录。\n 从根域名服务器查询顶级域名服务器的NS记录和A记录；  根域名服务器是总所周知的，不用查。   从顶级域名服务器查询次级域名服务器的NS记录和A记录； 从次级域名服务器查询主机名的A记录；  分级查询示例：www.isshe.xyz\n dig +trace www.isshe.xyz 进行查看\n  列出根域名服务器：  . 227343 IN NS e.root-servers.net. . 227343 IN NS k.root-servers.net. . 227343 IN NS i.root-servers.net. . 227343 IN NS d.root-servers.net. . 227343 IN NS j.root-servers.net. . 227343 IN NS m.root-servers.net. . 227343 IN NS b.root-servers.net. . 227343 IN NS c.root-servers.net. . 227343 IN NS h.root-servers.net. . 227343 IN NS f.root-servers.net. . 227343 IN NS l.root-servers.net. . 227343 IN NS a.root-servers.net. . 227343 IN NS g.root-servers.net.  查询xyz.的结果：  xyz. 172800 IN NS x.nic.xyz. xyz. 172800 IN NS y.nic.xyz. xyz. 172800 IN NS z.nic.xyz. xyz. 172800 IN NS generationxyz.nic.xyz. ... ;; Received 669 bytes from 192.58.128.30#53(j.root-servers.net) in 651 ms  查询isshe.xyz.的结果：  isshe.xyz. 3600 IN NS f1g1ns1.dnspod.net. isshe.xyz. 3600 IN NS f1g1ns2.dnspod.net. ... ;; Received 581 bytes from 194.169.218.42#53(x.nic.xyz) in 245 ms  查询www.isshe.xyz.的结果：  www.isshe.xyz. 600 IN CNAME isshe.coding.me. isshe.xyz. 86400 IN NS f1g1ns1.dnspod.net. isshe.xyz. 86400 IN NS f1g1ns2.dnspod.net. ;; Received 135 bytes from 14.215.155.156#53(f1g1ns1.dnspod.net) in 10 ms 协议格式 0 16 32 0 16 32 +-------------------+-------------------+ +---------------------------------------+ | Transaction ID | Flags | / Name / +-------------------+-------------------+ / / | Questions | Answer RRs | +-------------------+-------------------+ +-------------------+-------------------+ | Type | Class | | Authority RRs | Additional RRs | +-------------------+-------------------+ +-------------------+-------------------+ / / Question / +---------------------------------------+ / Answers / +---------------------------------------+ / Authoritaty / +---------------------------------------+ / Additional / +---------------------------------------+ Transaction ID  会话ID，DNS报文的ID标识。 请求和应答报文的这个字段相同。  Flags  标志：  +----+--------+----+----+----+----+--------+-------+ | QR | opcode | AA | TC | RD | RA | (zero) | rcode | +----+--------+----+----+----+----+--------+-------+ 1 4 1 1 1 1 3 4  QR: 查询/响应标记，0查询，1响应。 opcode：0标准查询，1反向查询，2服务器状态请求。 AA：授权回答。 TC：可截断的。 RD：期望递归。 RA：可用递归。 rcode：表示返回码。0没有差错，2服务器错误，3名字差错  Question 0 16 32 +---------------------------------------+ / Name / / / +-------------------+-------------------+ | Type | Class | +-------------------+-------------------+  Name：查询的域名名称。按Lable划分(isshe.xyz，为2个lable)，以'\\0'结尾；可能为奇数个字节。 Type：查询类型。A：主机。 Class：查询的协议类。IN：internet。  Answer/Authority/Additional 0 16 32 +---------------------------------------+ / Name / / / +-------------------+-------------------+ | Type | Class | +-------------------+-------------------+ | TTL | +---------------------------------------+ | RdLength | Rdata / +-------------------+ / | / +---------------------------------------+  Name: 域名。 Type：类型。 Class：Rdata的类。 TTL：资源记录的生存时间。0表示只能被传输，不能被缓存。（无符号整型） RdLenght：Rdata的长度。 Rdata：资源数据，表示记录。格式和Type、Class有关。如Type=A、Class=IN，Rdata就是一个IP地址。  RRs Questions：指明Question的数量。 Answer RRs：指明Answer的数量。 Authority RRs：指明Antuority的数量。 Additional RRs：指明Additional的数量。\n记录类型  详见DNS记录类型列表\n 常见记录类型：\n A：主机记录（Address）。 NS：域名服务器记录（Name Server）。  返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。   CNAME：规范名称记录，当前查询域名是另一个域名的跳转。（即别名记录，指向某个A记录） AAAA：IPv6主机记录。 SRV：服务位置记录。 MX: 邮件记录(Mail eXchange)，返回接收电子邮件的服务器地址。 PTR：逆向查询记录（Pointer Record），从IP查域名。  报文示例 报文示例-查询  +---------------------------------------------------+ Header | OPCODE=SQUERY | +---------------------------------------------------+ Question | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A | +---------------------------------------------------+ Answer | \u0026lt;empty\u0026gt; | +---------------------------------------------------+ Authority | \u0026lt;empty\u0026gt; | +---------------------------------------------------+ Additional | \u0026lt;empty\u0026gt; | +---------------------------------------------------+ 报文示例-响应  +---------------------------------------------------+ Header | OPCODE=SQUERY, RESPONSE, AA | +---------------------------------------------------+ Question | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A | +---------------------------------------------------+ Answer | SRI-NIC.ARPA. 86400 IN A 26.0.0.73 | | 86400 IN A 10.0.0.51 | +---------------------------------------------------+ Authority | \u0026lt;empty\u0026gt; | +---------------------------------------------------+ Additional | \u0026lt;empty\u0026gt; | +---------------------------------------------------+ 疑问 相关  dig 命令：可用于DNS相关操作。 host 命令：dig的简化版本。 whois 命令: 查看域名注册情况。 nslookup 命令: 可互动式查询域名记录。 DNS 原理入门-阮一峰 wiki wiki中文  ","date":"2021-12-12T11:35:47-04:00","image":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/image_hu55e9525b31cc013ff4b823f79d803bd9_80202_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/","title":"网络协议 —— DNS"},{"content":"ICMP  ICMP - 互联网控制消息协议（Internet Control Message Protocol） ICMP是互联网协议族的核心协议之一。 IMCP用于发送控制消息，提供可能发生在通信环境中的各种问题反馈。 ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。  原理及技术细节  每个路由器在转发数据报的时候都会把IP包头中的TTL值减1。  报文结构 ICMP报头从IP报头的第160位(20字节)开始：（有可选部分另算）\n 8bit 8bit 8bit 8bit +------+------+------+------+ | Type | Code | Checksum | +------+------+------+------+ | ID | Sequence | +------+------+------+------+  Type: ICMP报文类型。 Code：进一步划分ICMP的类型；该字段用来查找产生错误的原因。  例如，ICMP的目标不可达类型可以把这个位设为1至15等来表示不同的意思。   Checksum：校验和。 ID：ID/标识，在Echo Reply类型的消息中需要返回这个字段。 Sequence：序号，在Echo Reply类型的消息中需要返回这个字段。  报文类型    Type Code Status 描述 查询 差错 备注     0：Echo响应 0  Echo响应 ✓  ping中使用   1  未分配   ✓ 保留   2  未分配   ✓ 保留   3：目的不可达 0  目标网络不可达  ✓     1  目标主机不可达  ✓     2  目标协议不可达  ✓     3  目标端口不可达  ✓     4  要求分段并(但)设置DF标记  ✓     5  源路由失败  ✓     6  未知的目标网络  ✓     7  未知的目标主机  ✓     8  源主机隔离（作废不用）  ✓     9  禁止访问的网络  ✓     10  禁止访问的主机  ✓     11  对特定的TOS 网络不可达  ✓     12  对特定的TOS 主机不可达  ✓     13  由于过滤 网络流量被禁止  ✓     14  主机越权  ✓     15  优先权终止生效  ✓    4：源端关闭 0 弃用 源端关闭（拥塞控制）  ✓    5：重定向 0  重定向网络  ✓     1  重定向主机  ✓     2  基于TOS的网络重定向  ✓     3  基于TOS的主机重定向  ✓    6  弃用 备用主机地址      7  未分配 保留      8 0  Echo请求 ✓     9 0  路由通告 ✓     10 0  路由器的发现/选择/请求 ✓     11：超时 0  TTL超时  ✓     1  分片重组超时  ✓    12：参数问题-IP头部错误 0  IP报文首部参数错误  ✓     1  丢失必要选项  ✓     2  不支持的长度      13 0  时间戳请求 ✓     14 0  时间戳应答 ✓     15 0  信息请求 ✓     16 0  信息应答 ✓     17 0  地址掩码请求 ✓     18 0  地址掩码应答 ✓     19  保留 因安全原因保留      20~29  保留 保留用于稳健性实验      30~39  弃用       40   Photuris, Security failures   ？？？   41   用于实验性移动协议，如Seamoby[RFC4065]      42~255  保留       235  实验性 RFC3692      254  实验性 RFC3692                部分报文结构示例 3：目标不可达 目的地不可达由主机或其入站网关生成，以通知客户端由于某种原因目的地不可达。\n0 8 16 24 32 +---------+----------+----------+----------+ | Type=3 | Code=... | Checksum | +---------+----------+----------+----------+ | 未使用 | 下一跳MTU | +------------------------------------------+ | IP报头和原始数据报数据的前8个字节 | +------------------------------------------+ 11: 超时 超时由网关生成，以便通知源，数据报在TTL=0时被丢弃了。\n0 8 16 32 +---------+----------+----------+ | Type=11 | Code=0/1 | Checksum | +---------+----------+----------+ | 未使用 | +-------------------------------+ | IP报头和原始数据报数据的前8个字节 | +-------------------------------+ 相关  RFC 792  ","date":"2021-12-12T11:24:32-04:00","image":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/image_hue1f82669ca730723685f7d5c1bcf2446_46573_120x120_fill_q75_box_smart1.jpg","permalink":"https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/","title":"网络协议 —— ICMP"}]