<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 树深时间录</title><link>https://isshe.site/post/</link><description>Recent content in Posts on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 May 2024 01:15:10 +0800</lastBuildDate><atom:link href="https://isshe.site/post/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenResty access_by_lua*</title><link>https://isshe.site/p/openresty-access_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-access_by_lua/</guid><description>access_by_lua* access_by_lua* 充当一个 access 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文：http, server, location, location if 阶段：access tail 注意：执行阶段晚于标准 ngx_http_access_module 模块。 语法： 与 init_by_lua* 类似，不再赘述。 实现 实现逻辑与 rewrite_by_lua* 别无二致，不再赘述。</description></item><item><title>OpenResty content_by_lua*</title><link>https://isshe.site/p/openresty-content_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-content_by_lua/</guid><description>content_by_lua* content_by_lua* 充当一个 content 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文：location, location if 注意，不能定义在 http、server 块内了。 阶段：content 语法： 与 init_by_lua* 类似，不再赘述。 注意：这个指令不要和其他 content handler 指令（如 proxy_pass）在同一个 location 同时使用。 实现 在《模块初始化》的“ngx_http_lua_init 执行流程”中， 我们了解到 content handler 并没有像 rewrite handler 一样在函数 ngx_http_lua_init 中被放到 cmcf-&amp;gt;phases 数组中，所以接下来我们来探究一下为什么。 因此，我们此行的目的：
了解指令是如何被解析的。（猜测与前面的阶段没有什么差异） 了解 content handler 是被如何设置的，为何于其他阶段的 handler 不同。 了解是何时执行了 Lua 代码，如何执行的。（猜测与前面的阶段没有什么差异） 指令定义 /* content_by_lua &amp;#34;&amp;lt;inline script&amp;gt;&amp;#34; */ { ngx_string(&amp;#34;content_by_lua&amp;#34;), NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1, ngx_http_lua_content_by_lua, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_content_handler_inline }, ngx_http_lua_content_by_lua 执行过程 - ngx_http_lua_content_by_lua \- if (cmd-&amp;gt;post == NULL)：检查是否有指定处理程序，没有直接报错返回。 \- if (llcf-&amp;gt;content_handler)：检查是否已经设置了处理程序，设置了报错返回。 \- if (value[1].</description></item><item><title>OpenResty cosocket</title><link>https://isshe.site/p/openresty-cosocket/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-cosocket/</guid><description>OpenResty cosocket 使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？
目的：
学习如何使用 cosocket。 cosocket 是什么？ cosocket 的实现方式、原理是什么？ 使用 ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。
以下接口的上下文皆是：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*。
ngx.socket.tcp 语法：tcpsock = ngx.socket.tcp()
作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。
注意：
此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以永远不要将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也永远不要在不同的 Nginx 请求之间共享 cosocket 对象。 如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭： 当前请求处理程序（handler）执行完成 Lua cosocket 对象被 Lua GC 回收 发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。 tcpsock:bind 此接口需要更新的版本，v0.</description></item><item><title>OpenResty HTTP 模块的 *_by_lua* 及阶段</title><link>https://isshe.site/p/openresty-http-%E6%A8%A1%E5%9D%97%E7%9A%84-_by_lua-%E5%8F%8A%E9%98%B6%E6%AE%B5/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-http-%E6%A8%A1%E5%9D%97%E7%9A%84-_by_lua-%E5%8F%8A%E9%98%B6%E6%AE%B5/</guid><description>OpenResty 中 HTTP 模块的 *_by_lua* 及阶段 目的：
了解都有哪些阶段：*_by_lua*。 了解各个阶段的执行时机，各阶段有什么限制：如是否可以 yield，原因是什么。 所有的 *_by_lua*：
执行阶段：指的是对应的 Nginx 的阶段
init_by_lua*：可用于加载配置、初始化全局变量等
上下文：无 执行阶段：初始化阶段是在 master 进程中 设置执行阶段的位置：无 是否可以 yield：否，初始化阶段，无需 yield。 init_worker_by_lua*：可用于加载 Lua 模块等
上下文：NGX_HTTP_LUA_CONTEXT_INIT_WORKER 执行阶段：初始化 worker 进程阶段 设置执行阶段的位置：无 是否可以 yield：否，初始化阶段，无需 yield。 ssl_client_hello_by_lua*：可以用于设置 TLS 算法，HTTP 协议版本 (1.1/2/3)。
上下文：NGX_HTTP_LUA_CONTEXT_SSL_CLIENT_HELLO 执行阶段：客户端发来 Client Hello 时后，处理 Client Hello 消息前 设置执行阶段的位置：SSL_CTX_set_client_hello_cb 是否可以 yield：是 ssl_session_fetch_by_lua*：根据客户端提供的 Session ID 查找并恢复会话。</description></item><item><title>OpenResty init_by_lua*</title><link>https://isshe.site/p/openresty-init_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-init_by_lua/</guid><description>init_by_lua* 相关代码逻辑出自 lua-nginx-module v0.10.21 版本
当 Nginx 收到 HUP 信号并开始重新加载配置文件时，Lua VM 会被重新创建，并且 init_by_lua* 会在新的 Lua VM 上再次运行。 如果关闭 lua_code_cache 指令（默认打开），init_by_lua* 处理程序（Lua 代码）将在每个请求上运行，因为在这种特殊模式下，需要为每个请求创建一个独立的 Lua VM。
用法 init_by_lua 已不建议使用，使用 init_by_lua_block 和 init_by_lua_file 代替。
使用场景：
在 init_by_lua* 中，加载 Lua 模块，如 require &amp;quot;cjson&amp;quot;，再在其他阶段（如 content_by_lua*）使用：再次 require，这次 require 会很快，直接从 package.loaded 中获取返回。 执行阶段：loading-config，配置加载阶段
上下文：http
语法：
init_by_lua &amp;#39;lua-script-str&amp;#39; init_by_lua_block { lua-script } init_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt; 示例： init_by_lua 'print(&amp;quot;Hello World&amp;quot;)' init_by_lua_block { print(&amp;quot;Hello World&amp;quot;) } init_by_lua_file /usr/local/openresty/lua/init.</description></item><item><title>OpenResty init_worker_by_lua*</title><link>https://isshe.site/p/openresty-init_worker_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-init_worker_by_lua/</guid><description>init_worker_by_lua* 如果没有启用 master 进程则此指令的 Lua 代码将在 init_by_lua* 指令的 Lua 代码之后运行。
启用 master 进程：表示非 master-worker 的模式 用法 使用场景
通常用于启动定时器执行每 worker 相关的内容，或者后端健康检查等。 执行阶段：starting-worker，工作进程启动阶段
上下文：http
语法：
与 init_by_lua* 类似，不再赘述。
实现 以 init_worker_by_lua_file 为例
通过前面的探索，我们已经知道指令的解析会在配置解析阶段，而对应的 Lua 代码会在后续才执行。 因此，我们接下来目的很明确：
解析 init_worker_by_lua_file 指令时，做了什么？ 在什么时候实际执行了 Lua 代码？如何执行的？ 我们以 init_worker_by_lua_file 指令为例。
指令定义 { ngx_string(&amp;#34;init_worker_by_lua_file&amp;#34;), NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1, ngx_http_lua_init_worker_by_lua, NGX_HTTP_MAIN_CONF_OFFSET, 0, (void *) ngx_http_lua_init_worker_by_file }, ngx_http_lua_init_worker_by_lua：指令解析时调用的函数。 ngx_http_lua_init_worker_by_file：指令结构的 post 字段的值。 解析指令时，会调用 ngx_http_lua_init_worker_by_lua，我们来跟踪一下。</description></item><item><title>OpenResty log_by_lua*</title><link>https://isshe.site/p/openresty-log_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-log_by_lua/</guid><description>log_by_lua* 在日志处理阶段执行 Lua 源代码，不会替换当前的访问日志，并在打印日志之前运行。
用法 上下文：http, server, location, location if 阶段：log 语法： 与 init_by_lua* 类似，不再赘述。 注意： 以下 API 无法在此指令中使用： Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.exit) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket). 实现 与 005-rewrite_by_lua 类似，不再赘述。
header_filter_by_lua*、 body_filter_by_lua* 等都是一样的套路，就不再赘述了。</description></item><item><title>OpenResty Lua VM 初始化</title><link>https://isshe.site/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>Lua VM 初始化 上一篇关于 ngx.log 文章中，跟踪相关代码时思路几近断裂，因此赶紧来补补 Lua VM 初始化相关内容。
目的：
Lua VM 初始化的时机？（什么时候初始化） 了解 Lua VM 初始化做了哪些工作？为什么这么做（选）？ Lua 虚拟机是共用一个？还是每次调用 Lua 代码起一个？ 注入的接口和 _G 是什么关系？这些接口也在 _G 中吗？ Lua VM 初始化时机 从上一篇文章中，我们已经拿过一个 Lua VM 初始化相关的堆栈，这里截取一部分：
#4 0x000055555570b955 in ngx_http_lua_init_vm (new_vm=0x555555891080, parent_vm=0x0, cycle=0x555555885740, pool=0x5555558856f0, lmcf=0x555555891080, log=0x55555583d280 &amp;lt;ngx_log&amp;gt;, pcln=0x0) at ../ngx_lua-0.10.21/src/ngx_http_lua_util.c:3896 #5 0x00005555556fb450 in ngx_http_lua_init (cf=0x7fffffffd7e0) at ../ngx_lua-0.10.21/src/ngx_http_lua_module.c:865 #6 0x00005555555f4ddc in ngx_http_block (cf=0x7fffffffd7e0, cmd=0x55555581a200 &amp;lt;ngx_http_commands&amp;gt;, conf=0x555555886a20) at src/http/ngx_http.c:310 #7 0x00005555555b9ec7 in ngx_conf_handler (cf=0x7fffffffd7e0, last=1) at src/core/ngx_conf_file.</description></item><item><title>OpenResty Lua 代码加载</title><link>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD/</guid><description>OpenResty 加载及缓存 Lua 代码 目的：
了解 OpenResty 是如何加载及缓存 Lua 代码的。 加载 Lua 代码之前的代码逻辑见 005-rewrite_by_lua.md，本文接着从 ngx_http_lua_cache_loadbuffer 开始深入。
ngx_http_lua_cache_loadbuffer - ngx_http_lua_cache_loadbuffer: 加载 Lua 代码 \- ngx_http_lua_cache_load_code: 从缓存中加载，有直接返回，没有则继续。 \- lua_pushlightuserdata(L, ngx_http_lua_lightudata_mask(code_cache_key)) \- lua_rawget(L, LUA_REGISTRYINDEX): 把 Lua 代码缓存表加载到栈顶 \- if (*ref == LUA_NOREF): 通过 ref 和 key 结合来获取缓存。如果有 ref，就用 ref，如果没有，就用 key。如果用 key 也没找到，就是没缓存，后续需要加载。 \- lua_isfunction: 这是闭包工厂函数，通过此函数来生成闭包 \- rc = lua_pcall(L, 0, 1, 0): 正式调用闭包工厂，生成闭包，返回值是 0 表示成功，否则就是失败了。 \- ngx_http_lua_clfactory_loadbuffer: 加载闭包工厂 \- lua_load(L, ngx_http_lua_clfactory_getS, &amp;amp;ls, name): 加载 Lua Chunk 成一个函数。这个函数其实是一个闭包 &amp;#34;return function() .</description></item><item><title>OpenResty Lua 代码执行实例跟踪</title><link>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8B%E8%B7%9F%E8%B8%AA/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8B%E8%B7%9F%E8%B8%AA/</guid><description>Lua 代码执行实例跟踪 实际跟踪 Lua 代码的执行情况（主要是出错情况）。
异常情况 由于使用 bpftrace 得到的堆栈不符合预期，直接用 gdb 来获取：
指令：
# index a nil value init_by_lua 'return a.b'; 对 nil 值进行索引。
错误输出：
nginx: [error] init_by_lua error: init_by_lua:1: attempt to index global 'a' (a nil value) stack traceback: init_by_lua:1: in main chunk 命令：
$ gdb sbin/nginx &amp;gt; set args -p /NGINX/CONFIG/PATH &amp;gt; b ngx_http_lua_traceback &amp;gt; run &amp;gt; bt 从 init_by_lua 的文章中，已经知道了 ngx_http_lua_traceback 是错误处理函数，因此我们直接追踪它。
结果：
#0 ngx_http_lua_traceback (L=0x7ffff76f02e8) at ngx_lua-0.</description></item><item><title>OpenResty ngx.log</title><link>https://isshe.site/p/openresty-ngx.log/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-ngx.log/</guid><description>ngx.log 我们都知道，这个接口的功能是打印错误日志，那么它是如何工作的呢？我们来探究一下。
注意，是接口 ngx.log 不是指令 log_by_lua 。*
目的：
它是如何工作的呢？ ngx.log 是如何被定义的？ ngx.log 执行时，做了什么？ 使用 上下文：context: init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer., balancer_by_lua, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*, exit_worker_by_lua*, ssl_client_hello_by_lua*
语法：ngx.log(log_level, ...)
注意：
Lua nil 会被输出为字符串 &amp;ldquo;nil&amp;rdquo;；Lua 的布尔类型会输出为 &amp;ldquo;true&amp;rdquo; or &amp;ldquo;false&amp;rdquo;；ngx.null 被输出为 &amp;ldquo;null&amp;rdquo; 字符串；Lua table 将会调用其元表的 __tostring 函数，调用失败则抛出异常，异常也被输出到错误日志中；如果是 userdata，则输出字符串 &amp;ldquo;null&amp;rdquo;；其他类型一律抛出异常。 Nginx 内核中的错误消息长度有一个硬编码的 2048 字节限制。此限制包括尾部换行符和前置时间戳。如果消息大小超过此限制，Nginx 将相应地截断消息。可以通过编辑 Nginx 源代码树中 src/core/ngx_log.</description></item><item><title>OpenResty ngx.sleep</title><link>https://isshe.site/p/openresty-ngx.sleep/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-ngx.sleep/</guid><description>ngx.sleep 在 OpenResty 中，我们可以通过 ngx.sleep() 让出执行权进行“睡眠/挂起”，让当前请求暂停一段时间（单位为秒）后醒来。
目的：
了解 ngx.sleep 的使用。 了解 ngx.sleep 的实现。 ngx.sleep() 及其他 cosocket 相关的函数不能用在 init_by_lua/init_worker_by_lua/set_by_lua/header_filter_by_lua/body_filter_by_lua/log_by_lua 的原因是什么？ 使用 ngx.sleep 的使用非常简单：
ngx.sleep(0.001) 睡眠时间的精度是毫秒（0.001 秒）。
上下文：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer., ssl_certificate_by_lua, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*
实现 ngx.sleep 也是通过 C 代码注入的方式，对应的处理函数是：ngx_http_lua_ngx_sleep，我们直接来跟踪这个函数的实现。
- ngx_http_lua_ngx_sleep \- delay = (ngx_int_t) (luaL_checknumber(L, 1) * 1000)：将参数转换成毫秒 \- coctx-&amp;gt;sleep.handler = ngx_http_lua_sleep_handler：填充 coctx-&amp;gt;sleep 事件 \- ngx_add_timer(&amp;amp;coctx-&amp;gt;sleep, (ngx_msec_t) delay)：添加定时器 \- return lua_yield(L, 0)：让出执行权 可以看到，时间到了以后，会调用 ngx_http_lua_sleep_handler：
- ngx_http_lua_sleep_handler \- ctx-&amp;gt;cur_co_ctx = coctx：设置当前协程 \- if (ctx-&amp;gt;entered_content_phase)：如果不是 access、rewrite 阶段 \- ngx_http_lua_sleep_resume：直接 resume \- vm = ngx_http_lua_get_lua_vm(r, ctx)：获取 Lua 虚拟机 \- rc = ngx_http_lua_run_thread(vm, r, ctx, 0)：继续跑协程 \- else：否则如果是 access、rewrite 阶段，就设置回调，直接进入核心处理流程 \- ctx-&amp;gt;resume_handler = ngx_http_lua_sleep_resume：设置 resume 回调 \- ngx_http_core_run_phases(r)：然后继续回到核心处理逻辑 \- ngx_http_run_posted_requests：执行后续的请求 在这个函数中，会恢复被暂停的 Lua 协程。</description></item><item><title>OpenResty rewrite_by_lua*</title><link>https://isshe.site/p/openresty-rewrite_by_lua/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-rewrite_by_lua/</guid><description>rewrite_by_lua* rewrite_by_lua* 充当一个 rewrite 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文：http, server, location, location if 阶段：rewrite tail 注意：执行阶段晚于标准 ngx_http_rewrite_module 模块。 语法： 与 init_by_lua* 类似，不再赘述。 注意： 如果 rewrite_by_lua* 指定的 Lua 代码中通过 ngx.exit(code) 退出，如果 code = ngx.OK（非 ngx.HTTP_OK），则会继续执行！ 实现 以 rewrite_by_lua_block 为例
开始前，还是如以往一样，先明确此行的目的：
解析指令时，做了什么？猜测和前面两个没有太大差别。 在什么时候实际执行了 Lua 代码？如何执行的？每个请求都会执行这个，想必处理方法应该不同以往。 还提到“全局环境（沙箱）”，是什么呢？ 指令定义 { ngx_string(&amp;#34;rewrite_by_lua_block&amp;#34;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF |NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_http_lua_rewrite_by_lua_block, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_rewrite_handler_inline }, NGX_HTTP_LIF_CONF：location if 配置 ngx_http_lua_rewrite_by_lua_block：配置解析时执行的函数。 ngx_http_lua_rewrite_handler_inline：实际执行 Lua 代码的函数。 还是围绕 3 点展开：</description></item><item><title>OpenResty 代码结构</title><link>https://isshe.site/p/openresty-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</guid><description>Lua Nginx Module 的源码结构 常常提醒自己使用总分思想，这不，发现缺少了一些更为全局的内容，现补充如下。 以 0.10.21 版本为例
目的
大致了解 openresty 是个什么、实现了哪些功能。 ngx_lua-0.10.21 ├── README.markdown ├── src │ ├── api │ │ └── ngx_http_lua_api.h │ ├── ddebug.h：用于调试的头文件 - 各个阶段是处理程序，用于支持 `*_by_lua*` 系列指令 │ ├── ngx_http_lua_initby.c │ ├── ngx_http_lua_initby.h │ ├── ngx_http_lua_initworkerby.c │ ├── ngx_http_lua_initworkerby.h │ ├── ngx_http_lua_ssl_certby.c │ ├── ngx_http_lua_ssl_certby.h │ ├── ngx_http_lua_ssl_client_helloby.c │ ├── ngx_http_lua_ssl_client_helloby.h │ ├── ngx_http_lua_setby.c │ ├── ngx_http_lua_setby.h │ ├── ngx_http_lua_ssl_session_fetchby.c │ ├── ngx_http_lua_ssl_session_fetchby.</description></item><item><title>OpenResty 信号量</title><link>https://isshe.site/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>轻线程信号量 和 Linux 系统或者 Nginx 中的信号量类似，都是用于进程/协程同步。当值小于 0 时，表示需要等待资源。 不过 Nginx 中的信号量是会导致进程在等待资源时休眠的，OpenResty 的信号量（后续简称信号量）是不是也是一样呢？我们来探究一番。
目的：
如何使用信号量？ 信号量是如何实现的？ 信号量是否会导致如进程休眠之类的问题？ 不同进程的协程是否能使用信号量？ 使用 Lua 接口的使用都比较简单，我们直接通过一个示例来说明。
-- 引入 ngx.semaphore 模块 local semaphore = require &amp;#34;ngx.semaphore&amp;#34; -- 新建一个 semaphore 对象 -- 此时默认资源是 0 个 -- 也可以传递参数指定信号量初始有多少资源 local sema = semaphore.new() -- 获取资源数量 ngx.say(&amp;#34;main thread: count: &amp;#34;, sema:count()) -- count: 0 -- 新协程的处理函数 local function handler() ngx.say(&amp;#34;sub thread: waiting on sema...&amp;#34;) -- 等待 1 个资源；超时时间是 1 秒，如果资源数量 &amp;gt;= 0，立即返回，如果拿不到（数量 &amp;lt; 0），会 yield。 -- 相当于锁操作中的 加锁（lock）操作。 -- 参数中的 1 表示 1 秒；最小可以为 0.</description></item><item><title>OpenResty 共享字典（内存）</title><link>https://isshe.site/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/</guid><description>OpenResty shared dict 目的：
相关 Lua API 如 ngx.shared.DICT.get 是如何使用的？ 如何定义 lua_shared_dict 的，lua_shared_dict 做了哪些工作？ 详细跟踪各类 Lua 接口（set、get 每类一个）的实现，了解 shared dict 的设计/实现细节。 这些 Lua 接口是否是原子的？是否需要考虑竞争问题？原子性是如何保证的？ ngx_http_lua_shdict_shctx_t 等关键数据结构是什么作用？它们之间有什么联系？ 使用 使用示例：
http { lua_shared_dict dogs 10m; server { location / { content_by_lua_block { -- 设置 local dogs = ngx.shared.dogs dogs:set(&amp;#34;Jim&amp;#34;, 8) -- 获取 local jim_age = dogs:get(&amp;#34;Jim&amp;#34;) ngx.say(jim_age) -- 替换 dogs:replace(&amp;#34;Jim&amp;#34;, 9) -- 递增, value = 10 dogs:incr(&amp;#34;Jim&amp;#34;) -- 更新/设置超时 dogs:expire(&amp;#34;Jim&amp;#34;, 10) -- 获取 TTL dogs:ttl(&amp;#34;Jim&amp;#34;) -- 删除 dogs:delete(&amp;#34;Jim&amp;#34;) } } } } 以下是所有 Lua Api 的作用：</description></item><item><title>OpenResty 协程</title><link>https://isshe.site/p/openresty-%E5%8D%8F%E7%A8%8B/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E5%8D%8F%E7%A8%8B/</guid><description>协程 lua-nginx-module 提供了 coroutine 系列 Lua 接口，用于操作协程。
这个与 ngx_http_lua_new_thread 相关的 lua-nginx-module 内部使用的协程不同，切勿搞混了。
这系列函数较为少用，需要并行操作时通常使用轻量级线程（light thread）。
目的：
coroutine Lua 接口的使用？主要使用场景？ 如前面提到，这个较为少用。lua-nginx-module 支持，主要应该是为了兼容第三方 Lua 模块。 coroutine 是如何实现的？ 与 Luajit 的协程是什么关系？ 使用 coroutine.create(f)：创建一个协程并返回此协程，类型为“thread”，f 必须是一个函数。 coroutine.resume (co [, val1, ···])：开始或继续执行协程 co。如果协程执行出错，则返回 false 和错误信息，如果协程执行正常，返回 true。 首次调用会开始调用 f 函数，val1 等作为参数传递给 f。 后续调用会用 yield 的地方继续，val1 等作为 yield 的结果传递给 f。 coroutine.yield (···)：暂停正在执行的协程的执行。传递给 yield 的参数，将作为 resume 额外的结果返回。 coroutine.running ()：返回正在运行的协程，主协程正在运行，则返回 nil。 coroutine.status (co)：返回协程 co 的状态。 running：协程正在执行 suspended：调用了 yield，或者还没开始运行。 normal：激活但没有在运行，意味着它正在 resume 其他协程。 dead：执行完 f 函数，或者出错了。 coroutine.</description></item><item><title>OpenResty 核心技术点</title><link>https://isshe.site/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/</guid><description>OpenResty 核心技术点 本文档用于汇总学习过程中遇到的核心技术点。 记录逻辑：假设相关功能没有实现，简要描述重新实现的要点。
TODO: 补充以下相关的
lua 堆栈解读（或许应该放到 Luajit 那边去） Lua 接口/数据 (变量) 注入 有些函数不需要 require 都能进行使用，这是因为 OpenResty 自动进行了相关工作。
在初始化 Lua 虚拟机时，进行 Lua 接口注入。 采用表（table）的形式进行组织 —— lua_createtable。 创建一个表，然后设置键值对，把 key（如 &amp;ldquo;get&amp;rdquo;）和 C 函数（lua_pushcfunction）或值 (lua_pushinteger 等) 进行绑定。 各个协程可以设置各自独立的全局表。 cosocket 基于 Lua 协程和 Nginx 的事件模型以及异步 I/O：Lua 接口调用 cosocket 相关函数时，底层的 listen、send 等接口采用非阻塞的方式，使这些调用立即返回。根据返回的状态，设置并监听相关读写事件，然后 yield 让出当前 Lua 协程的执行权，继续执行其他协程。当等待的事件发生后，事件处理函数 resume 唤醒对应的协程，继续执行。 详见 OpenResty cosocket。
Pipe 设计要点 开 2 或 3 个 pipe，分别用于 stdin/stdout/stderr —— 把标准输入、输出、错误重定向到这些 pipe 的 fd。 使用 exec 系列函数来执行命令 读或写数据 (命令输入或命令输出) 时，先进行一次读写，如果无法一次完成，则设置对应的读写事件，然后 yield 让出执行权；后续通过事件模块 resume 获取执行权。 详见 OpenResty Pipe。</description></item><item><title>OpenResty 模块初始化</title><link>https://isshe.site/p/openresty-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>lua-nginx-module 模块的定义及初始化 lua_nginx_module 其实就是一个 Nginx 模块，定义及实现都需要按照 Nginx 模块的要求。
这篇文章的目的是什么呢？
了解 lua-nginx-module 模块相关数据结构的定义。 了解 lua-nginx-module 模块大致的初始化流程，对 lua-nginx-module 模块有一个总体的概念，然后我们在后续的文章中，去细化追究相关指令的细节。 总分结构 定义 定义个全局的模块变量： ngx_http_lua_module.c 此结构的详细解释可见 Nginx 数据结构 ngx_module_t
ngx_module_t ngx_http_lua_module = { NGX_MODULE_V1, &amp;amp;ngx_http_lua_module_ctx, /* module context */ ngx_http_lua_cmds, /* module directives */ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ ngx_http_lua_init_worker, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ ngx_http_lua_exit_worker, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; 定义一个模块上下文 static ngx_http_module_t ngx_http_lua_module_ctx = { NULL, /* preconfiguration */ ngx_http_lua_init, /* postconfiguration */ ngx_http_lua_create_main_conf, /* create main configuration */ ngx_http_lua_init_main_conf, /* init main configuration */ ngx_http_lua_create_srv_conf, /* create server configuration */ ngx_http_lua_merge_srv_conf, /* merge server configuration */ ngx_http_lua_create_loc_conf, /* create location configuration */ ngx_http_lua_merge_loc_conf /* merge location configuration */ }; 可以看到被定义成了一个 HTTP 模块（NGX_HTTP_MODULE, ngx_http_module_t）。</description></item><item><title>OpenResty 管道（pipe）</title><link>https://isshe.site/p/openresty-%E7%AE%A1%E9%81%93pipe/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E7%AE%A1%E9%81%93pipe/</guid><description>管道 目的：
有哪些使用场景？ 如何使用？在 OR 里面是如何使用的？ 由操作系统 shell 执行的字符串形式的命令行，会阻塞吗？ 如何实现的？ 在 proc_write 中 yield 出去后，是如何 resume 的？ 使用 spawn —— 创建对象 语法：proc, err = pipe_module.spawn(args, opts?)
作用：创建并返回一个新的子流程实例。
参数：
args：数组形式的命令或者是字符串形式的命令。 数组形式示例：{&amp;ldquo;ls&amp;rdquo;, &amp;ldquo;-l&amp;rdquo;} 字符串形式示例：&amp;ldquo;ls -l&amp;rdquo;。当使用此模式时，命令将由操作系统 shell 执行，就像 os.execute 一样。 opts： merge_stderr：如果是 true，将合并 stderr 和 stdout 的输出，相当于 2&amp;gt;&amp;amp;1。 buffer_size：读取操作的缓冲区大小，默认是 4096 字节。 environ：环境变量。如果当前系统不支持环境变量，则返回 nil 和 &amp;ldquo;environ option not supported&amp;rdquo;。示例：{&amp;quot;PATH=/tmp/bin&amp;quot;, &amp;quot;CWD=/tmp/work&amp;quot;} write_timeout：写超时时间，单位是毫秒。默认是 10000，设置为 0 则永不超时。 stdout_read_timeout：标准输出读超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 stderr_read_timeout：标准错误读超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 wait_timeout：等待超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 返回值：</description></item><item><title>OpenResty 线程</title><link>https://isshe.site/p/openresty-%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E7%BA%BF%E7%A8%8B/</guid><description>OpenResty 协程/线程 后续都称为协程。
通过前面的探索可以看出，ngx_http_lua_run_thread 是相当重要的一个函数，对于协程的调度，都是通过此接口进行。
目的：
了解 OpenResty 协程是什么？ 是否和此函数强关联：ngx_http_lua_run_thread？ OpenResty 的协程与 Luajit 的协程是什么关系？ OpenResty 协程是如何创建的？是何时创建的？（排除前面探究过的轻线程和 coroutine 接口） OpenResty 协程会在何时执行？（排除前面探究过的轻线程和 coroutine 接口） 主协程和其他协程是如何区分的？ Lua VM 和主协程是什么关系？ 这里描述的协程与前面章节中描述的 coroutine 什么关系？ 使用 不涉及
实现 协程的状态 typedef enum { NGX_HTTP_LUA_CO_RUNNING = 0, /* coroutine running */ NGX_HTTP_LUA_CO_SUSPENDED = 1, /* coroutine suspended */ NGX_HTTP_LUA_CO_NORMAL = 2, /* coroutine normal */ NGX_HTTP_LUA_CO_DEAD = 3, /* coroutine dead */ NGX_HTTP_LUA_CO_ZOMBIE = 4, /* coroutine zombie */ } ngx_http_lua_co_status_t; NGX_HTTP_LUA_CO_RUNNING：当前协程正在执行 NGX_HTTP_LUA_CO_SUSPENDED：当前协程已挂起，等待恢复 NGX_HTTP_LUA_CO_NORMAL：正常 NGX_HTTP_LUA_CO_DEAD：协程死亡/终止了 NGX_HTTP_LUA_CO_ZOMBIE：是僵尸协程，等待父协程回收 新建协程：ngx_http_lua_new_thread - ngx_http_lua_new_thread \- ngx_http_get_module_main_conf：获取模块配置 \- if (L == lmcf-&amp;gt;lua &amp;amp;&amp;amp; !</description></item><item><title>OpenResty 轻量级线程</title><link>https://isshe.site/p/openresty-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 19 May 2024 01:15:10 +0800</pubDate><guid>https://isshe.site/p/openresty-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B/</guid><description>轻量级线程 与前一个文档中介绍的协程不同，轻量级线程不需要自行 resume、yield 来调度协程，因此使用起来更方便，有并行操作时，通常会使用此方式。
看是否和此函数强关联：ngx_http_lua_run_thread； 如果此文章无法完成对 ngx_http_lua_run_thread 的理解，则另外文章。
目的：
轻线程如何使用？ 轻线程的使用场景？ 什么是轻线程？ OpenResty 的协程与 Luajit 的协程是什么关系？有什么区别？ 介绍 轻线程是一种由 lua-nginx-module 调度的特殊的 Lua 协程。rewrite/access/content_by_lua* 的 Lua 代码块就是在 lua-nginx-module 自动创建的**样板“轻线程”**中执行，这种样板“轻线程”也称为“入口线程（entry thread）”。
默认情况下，rewrite_by_lua 等 Nginx 处理程序只有在遇到以下情况时才会中止：
入口线程和所有用户轻线程都中止了。 任意一个轻线程调用了 ngx.exit、ngx.exec、ngx.redirect、ngx.req.set_uri(uri, true)。 入口线程触发了 Lua 错误。 不过，用户的轻线程触发了 Lua 错误而中止，并不会导致其他轻线程也中止。
由于 Nginx 子请求模型的限制，一般不允许中止一个正在运行的 Nginx 子请求，因此也不允许中止一个正等待一个或多个子请求终止的正在运行的轻线程，而必须使用 ngx.thread.wait 来等待这些轻线程终止。 一个值得注意的例外是，可以使用状态码 ngx.ERROR(-1), 408, 444 或 499 调用 ngx.exit 来中止挂起的子请求。
轻线程不是以抢的方式进行调度的，也就是不会自动执行时间分片。轻线程会一直运行，知道遇到以下情况：
一个 I/O 操作无法在一次执行中完成。 调用了 coroutine.</description></item><item><title>Linux 内核 —— 中断</title><link>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</guid><description>中断 1. 硬件中断注册 #include &amp;lt;linux/interrupt.h&amp;gt; static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) 作用：申请一个中断线。 参数： irq: 中断线号 handler: 中断处理函数 flags: name: dev: 2. 硬件中断释放 #include &amp;lt;linux/interrupt.h&amp;gt; const void *free_irq(unsigned int irq, void *dev_id); 作用：释放一个中断线。如果没有其他设备注册该 IRQ 线，就关闭该 IRQ。 参数： irq: 中断线号。 dev_id: 设备标识。 3. 中断类型 网络设备常见的中断事件类型：
接收一帧：最常见、标准的情况。 传输失败； DMA 传输已成功完成； drivers/net/3c59x.</description></item><item><title>Linux 内核 —— 设备驱动</title><link>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid><description>设备驱动 NIC 可用之前，相关联的 net_device 数据结构必须先初始化，添加至内核网络设备数据库、配置并开启。 注册/注销/开启/关闭是四个不同的操作，不要混淆。 相关讨论，主要以网络设备为主。
设备注册 触发网络设备注册的情况：
加载 NIC 设备驱动程序：内建在内核，则引导期间初始化；模块形式，则在运行期间初始化。 例如，注册 PCI 设备驱动程序时，会导致pci_driver-&amp;gt;probe被调用。 插入可热插拔网络设备：内核通知其驱动程序，驱动程序注册该设备。 注册流程：以 ethernet 设备为例，流程都是一样，只是细节不同。 示例可见：drivers/net/ethernet/intel/e100.c
xxx_probe/module_init | |---&amp;gt;dev = alloc_etherdev(sizeof(driver_private_structure)) | | | +---&amp;gt; alloc_etherdev(sizeof_priv, &amp;#34;eth%d&amp;#34;, ether_setup) | | | |---&amp;gt; dev = kmalloc(sizeof(net_device)) + sizeof_prive + padding) | |---&amp;gt; ether_setup(dev) | |---&amp;gt; strcpy(dev-&amp;gt;name, &amp;#34;eth%d&amp;#34;) | +---&amp;gt; return(dev) | ... ... ... |---&amp;gt; netdev_boot_setup_check(dev) | ... ... ... +---&amp;gt; register_netdev(dev) | +---&amp;gt; register_netdevice(dev) 注销 触发网络设备注销的情况：</description></item><item><title>Linux 命令 —— gdb</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</guid><description>gdb gdb - GNU 调试器。
调试器 (如 GDB) 的目的是允许你查看其他程序在执行时的&amp;quot;内部&amp;quot;的内容，或者程序奔溃的时候正在做什么。 GDB 可以做 4 种主要的事情来帮助你捕捉 bug：
启动你的程序，指定任何可能影响程序行为的内容。 使程序在指定条件下停止。 检查你程序停止时，正在发生的事情。 更改程序中的内容，以便你可以尝试纠正一个错误的影响并继续了解另一个错误。 你可以用 GDB 来调试 C、C++、Fortran、Modula-2 编写的程序。 使用gdb命令来调用 GDB。一旦启动，它会从中断读取命令，直到你用 GDB 命令&amp;quot;exit&amp;quot;告诉它退出。你可以用 GDB 命令help来查看帮助（不用退出 gdb）。 你可以运行没有参数或选项的 gdb ; 但是最常用的启动 GDB 的方法是使用一个或两个参数，将可执行程序指定为参数：
gdb program
您还可以从可执行程序和指定的 core 文件开始：
gdb program core
如果要调试正在运行的进程，则可以将进程 ID 指定为第二个参数：
gdb program 1234 gdb -p 1234
将 GDB 附加 (attach) 到 1234 进程（除非你由一个名字为 1234 的 core 文件，gdb 会先查找 core 文件）。 以下是一些常用的 GDB 命令：</description></item><item><title>Linux 命令 —— git</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</guid><description>git submodule 添加 submodule： git submodule add &amp;lt;subproject URL&amp;gt; &amp;gt; git submodule add https://github.com/isshe/gitsubproject 查看 subproject 的 commit： git diff --cached &amp;lt;subproject dir&amp;gt; &amp;gt; git diff --cached gitsubproject/ 查看 subproject 的.gitmodules： git diff --cached --submodule 自动 clone 每个 submodule： git clone --recursive &amp;lt;your repository url&amp;gt; &amp;gt; git clone --recursive https://github.com/isshe/gitproject 拉取子模块： git submodule init git submodule update &amp;gt; 更常用的是：递归更新 git submodule update --init --recursive 子模块的后续更新：
git submodule update --remote 调整 submodule 的 commit： git pull origin xxx 切 submodule 的分支： git config -f .</description></item><item><title>Linux 命令 —— ip</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</guid><description>ip 显示/操纵路由、设备、策略路由、隧道。
概要 ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics } OPTIONS := { -V[ersion] | -h[uman-readable] | -s[tatistics] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -n[etns] name | -a[ll] | -c[olor] } OBJECT:</description></item><item><title>Linux 命令 —— modprobe</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</guid><description>modprobe modprobe - 向 Linux 内核添加或从内核移除模块。
modprobe 智能地从 Linux 内核添加或删除模块：
注意，模块名称中-和_没有区别（自动执行下划线转换）。 modprobe 在模块目录/lib/modules/'uname -r'(符号冲突了，用'代替) 中查找所有模块和其他文件。 除了/etc/modprobe.d目录是的可选配置文件。详见modprobe.d modprobe 还将以&amp;lt;module&amp;gt;.&amp;lt;option&amp;gt;的形式使用内核命令行上指定的模块选项。 modprobe.blacklist=&amp;lt;module&amp;gt;的形式使用黑名单。 如果在 modulename 之后给出了任何参数，它们将被传递给内核。 除了配置文件中列出的选项。 用法 modprobe [-v] [-V] [-C config-file] [-n] [-i] [-q] [-b] [modulename] [module parameters...] modprobe [-r] [-v] [-n] [-i] [modulename...] modprobe [-c] modprobe [--dump-modversions] [filename] 选项 -a, --all 加载命令行中指定的所有模块。 -b, --use-blacklist 此选项使modprobe将配置文件（如果有）中的黑名单命令也应用于模块名称。 它通常由udev(7)使用。 -C, --config 此选项会覆盖缺省配置目录（/etc/modprobe.d） 此选项通过安装或删除命令传递给 MODPROBE_OPTIONS环境变量中 的其他modprobe命令。 -c, --showconfig 输出config目录中的有效配置并退出。 --dump-modversions 打印出模块所需的模块版本信息列表。 分发版通常使用此选项，以便使用模块版本控制deps(依赖？)打包Linux内核模块。 -d, --dirname 模块的根目录，默认是`/`。 --first-time 通常，如果告知插入已存在的模块或删除不存在的模块，modprobe将成功（并且不执行任何操作）。 这是简单脚本的理想选择; 然而，更复杂的脚本通常想知道modprobe是否真的做了一些事情： 这个选项使modprobe失败，因为它实际上没有做任何事情。 --force-vermagic 每个模块都包含一个包含重要信息的小字符串，例如内核和编译器版本。 如果模块无法加载并且内核抱怨`version magic`不匹配，则可以使用此选项将其删除(抱怨)。 当然，这个检查是为了保护你的，所以这个使用选项是危险的，除非你知道你在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 --force-modversion 当使用CONFIG_MODVERSIONS集编译模块时，会创建模块使用（或由模块提供）的每个接口的版本的详细说明。 如果模块无法加载并且内核抱怨模块不同意某个接口的版本，则可以使用“--force-modversion”来完全删除版本信息。 当然，这项检查是为了保护您的，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -f, --force 尝试从模块中删除任何可能阻止加载的版本信息：这与使用--force-vermagic和--force-modversion相同。 当然，这些检查是为了您的保护，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -i, --ignore-install, --ignore-remove 此选项使modprobe忽略命令行中，指定的模块的配置文件（如果有）中的安装和删除命令（任何相关模块仍然受配置文件中为它们设置的命令的限制）。 当使用此选项时，无论是否仅使用--ignore-install或--ignore-remove中的一个或其他（而不是两个）更具体地进行请求，将忽略安装和删除命令。 详见modprobe.</description></item><item><title>Linux 命令 —— netstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</guid><description>netstat 显示当前的连接情况。（UDP、TCP、UNIX、ICMP 等） 显示路由表、网络接口列表、网络统计信息、多播信息、伪装连接等。
1. 介绍 1.1 用法 netstat [-vWeenNcCF] [&amp;lt;Af&amp;gt;] -r netstat {-V|--version|-h|--help} netstat [-vWnNcaeol] [&amp;lt;Socket&amp;gt; ...] netstat { [-vWeenNac] -i | [-cWnNe] -M | -s } 1.2 选项 -r, --route 显示路由表 -i, --interfaces 显示接口列表 -g, --groups 显示多播组成员 -s, --statistics 显示网络统计信息 -M, --masquerade display masqueraded connections【？？？】 -v, --verbose 详细 -W, --wide 不要截断IP地址 -n, --numeric 不要解析IP成域名（直接使用IP，不经过域名服务器） --numeric-hosts 不要解析主机名 --numeric-ports 不要解析端口名 --numeric-users 不要解析用户名 -N, --symbolic 解析硬件名 【？？？】 -e, --extend 显示更多信息 -p, --programs 显示进程ID和进程名 -c, --continuous 持续列出网络状态 -l, --listening 显示LISTENING状态的连接 -a, --all, --listening 显示所有连接(默认: 显示CONNECTED的连接) -o, --timers 显示计时器 【netstat -to】 -F, --fib 显示转发信息库（Forwarding Information Base），默认显示 -C, --cache 显示路由缓存(routing cache)而不是FIB -t, --tcp 显示TCP信息 -u, --udp 显示UDP信息 -w, --raw 实现raw信息 -x, --unix 显示unix信息 --ax25 显示AMPR AX.</description></item><item><title>Linux 命令 —— ssh</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</guid><description>ssh 隧道 场景：家里内网机器 A 想要访问公司的内网机器 B。 条件：需要一个公网机器 C（假设 IP 是 1.1.1.1）。
打开公网机器的转发
在 B 上执行：
ssh -p 22 -NR 0.0.0.0:10443:0.0.0.0:443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：C 的信息 # 后面部分 0.0.0.0:443：B 的信息 注意：此时链接会一直保持，终端不会返回。
在 A 上执行： ssh -p 22 -NL 0.0.0.0:10443:0.0.0.0:10443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：A 的信息 # 后面部分 0.0.0.0:10443：C 的信息 注意：此时链接会一直保持，终端不会返回。
此时，在 A 上通过 localhost:10443 即可访问 B 的 443。
端口映射 此方法相比上面的更为简化，直接把内网端口映射到外网设备上，直接访问外网设备映射的端口即可。
修改公网设备的 ssh 配置 sudo vi /etc/ssh/sshd_config # 设置 GatewayPorts yes # 重启 ssh 服务 sudo systemctl restart sshd 进行端口映射 在内网机器上：</description></item><item><title>Linux 命令 —— strace</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</guid><description>strace strace - 跟踪系统调用和信号。
在最简单的情况下，strace 运行指定的命令直到它退出。 它拦截并记录由进程调用的系统调用和进程接收的信号。 每个系统调用的名称，其参数和返回值都打印在标准错误或使用-o选项指定的文件上。 strace 是一种有用的诊断，指导和调试工具。 跟踪中的每一行都包含系统调用名称，后跟括号中的参数及其返回值。如：
open(&amp;#34;/dev/null&amp;#34;, O_RDONLY) = 3 系统调用错误，如：(返回 -1，并打印出错原因)
open(&amp;#34;/foo/bar&amp;#34;, O_RDONLY) = -1 ENOENT (No such file or directory) 信号，如：
sigsuspend([] &amp;lt;unfinished ...&amp;gt; --- SIGINT (Interrupt) --- +++ killed by SIGINT +++ 正在执行系统调用的同时，另一个线程/进程调用另一个系统调用，则 strace 将尝试保留这些事件的顺序并将正在进行的调用标记为未完成。 当调用返回时，它将被标记为已恢复：
[pid 28772] select(4, [3], NULL, NULL, NULL &amp;lt;unfinished ...&amp;gt; [pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0 [pid 28772] &amp;lt;... select resumed&amp;gt; ) = 1 (in [3]) 系统调用被中断后重启，如：</description></item><item><title>Linux 命令 —— tcpdump</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</guid><description>tcpdump tcpdump - dump traffic on a network（转储网络上的流量）。
用法 tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ -Q in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,.</description></item><item><title>Linux 命令 —— vmstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</guid><description>vmstat 报告虚拟内存统计信息：进程，内存，分页，块 IO，陷阱 (traps)、磁盘和 cpu 活动。
用法 vmstat [options] [delay [count]] vmstat [-f] [-s] [-m] vmstat [-S unit] vmstat [-d] vmstat [-p disk partition] vmstat [-V] 选项 delay 更新之间的延迟，以秒为单位。如果未指定延迟，则仅打印一个报告：自引导以来的平均值。 count 更新次数。如果未指定计数且指定了延迟(delay)，则count默认为无穷大。 -a, --active 显示活动和非活动内存（2.5.41及之后的版本） -f, --forks 显示自引导以来的fork数。 这包括fork，vfork和clone系统调用，并且是相当于创建的任务总数。 每个进程由一个或多个任务表示，具体取决于线程用法。此显示不重复（也就是只显示一次）。 -m, --slabs 显示slabinfo。【相关字段含义见下面部分】 -n, --one-header 标题仅显示一次而不是定期显示。 -s, --stats 显示各种事件计数器和内存统计信息。此显示不重复（也就是只显示一次）。 -d, --disk 报告磁盘信息（2.5.70及之后版本） -D, --disk-sum 报告一些有关磁盘活动的摘要统计信息。 -p, --partition device 分区的详细统计信息。 (2.5.70及之后版本). -S, --unit character 更换输出的单位：1000(k)，1024(K)，1000000(m)，1048576(M) 字节。 注意，这不会改变交换(si/so)或块(bi/bo)字段。 -t, --timestamp 为每一行附加时间戳。 -w, --wide 宽屏输出模式（对于具有较高内存量的系统非常有用，其中默认输出模式会受到不必要的列断裂影响）。 输出宽度会超过每行80个字符。 -V, --version 显示版本信息并退出。 -h, --help 显示帮助信息并退出。 字段描述 VM 模式字段描述 进程 r: 可运行进程的数量 (正在运行 + 就绪状态)。 b: 处于不可中断睡眠的进程数量。 内存 swpd: 使用的虚拟内存量。 free: 空闲内存量。(idle) buff: 用作缓冲区 (buffer) 的内存量。 cache: 用作缓存 (cache) 的内存量。 inact: 非活动内存量。（-a 选项） active: 活动内存量。（-a 选项） 交换内存 si: 从磁盘交换的内存量（/s）。 so: 交换到磁盘的内存量（/s）。 IO bi: 从块设备接收的块数（blocks/s）。 bo: 发送到块设备的块数（blocks/ s）。 系统 in: 每秒的中断数，包括时钟。 cs: 每秒上下文切换次数。 CPU 这些是总 CPU 时间的占比。 us: 运行非内核代码所花费的时间。 (用户时间，包括 nice 时间) sy: 运行内核代码所花费的时间。 (系统时间) id: 空闲时间。在 2.</description></item><item><title>Lua —— 重载全局函数 require</title><link>https://isshe.site/p/lua-%E9%87%8D%E8%BD%BD%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0-require/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/lua-%E9%87%8D%E8%BD%BD%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0-require/</guid><description>全局函数重载 在我个人的开源项目 xway 的中有一个需求：允许用户写 Lua 来自定义一些模块，提供最大的灵活性，但是不把 Lua 模块保存成文件。要如何实现呢？怎么才能从内存中 require 一个模块？答案是重载 require 函数。 利用 Lua 的环境（Environment）特性，在某个独立的环境中重载 require 函数。同时独立的环境也允许我们进行一些限制，例如每个用户只能访问自己的资源。不过，xway 项目计划是不支持多租户，所以限制相关的实现，还未进行相关探索及验证。
下面直接通过一个例子来说明。
示例 local ctype_count = require &amp;#34;ctype.count&amp;#34; local ma = [[ local _M = {} function _M.hello() print(&amp;#34;a hello&amp;#34;) end return _M ]] local mb = [[ local ma = require(&amp;#34;ma&amp;#34;) local _M = {} function _M.hello() ma.hello() print(&amp;#34;b hello&amp;#34;) end return _M ]] local module_map = { [&amp;#34;ma&amp;#34;] = ma, [&amp;#34;mb&amp;#34;] = mb, } local function new_require(name) return loadstring(module_map[name])() end local new_env ={ require = new_require, } setmetatable(new_env, {__index = _G}) local m1 = loadstring(mb) setfenv(m1, new_env) print(ctype_count()) local ret, mod = pcall(m1) if not ret then print(ret) end print(ctype_count()) mod.</description></item><item><title>VLAN 介绍</title><link>https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/</guid><description>VLAN VLAN - 虚拟局域网（Virtual Local Area Network）。 在 IEEE 802.1Q 中，给定以太网上的最大 VLAN 数为 4094。（12 位 VID。减去头尾的 0 和 4095）
作用 VLAN 可以为网络提供以下作用： 广播控制 带宽利用 降低延迟 安全性（非设计作用，本身功能所附加出的） 采用虚拟局域网技术实现交换机以太网的广播隔离。 一个 VLAN 相当于 OSI 模型第 2 层的广播域，它能将广播控制在一个 VLAN 内部。 不同 VLAN 之间或 VLAN 与 LAN/WAN 的数据通信必须通过第 3 层（网络层）完成。 原理（划分方式） 物理层 (physical layer) 以交换机端口作为划分 VLAN 的基础。 适合规模不大的组织。 数据链路层 (data link layer) 以每台主机的MAC地址作为划分 VLAN 的基础。 实现方法： 创建一个 MAC 与 VLAN 映射的数据库。 当网络设备连接到端口后，交换机向VMPS(VLAN管理策略服务器)请求这个数据库。 找到相应的映射，完成 VLAN 的分配。 优点： 计算机物理位置的不同，也不影响 VLAN 的运作。 缺点： 人为建立 MAC 与 VLAN 的映射关系；因此导致管理复杂度增加。 网络层 以IP地址作为划分 VLAN 的基础；以子网视为 VLAN 设置的依据。【？？？】 优点： 网管人员已经将内部网段做好规划与分配后，将可大辐降低规划并设置 VLANs 架构的复杂度。 缺点： 交换机需要对帧进行处理（原本不需要），降低交换机接收和分派分组的效率。</description></item><item><title>图解密码技术 —— 第14章-SSL-TLS</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC14%E7%AB%A0-ssl-tls/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC14%E7%AB%A0-ssl-tls/</guid><description>SSL/TLS为了更安全的通信
什么是 SSL/TLS？ 是世界上应用最广泛的密码通信方法。 SSL: Secure Socket Layer. TLS: Transport Layer Security. 相当于 SSL 的后续版本。 由 (下层)TLS 记录协议 (TLS record protocol) 和 (上层)TLS 握手协议 (TLS handshake protocol) 这两层协议叠加而成。 TLS 记录协议 TLS 记录协议负责：消息的压缩、加密、数据的认证。
TLS 握手协议 TLS 握手协议：加密之外的其他各种操作。 握手协议 密码规格变更协议 警告协议 应用数据协议</description></item><item><title>图解密码技术 —— 第一章-环游密码世界</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%8E%AF%E6%B8%B8%E5%AF%86%E7%A0%81%E4%B8%96%E7%95%8C/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%8E%AF%E6%B8%B8%E5%AF%86%E7%A0%81%E4%B8%96%E7%95%8C/</guid><description>第一章 环游密码世界 名词 明文：加密前的消息。 密文：加密后的消息。 加密：把明文转换为密文的操作。 解密：把密文还原为明文的操作。 破译：接收者以外的人试图将密文还原为明文。 秘钥：加密解密的钥匙。 对称密码：加密、解密使用同一秘钥。 非对称密码：加密、解密使用不同秘钥。（也称为公钥密码） 混合密码系统：结合对称密码和公钥密码的加密方式。 单向散列函数(one-way hash function)：用于保证数据的完整性 (integrity)。防篡改。 消息认证码(message authentication code)：用于确认消息是否来自期望的对象。防篡改、防伪装 (认证)。 数字签名(digital signature): 防篡改、防伪装、防止否认。 伪随机数生成器(Pseudo Random Number Generator, PRNG): 一种模拟产生随机数的算法。
密码常识 不要使用保密的密码算法 使用低强度的密码比不进行任何加密更危险 任何密码总有一天都会被破解 密码只是信息安全的一部分</description></item><item><title>图解密码技术 —— 第七章-单向散列函数</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid><description>第七章 单向散列函数 单向散列函数 (one-way hash function): 可以根据消息的内容，计算出散列值。
散列值可以被用于检查消息的完整性。 输入：消息 (message)；输出：散列值 (hash value)。 性质 抗碰撞性：collision resistance，难以发生碰撞。 单向性：one-way，无法通过散列值反算出消息的性质。
术语 单向散列函数：消息摘要函数、哈希函数、杂凑函数。 消息：原像。 散列值：消息摘要、指纹。 完整性：一致性。</description></item><item><title>图解密码技术 —— 第三章-对称密码</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/</guid><description>对称密码 用相同的秘钥进行加密和解密。
比特序列 编码：将现实中的东西映射为比特序列。 ASCII UTF-8 XOR——异或 XOR: exclusive or, 异或。
异或类似于加密解密过程： 消息 A异或秘钥 B = X X 异或 B = A 一次性密码本 原理：将明文与一串随机的比特序列进行 XOR 运算。 无法破解的原因：密文 XOR 破解秘钥得到的有意义明文，可能有多个，无法确定具体是哪个明文。
DES DES: Data Encryption Standard.
美国联邦信息处理标准中采用的一种对称密码。 一种将 64bit 明文加密成 64bit 密文的对称密码算法。 秘钥长度是 56bit。（实际 64bit，但由于每隔 7bit 设置一个错误检查 bit，因此是 56bit） 如果明文长于 64bit，则需要迭代加密。 差分分析 思路：改变一部分明文并分析密文如何随之改变。
线性分析 思路：将明文和密文的一些对应比特进行 XOR 并计算其结果为 0 的概率。
三重 DES 3DES(TDEA)：将 DES 重复 3 次。 分组长度为：64 * 3 = 192</description></item><item><title>图解密码技术 —— 第九章-数字签名</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</guid><description>数字签名 公钥密码：存在加密秘钥 (公钥) 和解密秘钥（私钥）。用公钥加密。 数字签名：签名秘钥（私钥）和验证秘钥（公钥）。用私钥加密。 数字签名并不是为了保证机密性。
签名的生成和验证 签名秘钥：私钥。用于对消息进行签名——生成签名。只能一人持有。 验证秘钥：公钥。用于验证消息的签名——验证签名。可以多人持有。
对消息签名的过程 A 用自己的私钥进行加密。 A 将签名和消息发送给 B。 B 用 A 的公钥进行解密（签名验证）。 B 将解密后的消息与 A 发过来的消息进行对比。一致，则验证成功，否则，验证失败。 对消息散列值签名的过程 公钥密码算法较慢，如果直接对消息进行签名，会比较耗时。
A 用单向散列函数计算消息的散列值。 A 用私钥对散列值进行加密。 A 将消息和签名发送给 B。 B 用 A 的 g 公钥对收到的签名进行解密。 B 将签名解密后得到的散列值与 A 发送的消息的散列值进行对比。一致，验证成功，否则，验证失败。 应用场景 信息公告 确保是目标组织发布的目标公告，法制被篡改。 软件下载 软件下载完成后，验证签名，防止软件遭到篡改。（并不能检测软件是否是恶意的） 公钥证书。 验证数字签名时，需要合法的公钥。对公钥进行签名得到的就是公钥证书。【第三方？？？】 SSL/TLS。 使用服务器证书验证服务器身份。 服务器证书：加上数字签名的服务器公钥。 总结 对称密码的秘钥是机密性的精华，单向散列函数的散列值是完整性的精华。</description></item><item><title>图解密码技术 —— 第二章-历史上的密码</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%AF%86%E7%A0%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%AF%86%E7%A0%81/</guid><description>第二章 历史上的密码 历史上著名的密码 凯撒密码 简单替换密码 Enigma 破译方法 暴力攻击 频率分析 凯撒密码 通过将明文中使用的字母表&amp;quot;平移&amp;quot;来进行加密。 秘钥空间：26 破解方式：直接暴力破解。
简单替换密码 更改 26 个字母的对应关系。如 A 表示 X（A 不再是 A）。 秘钥空间：26 x 25 x 24 x &amp;hellip; x 1 = 403291461126605635584000000 破解方式：频率分析 Enigma 略</description></item><item><title>图解密码技术 —— 第五章-公钥密码</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</guid><description>第五章 公钥密码 秘钥配送问题 解决方法 事先共享秘钥 密钥分配中心 Diffie-Hellman 密钥交换 公钥密码 RSA RSA 是一种公钥密码算法。名字来源于三位作者的姓。
Ron Rivest、Adi Shamir、Leonard Adleman RSA 加密 密文 = 明文 ^ E mode N 在 RSA 中，明文、密钥、密文都是数字。 密文等于明文的 E 次方对 N 取模） E = Encryption N = Number E和N的组合就是公钥。 RSA 解密 明文 = 密文 ^ D mod N D = Decryption N = Number D和N的组合就是私钥。 求 N N = p x q p和q是质数，由伪随机数生成器生成。 求 L L = lcm(p - 1, q - 1) lcm：取最小公倍数 求 E 1 &amp;lt; E &amp;lt; L gcd(E, L) = 1 gcd: 最大公约数 E 和 L 最大公约数是 1（互质） 求 D 1 &amp;lt; D &amp;lt; L E x D mode L = 1 中间人攻击 攻击方式： A 和 B 用公钥密码通讯。 中间人 X 对 A 冒充 B，对 B 冒充 A。 中间人攻击对所有公钥密码对是有效的。</description></item><item><title>图解密码技术 —— 第八章-消息认证码</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</guid><description>消息认证码 - 消息被正确传送了吗 消息认证码：Message Authentication Code，MAC。
是一种确认完整性并进行认证的技术。 是一种与秘钥相关联的单向散列函数。 输入：任意长度的消息 + 共享秘钥。 输出：固定长度的数据。 消息认证码使用的秘钥必须是密码学安全的、高强度的伪随机生成器。如果是人为选定，则会增加秘钥被推测的风险 消息验证码能与不能 不能保证消息的机密性； 不能防止否认； 能识别出篡改行为； 能对消息进行认证；（合法） 消息验证码的局限性 无法防止否认； 无法防止否认的本质是：相同的秘钥有多于 1 个人获得。</description></item><item><title>图解密码技术 —— 第六章-混合密码系统</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</guid><description>第六章 混合密码系统 用对称密码提高速度，用公钥密码保护会话密钥。
对称密码：用于加密消息/数据。 公钥密码：用于加密密钥/会话密钥。 对称密码和公钥密码的密钥长度必须具备同等强度。 考虑长期运用时，公钥密码的强度应该要高于对称密码。 因为对称密码的会话密钥被破解，只会影响到本次通信，而公钥被破译，会影响过去到未来所有通信内容。 密钥强度对比：
对称密码 AES 公钥密码 RSA 128 3072 192 7680 256 15360 问题 对称密码： 密钥传送问题 公钥密码： 中间人攻击 速度慢 混合密码加密过程 混合密码加密过程
混合密码解密过程 混合密码解密过程</description></item><item><title>图解密码技术 —— 第十一章-秘钥</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%A7%98%E9%92%A5/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%A7%98%E9%92%A5/</guid><description>第 11 章 秘钥——秘密的精华 什么是秘钥？ 秘钥：一个巨大的数字。
数字本身的大小不重要，重要的是秘钥空间的大小。 秘钥与明文是等价的。
常见的秘钥？ DES 秘钥：实质长度 56bit(7bytes)。 DES-EDE2 秘钥：实质长度 112bit(14bytes)。 DES-EDE3 秘钥：实质长度 168bit(21bytes)。 AES 秘钥：128/192/256bit 如何管理秘钥？ 需要清楚：信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。
生成秘钥： 用随机数生成秘钥； 密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的。 用口令生成秘钥； 配送秘钥： 事先共享秘钥; 更新秘钥： 定期更新，例如每发送 1000 字节数据更新一次。 更新方式：将当前秘钥的散列值作为下一个秘钥。 这种防止破译过去的通信内容的机制，称为向后安全。
保存秘钥
对秘钥进行加密：有助于减少需要保管的秘钥数量。 作废秘钥
为什么要作废秘钥？ 不再需要的秘钥及时作废，防止被解密。 如何作废秘钥？ 彻底删除秘钥。 秘钥的分类？ 对称、非对称。 用于认证、用于机密性。 Diffie-Hellman 秘钥交换 实际并没有交换秘钥，而是通过计算生成相同的秘钥，因此也称为Diffie-Hellman秘钥协商。 什么是基于口令的密码 (password based Encryption, PBE)？ 根据口令生成秘钥，再用秘钥进行加密的方法。 KEK：通过口令生成的秘钥。 CEK：通过随机数生成器生成的秘钥。 什么是盐？盐的作用是什么？ 盐：伪随机数生成器生成的随机数，和口令一起通过单向散列函数生成秘钥 (KEK)。 作用：用来防御字典攻击。 字典攻击：准备大量候选 KEK，逐一进行尝试。 什么是拉伸？ 拉伸：讲单向散列函数进行多次迭代的方法。 通过拉伸可以改良 PBE。 如何生成安全的口令？ 使用只有自己才能知道的信息。（大原则） 不要使用对自己重要的事物的名字。 不要使用关于自己的信息。 不要使用别人见过的信息。 将多个不同的口令分开使用。 有效利用笔记。 理解口令的局限性。 当对口令字符/长度进行限制时，秘钥的长度 (bit) 并不太长，可能可以通过暴力破解。 使用口令生成器和管理工具。</description></item><item><title>图解密码技术 —— 第十三章-PGP</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-pgp/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-pgp/</guid><description>PGP——密码技术的完美组合 什么是 PGP？ PGP: Pretty Good Privacy. 是Philip Zimmermann编写的密码软件。 PGP 有什么用？ 可以保护处于极端状况 (如：性命攸关) 下的人们的隐私。 什么是 OpenGPG？ OpenGPG：对秘闻和数字签名进行定义的标准规范：RFC1991/RFC2440/RFC4880/RFC5581/RFC6637。 GUN 遵照 OpenGPG(RFC4880) 规范编写了 GnuPG 自由软件。 什么是信任网？ PGP 采用的确认公钥合法性的方法。 注意：公钥是否合法和所有者是否可信是两个不同的问题，因为尽管公钥合法，其所有者也可以是不可信的。</description></item><item><title>图解密码技术 —— 第十二章-随机数</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid><description>第 12 章 随机数——不可预测性的源泉 随机数的作用？使用场景是什么？ 生成秘钥：用于对称密码和消息认证码。 生成秘钥对：用于公钥密码和数字签名。 生成初始化向量 (IV)：用于分组密码的 CBC/CFB/OFB 模式。 生成 nonce：用于防御重放共计以及分组密码的 CTR 模式等。 生成盐：用于基于口令的密码等。 随机数的性质 随机性——不存在统计学偏差，是完全杂乱的数列。 不可预测性——不能从过去的数列推测下一个出现的数。 不可重现性——除非将数列本身保存下来，否则不能重现相同的数列。 以上 3 个性质，越往下越严格。 随机数强度 弱伪随机数：只有随机性。 强伪随机数：具有随机性 + 不可预测性。 真随机数：同时具备上面三个性质。</description></item><item><title>图解密码技术 —— 第十章-证书</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%AF%81%E4%B9%A6/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%AF%81%E4%B9%A6/</guid><description>证书——为公钥加上数字签名 这章不是太理解。
什么是证书？ 证书：记录个人信息及公钥，并由认证机构施加数字签名. 证书是公钥证书的简称。
证书的应用场景？ 什么是公钥基础设施？ 公钥基础设施(PKI, Public-key Infrastructure): 为了能更有效运用公钥而制定的一系列规范和规格的总称。
公钥基础设置（PKI）的组成要素是什么？ 用户：使用 PKI 的人。 认证机构：颁发证书的人。 仓库：保存证书的数据库。 为什么需要证书？</description></item><item><title>图解密码技术 —— 第四章-分组密码的模式</title><link>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</guid><description>第四章 分组密码的模式 DES 和 AES 都属于分组密码，它们只能加密固定长度的明文。 如果需要加密任意长度的明文，则需进行迭代，而分组密码的迭代方法，就称为分组密码的模式。
分组密码与流密码 密码算法可以分为分组密码和流密码。 流密码：一次性密码本 分组密码：DES、AES、3DES 等大多数堆成密码算法。
模式分类 ECB：Electronic CodeBook mode，电子密码本模式。 CBC：Cipher Block Chaining mode，密码分组链接模式。 CFB：Cipher FeedBack mode，密文反馈模式。 OFB：Output FeedBack mode，输出反馈模式。 CTR：CounTeR mode，计数器模式。 GCM：Galois/Counter Mode, 。 初始化向量 由于加密第一个分组时，不存在“前一个密文分组”，因此事先准备一个长度为一个分组的 bit 序列来代替。此序列称为初始化向量(Initialization Vector, IV)
初始化向量必须使用不可预测的随机数。 ECB 模式 电子密码本模式：切割明文为多个分组，逐个加密。（容易有安全漏洞，不要使用）
加解密过程图示 加解密过程图示 CBC 模式 密码分组链接模式：密文分组像链条一样互相连接在一起。（前一个密文分组用于后一个分组的加密）
特点 无法直接对中间分组进行加密。 一个密文分组损坏，解密时最多只有两个明文分组受影响。（在密文长度没变的情况下） 加解密过程图示 加解密过程图示 CFB 模式 密文反馈模式：前一个密文分组被送到密码算法的输入端，用于生成下一个密文分组。
特点 依赖上一个密文分组。 加解密过程图示 加解密过程图示 OFB 模式 输出反馈模式：加密算法的输出作为下一个分组加密算法的输入。</description></item><item><title>安全 —— 使用 Snyk 及 Nessus 进行漏洞扫描</title><link>https://isshe.site/p/%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-snyk-%E5%8F%8A-nessus-%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E5%AE%89%E5%85%A8-%E4%BD%BF%E7%94%A8-snyk-%E5%8F%8A-nessus-%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</guid><description>漏洞扫描 本文主要介绍如何使用 nessus 进行主机扫描以及使用 snyk 进行 Docker 镜像扫描。
1. 主机扫描 1.1 安装 nessus 注意：需要空间 20 GB。
打开 nessus 官网
注册：
进入 nessus 下载页 下载：
安装
rpm -i Nessus-8.15.1-es7.x86_64.rpm 启动
/bin/systemctl start nessusd.service 进入管理界面：https://10.0.0.199:8834/
设置账号密码
初始化及编译插件
1.2 使用 nessus 添加 scan</description></item><item><title>操作系统 —— IO 多路复用之 epoll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</guid><description>epoll I/O 事件通知设施 (I/O event notification facility)。
1. epoll_create #include &amp;lt;sys/epoll.h&amp;gt; int epoll_create(int size); int epoll_create1(int flags); 作用：打开一个 epoll 文件描述符。 参数： size：Linux 2.6.8 后不再使用，但是必须大于 0。 flags： 0：和 epoll_create 行为一样。 O_CLOEXEC: 进程退出时关闭文件描述符。 返回： 失败：-1，设置 errno；否则： 返回一个指向一个新 epoll 实例的文件描述符；当不再使用此描述符时，应使用 close 关闭。 当所有指向此 epoll 实例的描述符都被关闭时，内核会释放相关资源。 2. epoll_ctl typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 作用：epoll 文件描述符的控制接口。 参数： epfd: epoll fd，epoll 文件描述符； op: EPOLL_CTL_ADD：注册 fd 到 epfd； EPOLL_CTL_MOD：修改与 fd 的关联 evnet 事件。 EPOLL_CTL_DEL：从 epfd 中删除 fd； fd: 要操作 (op) 的 fd； event: 与 fd 关联的事件。EPOLL_CTL_DEL 时这个参数被忽略，也可以直接为 NULL； 返回： 正常：0； 异常：-1，设置 errno； 数据结构说明； struct epoll_event的events的是位掩码的形式，取值是： EPOLLIN: 相关文件可读。(read) EPOLLOUT: 相关文件可写。(write) EPOLLRDHUP: 流套接字对端关闭连接，或关闭写入一半的连接。(在使用边沿触发时，此标志对于编写简单代码以检测对端关闭特别有用。) EPOLLPRI: 有紧急数据可读。 EPOLLERR: 相关文件描述符发生错误。（默认设置，不用手动设置） EPOLLHUP: 相关文件描述符被挂起。（默认设置，不用手动设置） EPOLLET: 相关文件描述符设置为边缘触发。（默认是水平触发） EPOLLONESHOT: 对相关描述符设置一次性行为。epoll_wait 一次后，不会再 wait，除非使用 EPOLL_CTL_MOD 重新设置。 EPOLLWAKEUP: 设置此标记，使事件排队时系统保持唤醒。 当系统设置了自动休眠模式 (/sys/power/autosleep) 时，为了保持设备唤醒直到事件处理完成，必须使用此标记。 EPOLLEXCLUSIVE：为附加到目标文件描述符 fd 的 epoll 文件描述符设置独占唤醒模式。【？？？】 3.</description></item><item><title>操作系统 —— IO 多路复用之 poll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</guid><description>poll 相关函数 #include &amp;lt;poll.h&amp;gt; struct pollfd { int fd; /* file descriptor */ short events; /* events to look for */ short revents; /* events returned */ }; int poll(struct pollfd fds[], nfds_t nfds, int timeout); 作用：类似于 select。（指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。） 参数： fds[]: 指向一个结构数组第一个元素的指针。 nfds: 指定 fds 中的元素个数。 timeout: INFTIM：永远等待；(INFTIM 被定义为一个负值) 0：立即返回； &amp;gt; 0: 等待指定数据的毫秒数。 返回： 成功：就绪描述符数目 超时：0 出错：-1 数据结构说明： events: 要测试的条件； revents: 返回描述符的状态。 events/revents标记： 常值 说明 能作为 evnets 的输入吗？ 能作为 revents 的输入吗？ POLLIN 普通或优先级带数据可读 + + POLLRDNORM 普通数据可读 + + POLLRDBAND 优先级带数据可读 + + POLLPRI 高优先级数据可读 + + POLLOUT 普通数据可写 + + POLLWRNORM 普通数据可写 + + POLLWRBAND 优先级带数据可写 + + POLLERR 发生错误 + POLLHUP 发生挂起 + POLLNVAL 描述符不是一个打开的文件 + 数据分类 poll 识别三类数据：普通 (normal)、优先级带 (priority band)、高优先级 (high priority)</description></item><item><title>操作系统 —— IO 多路复用之 select</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</guid><description>select select 函数允许进程指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。
1. select #include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); 作用：指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。 参数： nfds: 待测试的最大描述符 +1； readfds: 监听读的 fd 集合； writefds: 监听写得 fd 集合； errorfds: 监听异常的 fd 集合； timeout: 等待超时时间。 NULL: 永远等下去； 非 NULL 且不为值 0: 等待指定时间； 非 NULL 且值为 0: 不等待，检查描述符后立即返回。（轮询） 返回： 返回： 成功：就绪描述符数目 超时：0 出错：-1 2.</description></item><item><title>操作系统 —— 信号</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</guid><description>信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为： 1.信号发送和信号接收 待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix 系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数： #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;signal.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 发送 sig 指定信号到 pid 进程 int kill(pid_t pid, int sig); // 向自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题 待处理信号被阻塞。
例如：一个进程捕获一个信号 SIGINT 然后去处理程序处理信号，此时又来一个 SIGINT 信号，此信号会被阻塞。[疑问][1] （第 2 个信号不是 SIGINT 信号，那是否也还是阻塞？） 待处理信号不会排队等待。
任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？） 系统调用可以被中断。</description></item><item><title>操作系统 —— 线程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</guid><description>线程 当一个程序由 exec 启动执行时，系统将创建一个称为初始线程(initail thread)或主线程(main thread)的单个线程。 线程取消在8.5章，被取消的线程要释放相关资源（锁等），需要注意。 线程创建可能比进程创建快 10~100 倍； 线程或者是可汇合的(joinable)或者是脱离/分离的(detached)。（默认可汇合的） 可汇合的线程可以被其他线程回收其资源和杀死。 当可汇合的线程终止时，其线程 ID 和退出状态将保留，直到另一个线程调用 pthread_join; 脱离的线程则像守护进程：终止时，所有资源都释放，因此不能等待它终止； 线程是运行在进程上下文中的逻辑流。 1. 共享及私有 线程共享的内容：
进程指令； 大多数数据； 打开的文件（如描述符）； 信号处理程序和信号处置； 当前工作目录； 用户 ID 和组 ID； 线程私有的内容： 线程 ID； 寄存器集合（包括程序计数器和栈指针）； 栈； 栈指针； 程序计数器； errno； 信号掩码； 优先级； 2. 相关函数 2.1 pthread_create #include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); 作用：创建线程 参数： tid：线程 ID；这是结果参数； attr: 线程属性，如优先级、初始栈大小、是否是一个守护线程等；通常采用默认值； start_routine: 创建的线程所需要执行的函数；称为线程启动函数(thread start function); arg: 参数；如果有多个，则打包成一个结构即可； 返回： 成功：0 失败：Exxx 值 2.</description></item><item><title>操作系统 —— 进程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程是操作系统中最核心的概念。
定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。 逻辑流(逻辑控制流）：程序计数器 PC 值的序列。 异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。 并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发 (concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。 1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程； 1.进程地址空间 1.1 典型进程地址空间 1 典型进程地址空间 1
代码段起始地址： 32 位：0x08048000 64 位：0x00400000 进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。 1.2 典型进程地址空间 2 典型进程地址空间 2
2. 进程状态 2.1 状态转换图 状态转换图 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>Posix 信号量 信号量是一种提供不同进程间或一个进程的不同线程间同步手段的原语。 Posix 提供两类信号量：
有名 (named) 信号量 基于内存 (memory-base) 的信号量。【macOS 不支持】 Posix 信号量的函数调用 Posix 有名信号量至少具有岁内核的持续性。 Posix 信号量是计数信号量。 1.相关函数 #include &amp;lt;fcntl.h&amp;gt; /* For O_* constants */#include &amp;lt;sys/stat.h&amp;gt; /* For mode constants */#include &amp;lt;semaphore.h&amp;gt; // 打开 sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); // 关闭 int sem_close(sem_t *sem); // 删除 int sem_unlink(const char *name); // &amp;#34;加锁&amp;#34;——测试指定信号量的值，如果大于 0，将它 -1 int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // “解锁”——信号量 +1 int sem_post(sem_t *sem); // 获取信号量的值 (macOS 不支持) int sem_getvalue(sem_t *sem, int *sval); // 基于内存的信号量 (macOS 不支持) int sem_init(sem_t *sem, int shared, unsigned int value); int sem_destroy(sem_t *sem); A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 Posix.1 提供了两种无亲缘关系进程间共享内存区的方法：（都需要调用 mmap）
内存映射文件 (memory-mapped file)：由 open 函数打开，由 mmap 函数把得到的描述符映射到当前进程地址空间中的一个文件。 共享内存区对象 (share-memory object)：由 shm_open 打开一个 Posix.1 IPC 名字，所返回的描述符由 mmap 函数映射到当前进程的地址空间。 1. 相关函数 #include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 只是打开一个内存区对象，返回 fd // oflag: 必须函数 O_RDONLY、O_RDWR 中的一个。 // mode: // * 指定权限为，在指定了 O_CREAT 的前提下使用。 // * 与 mq_open 和 sem_open 不同，shm_open 的 mode 参数必须指定。 int shm_open(const char *name, int oflag, ...); // 删除一个共享内存区对象的名字。（删除一个名字不会影响低层支撑对象的现有引用。） int shm_unlink(const char *name); // 裁剪普通文件或者共享内存区对象 int ftruncate(int fd, off_t length); //获取打开的共享内存对象的信息 int fstat(int fildes, struct stat *buf); 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>Posix 信息队列 消息队列可认为是一个消息链表。具有随内核的持续性 有读权限的线程可以从队列中取走信息； 有写权限的线程可以从队列中放置信息； 允许异步事件通知。 1. 相关函数 #include &amp;lt;mqueue.h&amp;gt;// 打开消息队列 mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr */); // 关闭消息队列，调用进程不用，但不会被删除消息队列 int mq_close(mqd_t mqdes); // 从系统中删除消息队列 // mq_unlink(const char *name); // int mq_notify(mqd_t mqdes, const struct sigevent *notification); A. Posix 消息队列和 SystemV 消息队列的区别 Posix 消息队列的读总是返回最高优先级的最早消息；System V 消息队列的读可以返回任意指定优先级的消息。 往空队列放置一个消息时，Posix 消息队列允许产生一个信号或者启动一个线程。System V 没有类似的机制。</description></item><item><title>操作系统 —— 进程间通信之 SystemV 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>System V 信号量 1. 概述 二值信号量 (binary semaphore): 其值为 0 或 1 的信号量； 计数信号量 (counting semaphore): 其值为 0~某个限制值之间的信号量； 以上两种信号量，等待 (waiting) 操作都等待信号量的值变为大于 0； 计数信号量集 (set of counting semaphores): 一个或多个信号量 (构成一个集合), 其中的每个都是计数信号量。 System V 信号量通过此概念给信号量增加了一级复杂度。 当讨论 System V 信号量时，都是指计数信号量集；当讨论 Posix 信号量时，都是指计数信号量。
约定： semval: 信号量当前值 semncnt: 等待 semval 变为大于其当前值的线程数； semzcnt: 等待 semval 变为 0 的线程数； semadj: 所指定信号量针对调用进程的调整值；【？？？】 2.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>System V 共享内存区 1. 概述 System V 共享内存区在概念上类似于 Posix 共享内存区； Posix 共享内存区：先调用 shm_open，后调用 mmap; System V 共享内存区：先调用 shmget, 后调用 shmat; 2. shmget 函数 #include &amp;lt;sys/shm.h&amp;gt; int shmget(key_t key, size_t size, int shmflg); 作用：创建一个新的共享内存区或者访问一个已存在的共享内存区。 参数： key: ftok 的返回值或者 IPC_PRIVATE。 如果 key=IPC_PRIVATE 并且 shmflg 指定 IPC_CREAT 标记，则创建共享内存区。 如果没有 key 对应的共享内存标识符并且指定 IPC_CREAT，则创建共享内存区。 创建内存区会初始化内存区为 0。（size 字节） 创建共享内存区会分配shmid_ds结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation permissions */ int shm_segsz; /* size of segment in bytes */ pid_t shm_lpid; /* pid of last shm op */ pid_t shm_cpid; /* pid of creator */ short shm_nattch; /* # of current attaches */ time_t shm_atime; /* last shmat() time*/ time_t shm_dtime; /* last shmdt() time */ time_t shm_ctime; /* last change by shmctl() */ void *shm_internal; /* sysv stupidity */ }; size: 大小 shmflg：标记 返回：共享内存区标识符 (整数) 3.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 在新的应用程序中，不应再使用消息队列。【分布式系统里面，好像很常用！需要时再了解！】 详见此 Readme 2.4 节 若需要客户进程和服务器进程之间的双向数据流，用UNIX域套接字或全双工管道。 队列：消息队列。信息的链接表，存储在内核中，由标识符标识。 队列 ID：消息队列标识符。 与队列关联的数据结构：定义队列的当前状态 struct msqid_ds { struct ipc_perm msg_perm; msgqnum_t msg_qnum; // 队列里的消息长度/数量 msglen_t msg_qbytes; // 队列中能容纳的最大字节数 pid_t msg_lspid; // 最后 msgsnd() 的 pid pid_t msg_lrpid; // 最后 msgrcv() 的 pid time_t msg_stime; // 最后 msgsnd() 的时间 time_t msg_rtime; // 最后 msgrcv() 的时间 time_t msg_ctime; // 最后改变时间 } 1. 消息队列的系统限制 消息队列的系统限制</description></item><item><title>操作系统 —— 进程间通信之FIFO</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</guid><description>FIFO FIFO 有时被称为命名管道。 FIFO 是一种文件类型。 支持在无亲缘进程间使用。 1. FIFO 创建 创建 FIFO 类似于创建文件；FIFO 的路径名存在于文件系统中。 2. 创建 FIFO 相关函数 #include &amp;lt;sys/stat.h&amp;gt;int mkfifo(const char *path, mode_t mode); // 在 fd 表示的目录相关位置，创建一个 FIFO。 // * path 为绝对路径，则忽略 fd // * path 为相对路径，则 fd 参数是一个打开的目录的文件描述符。路径名和目录有关【？？？】 // * path 为相对路径，并且 fd 参数有特殊值 AT_FDCWD，则路径名以当前目录开始。 int mkfifoat(int fd, const char *path, mode_t mode); 3. 其他 open 一个 FIFO 时，非阻塞标记 (O_NONBLOCK) 会产生的影响： 一般情况下 (没有指定 O_NONBLOCK)， 只读 open 要阻塞到其他进程为写打开此 FIFO 为止； 只写 open 要阻塞到其他进程为读打开此 FIFO 为止； 如果指定了 O_NONBLOCK，则： 只读 open 时，立即返回。【返回啥？正常返回？】 只写 open 时，如果没有其他进程为读打开此 FIFO，则此只写 open 返回 -1，errno 置为 ENXIO。 若 write 一个没有进程为读打开的 FIFO，则产生信号 SIGPIPE。（类似 pipe） 若 FIFO 的最后一个写进程关闭了该 FIFO，则将为改 FIFO 的读进程产生一个文件结束标记。（类似于 pipe） FIFO 的两种用途： shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件； 客户——服务器进程应用中，FIFO 用作汇聚点，在客户和服务器进程间传递数据； 4.</description></item><item><title>操作系统 —— 进程间通信之共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 共享内存区是可用 IPC 形式中最快的。 一旦内存区映射到共享它的进程的地址空间，这些进程间的数据传递就不需要经过内核了；但是读写内存区时，需要进行同步。 非共享缓冲区读文件传给另一个进程写：4 次内核与内核的交互 非共享缓冲区读文件传给另一个进程写 共享缓冲区读文件传给另一个进程写：2 次内核与进程的交互 共享缓冲区读文件传给另一个进程写 1. 相关函数 1.1 mmap mmap: 把一个文件或一个 Posix 共享内存区对象映射到调用进程的地址空间。 使用此函数有 3 个目的： 使用普通文件以提供内存映射 I/O； 使用特殊文件以提供匿名内存映射； 使用 shm_open 以提供无亲缘关系进程间的 Posix 共享内存区。 映射文件示意图： 映射文件示意图 #include &amp;lt;sys/mman.h&amp;gt; // addr: 指定 fd 映射到的进程内空间的起始地址； // len: 映射的长度——字节数； // offset: 从被映射文件开头起 offset 字节开始映射； // prot: 属性/模式 (PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE) // * PROT_NONE Pages may not be accessed.</description></item><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定 PIPE_BUF 的值。 当管道的一端被关闭后，适用的规则：
当读 (read) 一个写端被关闭的管道，在所有数据被读取后，read 返回 0； 当写 (write) 一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write 返回 -1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.</description></item><item><title>操作系统 —— 进线程同步之互斥锁、条件变量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>互斥锁与条件变量 互斥锁及条件变量是同步的基本组成部分。 互斥锁及条件变量出自Posix.1线程标准； 可以用来同步一个进程内的各个线程； 也可以用在进程间同步：互斥锁放在多个进程的共享内存区中。 1.互斥锁 互斥锁：相互排斥，是最基本的同步形式。 作用：保护临界区（critical region）。 保护的是数据：临界区中被操纵的数据；进程/线程共享的数据。 互斥锁是协作性锁，也就是锁无法防止一些进程/线程不先获取锁就访问数据。（需要靠自觉） 1.1 相关函数 静态分配使用PTHREAD_MUTEX_INITIALIZER进行初始化 #include &amp;lt;pthread.h&amp;gt; // 互斥锁初始化、销毁 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); // 上锁、解锁 int pthread_mutex_lock(pthread_mutex_t *mptr); int pthread_mutex_trylock(pthread_mutex_t *mptr); int pthread_mutex_unlock(pthread_mutex_t *mptr); // 属性初始化、销毁 int pthread_mutexattr_init(pthread_mutexattr_t *attr); int pthread_mutexattr_destroy(pthread_mutexattr_t *attr) // 属性设置：进程间共享等（MACOS 和 LINUX 相关函数有所不同） // 均返回：成功：0，失败：正的 Exxx 值 2. 条件变量 互斥锁用于上锁，条件变量用于等待。 每个条件变量总是与一个互斥锁相关联。 2.</description></item><item><title>操作系统 —— 进线程同步之读写锁</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 1. 什么是读写锁 互斥锁把试图进入临界区的 (多余) 线程都阻塞住，无论是读还是写。（不区分读写） 独占锁。 读写锁区分读和写，同时只能一个线程写 (写时不能读)；允许同时多个线程读 (读时没有写)。 读为共享锁，写为独占锁。 读比写更频繁的应用中，用读写锁更好。 2. 读写锁的分配规则 只要没有线程持有读写锁用于写，任意数目的线程可以持有该读写锁用于读。 仅当没有线程持有读写锁时 (用于读或写)，才能分配读写锁用于写。 3. 相关函数 静态分配用PTHREAD_RWLOCK_INITIALIZER进行初始化。 #include &amp;lt;pthread.h&amp;gt; // 初始化、销毁 int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy(pthread_rwlock_t *lock); // 加锁、解锁 int pthread_rwlock_rdlock(pthread_rwlock_t *lock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock); int pthread_rwlock_wrlock(pthread_rwlock_t *lock); int pthread_rwlock_trywrlock(pthread_rwlock_t *lock); int pthread_rwlock_unlock(pthread_rwlock_t *lock); // 属性初始化、销毁 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); // 属性设置：设置进程间共享：PTHREAD_PROCESS_SHARED/PTHREAD_PROCESS_PRIVATE int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);</description></item><item><title>网络协议 —— ARP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/</guid><description>ARP 协议 ARP（Address Resolution Protocol）：地址解析协议，是根据 IP 地址获取物理地址的一个 TCP/IP 协议。
工作过程 当主机 A 要与主机 B 通信时，地址解析协议可以将主机 B 的 IP 地址解析成主机 B 的 MAC 地址 (如果 A/B 不同网段，则 A 解析的应该是下一跳的 MAC 地址)，以下为工作流程：
第 1 步：主机 A 根据路由表内容，确定用于访问主机 B 的转发 IP 地址。主机 A 在本地 ARP 缓存中查找与主机 B 的 IP 匹配 MAC 地址。 第 2 步：如果主机 A 没有找到映射，则将 ARP 请求帧广播到本地网络上的所有主机。 收到请求的主机检查自己的 IP 是否匹配，不匹配就丢弃此 ARP 请求。 第 3 步：主机 B 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将主机 A 的 IP 地址和 MAC 地址映射添加到本地 ARP 缓存中。 第 4 步：主机 B 将包含其 MAC 地址的 ARP 回复消息直接发送回主机 A。 第 5 步：当主机 A 收到从主机 B 发来的 ARP 回复消息时，会用主机 B 的 IP 和 MAC 地址映射更新 ARP 缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机 B 的 MAC 地址一旦确定，主机 A 就能向主机 B 发送 IP 通信了。 问题 什么是 ARP 欺骗？ 地址解析协议是建立在网络中各个主机可互相信任的基础上的，收到应答报文的主机，不会校验报文的真实性，就会加到 ARP 缓存中。 由此，攻击者可以向某一主机发送伪 ARP 应答报文，使此主机发送的信息无法到达预期的主机或者到达错误的主机，这就是 ARP 欺骗。</description></item><item><title>网络协议 —— DHCP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/</guid><description>DHCP DHCP - 动态主机设置协议（Dynamic Host Configuration Protocol）。 DHCP 是一个应用层协议。基于UDP。
作用 用于内网或网络服务供应商自动分配 IP 给用户。 作为内部管理员对所有计算机进行中央管理的手段。 历史 DHCP 在 1993 年 10 月成为标准协议，它的前身是BOOTP协议。 BOOTP：BOOTP 是一种网络协议，让电脑或其他周边仪器可以从服务器下载启动程序。 数据包类型 DHCP 发现（DISCOVER）：client 在物理子网上发送广播来寻找可用的服务器。 DHCP 提供（OFFER）：当 DHCP 服务器收到一个来自客户的 IP 租约请求时，它会提供一个 IP 租约。 DHCP 请求（REQUEST）：当客户 PC 收到一个 IP 租约提供时，它必须告诉所有其他的 DHCP 服务器它已经接受了一个租约提供。 DHCP 确认（Acknowledge，ACK）：确认租约，包含租期和客户可能请求的其他所有配置信息。 DHCP 释放 (RELEASE)：客户端向 DHCP 服务器发送一个请求以释放 DHCP 资源，并注销其 IP 地址。 DHCP NAK：服务器回复客户，客户要求的网址不能被分配。 原理/流程 客户主机发送 DHCP 服务器发现 (DISCOVER)广播包。 服务器收到 DISCOVER 包后，回复OFFER单播或广播包。【疑问？】 客户主机收到 OFFER 包后，发送REQUEST广播包。 服务器回复ACK单播或广播包。包含分配的 IP 及网关 IP(next server IP)、租约等。 典型 DHCP 会话的模式</description></item><item><title>网络协议 —— DNS</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/</guid><description>DNS DNS - 域名系统（Domain Name System）。
是一个将域名和IP地址进行映射的分布式数据库。 DNS 是应用层协议，使用 TCP 和 UDP 的 53 端口。 每一级域名长度的限制是 63 个字符，域名总长度不能超过 253 个字符。 作用 将对人友好的域名转换为对计算机友好的 IP 地址。 原理/过程 域名层级
主机名.次级域名.顶级域名.根域名 host.sld.tld.root www.isshe.xyz.root abc.isshe.xyz.root 分级查询：从根域名开始，依次查询每一级域名的 NS 记录。
从根域名服务器查询顶级域名服务器的 NS 记录和 A 记录； 根域名服务器是总所周知的，不用查。 从顶级域名服务器查询次级域名服务器的 NS 记录和 A 记录； 从次级域名服务器查询主机名的 A 记录； 分级查询示例：www.isshe.xyz
dig +trace www.isshe.xyz 进行查看
列出根域名服务器： . 227343 IN NS e.</description></item><item><title>网络协议 —— ICMP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/</guid><description>ICMP ICMP - 互联网控制消息协议（Internet Control Message Protocol） ICMP 是互联网协议族的核心协议之一。 IMCP 用于发送控制消息，提供可能发生在通信环境中的各种问题反馈。 ICMP 消息都是直接封装在一个 IP 数据包中的，因此，和 UDP 一样，ICMP 是不可靠的。 原理及技术细节 每个路由器在转发数据报的时候都会把 IP 包头中的 TTL 值减 1。 报文结构 ICMP 报头从 IP 报头的第 160 位 (20 字节) 开始：（有可选部分另算）
8bit 8bit 8bit 8bit +------+------+------+------+ | Type | Code | Checksum | +------+------+------+------+ | ID | Sequence | +------+------+------+------+ Type: ICMP 报文类型。 Code：进一步划分 ICMP 的类型；该字段用来查找产生错误的原因。 例如，ICMP 的目标不可达类型可以把这个位设为 1 至 15 等来表示不同的意思。 Checksum：校验和。 ID：ID/标识，在 Echo Reply 类型的消息中需要返回这个字段。 Sequence：序号，在 Echo Reply 类型的消息中需要返回这个字段。 报文类型 Type Code Status 描述 查询 差错 备注 0：Echo 响应 0 Echo 响应 ✓ ping 中使用 1 未分配 ✓ 保留 2 未分配 ✓ 保留 3：目的不可达 0 目标网络不可达 ✓ 1 目标主机不可达 ✓ 2 目标协议不可达 ✓ 3 目标端口不可达 ✓ 4 要求分段并 (但) 设置 DF 标记 ✓ 5 源路由失败 ✓ 6 未知的目标网络 ✓ 7 未知的目标主机 ✓ 8 源主机隔离（作废不用） ✓ 9 禁止访问的网络 ✓ 10 禁止访问的主机 ✓ 11 对特定的 TOS 网络不可达 ✓ 12 对特定的 TOS 主机不可达 ✓ 13 由于过滤 网络流量被禁止 ✓ 14 主机越权 ✓ 15 优先权终止生效 ✓ 4：源端关闭 0 弃用 源端关闭（拥塞控制） ✓ 5：重定向 0 重定向网络 ✓ 1 重定向主机 ✓ 2 基于 TOS 的网络重定向 ✓ 3 基于 TOS 的主机重定向 ✓ 6 弃用 备用主机地址 7 未分配 保留 8 0 Echo 请求 ✓ 9 0 路由通告 ✓ 10 0 路由器的发现/选择/请求 ✓ 11：超时 0 TTL 超时 ✓ 1 分片重组超时 ✓ 12：参数问题-IP 头部错误 0 IP 报文首部参数错误 ✓ 1 丢失必要选项 ✓ 2 不支持的长度 13 0 时间戳请求 ✓ 14 0 时间戳应答 ✓ 15 0 信息请求 ✓ 16 0 信息应答 ✓ 17 0 地址掩码请求 ✓ 18 0 地址掩码应答 ✓ 19 保留 因安全原因保留 20~29 保留 保留用于稳健性实验 30~39 弃用 40 Photuris, Security failures ？？？ 41 用于实验性移动协议，如 Seamoby[RFC4065] 42~255 保留 235 实验性 RFC3692 254 实验性 RFC3692 部分报文结构示例 3：目标不可达 目的地不可达由主机或其入站网关生成，以通知客户端由于某种原因目的地不可达。</description></item><item><title>设计模式 —— 代理模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：为某个对象提供一种代理，以控制对这个对象的访问。
控制对象的访问；只有需要时才创建、初始化。 别名：Proxy，Surrogate[ˈsɜ:rəgət]
类图： 类图
可能的对象图 对象图
出场嘉宾
Subject: 定义 RealSubject 和 Proxy 的共用接口。使得可以在任何使用 RealSubject 的地方使用 Proxy。 Proxy: 代理。继承自 Subject。 保存 RealSubject 的引用。 提供与 RealSubject 相同的接口，以代替 RealSubject。 控制对 RealSubject 的存取/访问，并可能负责创建、删除。 针对类型的功能： 远程代理：负责对请求及参数进行编码，编发送给不同地址空间的实体。 虚拟代理：可缓存真实对象的附加信息，以延迟对真实对象的访问/创建。如，图片代理缓存图片的大小，尺寸。 保护代理：检查调用者的权限，保护真实对象。 RealSubject: 真实的对象，被 Proxy 代表的实体。 Client: 使用 Subject。 协作/工作流程</description></item><item><title>设计模式 —— 单件模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid><description>单件模式——独一无二的对象 初看起来好像很简单，实际接触后，发现并不是这么一回事。先给自己几个问题：
创建对象的时候，如何知道现在只有一个？ 如何保证创建对象时候的原子性？（不能保证就有可能创建多于 1 个的对象） 如何获取/访问这个唯一对象？ 1. 基础概念 定义/意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 原理：让类自身保存它的唯一实例，并提供一个访问该实例的方法。实例的唯一性由类来保证。 类图： 类图 出场嘉宾 Singleton：单件类。 定义一个接口，允许客户访问唯一实例。此接口是一个类操作。 负责创建唯一实例。 2. 解决什么问题？如何解决？ 系统中，有些东西只需要一份就够了，因此要保证只有一份。 解决方法：只允许创建一个。但如何保证只有一个呢，见其他部分。 3. 优缺点是什么？ 3.1 优点 对唯一实例的创建是受控的——不允许直接创建（new 或变量）。 对唯一实例的访问是受控的。 缩小命名空间。 此模式是对全局变量的一种改进。 避免了存储唯一实例的全局变量污染命名空间。 （同一命名空间内，两个名字相同，就会冲突。） 允许对操作和表示的精化。【？！】 单件类可以有子类。 可以使用所需的拓展类在运行时配置应用。 允许可变的数目的实例。 比类操作更灵活。 如果使用类操作（C++ 的静态成员函数、Smalltalk 的类方法）的方式来封装单件功能，会使得改变设计以允许多个实例变得困难。 惰性 (lazy) 初始化，惰性创建——不需要的时候，不会创建。 3.2 缺点 4.</description></item><item><title>设计模式 —— 外观模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式——让接口更简单 外观模式：Facade /fəˈsɑːd/
目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：让接口更简单 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 使用外观模式 别名： 类图/结构： 类图 出场嘉宾 Facade：外观 知道哪些子系统负责处理哪些请求； 将客户请求代理给适当的子系统； Subsystem Classes：其他子系统类 实现子系统的功能； 处理由 Facede 指派的任务； 没有 Facade 的任何信息； 协作/工作流程 客户 -&amp;gt; Facade -&amp;gt; Subsystem 客户发送请求给 Facede； Facede 将请求适当转发到子系统； 子系统完成请求工作，返回请求结果给 Facede； Facede 返回请求结果给客户； 2. 解决什么问题？如何解决？ 降低系统间的通信和相互依赖关系。 3.</description></item><item><title>设计模式 —— 工厂方法模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法 工厂方法模式 (Factory Method Pattern) 又称为：
工厂模式； 虚拟构造器 (Virtual Constructor) 模式 多态工厂 (Polymorphic Factory) 模式 它属于类创建型模式。 1. 基础概念 定义/意图：
定义一个创建对象的接口，让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。 框架使用抽象类定义和维护对象之间的关系。 类图： 类图
出场嘉宾
产品/Product: 定义产品。 具体产品/Concrete Product: 定义具体的产品，继承自产品。 创建者/Creator：工厂；工厂的抽象类，声明工厂方法。 创建者可以定义一个默认的缺省实现，返回一个缺省的具体产品。 具体创建者/Concrete Creator: 具体工厂；继承自工厂，用于创建具体产品。 2. 解决什么问题？如何解决？ 3. 优缺点是什么？ 3.1 优点 【简单工厂的优点】 将创建对象的代码集中在一个对象或一个方法中，避免重复代码。 实例化对象时，依赖接口，不依赖具体类。【？！】 添加新产品时，不需修改旧代码，只需添加新的具体产品和具体创建者。 3.2 缺点 必须创建创建者的子类，无论用户想创建的具体产品是一个还是多个。（成对添加） 4.</description></item><item><title>设计模式 —— 抽象工厂模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>设计模式 Readme 模板 1. 基础概念 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
类图： 类图
出场嘉宾
AbstractFactory: 抽象工厂；声明具体工厂的接口——声明了一个创建抽象产品对象的接口。 ConcreteFactory: 具体工厂；继承自抽象工厂，实现了创建具体产品对象的操作。 AbstractProduct: 抽象产品；声明具体产品的接口——声明了一类产品对象的接口。 ConcreteProduct: 具体产品；继承自抽象产品，定义了一个将被具体工厂创建的产品对象，实现了抽象产品的接口， Client: 仅使用由抽象工厂和抽象产品类声明的接口——不使用具体工厂、具体产品的接口/方法。 工作方式：
运行时创建具体工厂对象，具体工厂对象创建具体产品对象。 客户使用不同的具体工厂对象，创建不同的具体产品对象。 抽象工厂将产品对象的创建延迟到具体工厂。 2. 解决什么问题？如何解决？ 需联合使用一系列产品的时候，可使用此模式 其他见【4.使用场景】 3. 优缺点是什么？ 3.1 优点 分离了具体的类： 工厂封装创建产品对象的过程，将客户和类的实现分离。客户通过抽象接口操纵实例。 具体产品的类名也在具体工厂的实现中被分离，它们不会出现在客户代码中。 易于交换产品系列： 一个具体工厂类在一个应用中仅出现一次——它初始化的时候； 改变具体工厂类即可改变产品配置——具体工厂类A换为具体工厂类B,则产品配置从 A 也更换到 B。 有利于产品的一致性：【？？？】 一个系列的产品对象被设计成一起工作的时候，一个应用一次只能使用同一个系列中的对象。【？？？】 3.</description></item><item><title>设计模式 —— 模板方法模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>模板方法模式——用继承改变算法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：定义一个操作的算法的骨架，将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 别名：无 类图： 类图 出场嘉宾 AbstrackClass：抽象类 定义抽象的原语操作(primitive operation)，各个步骤的具体实现交给子类。 实现一个模板方法，定义一个算法的步骤。 实现不变的部分。 ConcreteClass：具体类 实现原语操作，完成特定步骤的具体实现。 实现变动的部分。 协作/工作流程 AbstrackClass 实现不变的部分（或骨架）； ConcreteClass 实现变动的部分； AbstrackClass 和 ConcreteClass 实现整个操作/算法。 效果 模板方法是一种代码复用的基本技术。在类库中尤为重要。 模板方法导致一种反向的控制结构——&amp;ldquo;好莱坞原则&amp;rdquo;——即&amp;quot;别找我们，我们会找你&amp;quot;——父类调用子类的操作。 模板方法可能调用下列类型的操作： 具体的操作：ConcreteClass 或对客户类的操作。 具体的 AbstractClass 的操作：即通常对子类有用的操作。 原语操作：即抽象操作 工厂方法 钩子操作 (hook operation)：提供缺省的行为，子类可在必要时进行扩展。 2. 优缺点是什么？ 2.</description></item><item><title>设计模式 —— 状态模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid><description>状态 (State) 模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：允许一个对象再起内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 别名：状态对象 (Objects for States) 类图： 类图 出场嘉宾 Context: 上下文、环境 定义客户感兴趣的接口。 维护一个 ConcreteState 子类的实例，表示当前状态。 State：状态，抽象类/接口 定义一个接口，以封装与 Context 的特定状态相关的行为。 ConcreteState：具体状态 定义一个具体的状态，实现一个与 Context 的一个状态的相关的行为。 协作/工作流程 Context 保存一个 ConcreteState 对象，表示当前状态。 Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。 Context 可将自身作为一个参数传递给处理请求的状态对象。 Context 是客户使用的主要接口。 Context 和 ConcreteState 都可以决定哪一个状态是后继状态。 2.</description></item><item><title>设计模式 —— 策略模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid><description>策略模式——用委托改变算法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图： 定义一系列算法，把它们一个个封装起来，并使它们可以相互替换。 本模式使得算法可以独立于使用它的客户而变化。 别名：Policy（政策） 类图： 类图 出场嘉宾 Strategy：策略，定义算法的公共接口。 Context 使用这个接口来调用某个 ConcreteStrategy 定义的算法。 ConcreteStrategy：具体策略，实现具体的算法。 Context：上下文 用已成而 ConcreteStrategy 对象来配置；【？？？】 维护一个对 Strategy 对象的引用； 可定义一个接口来让 Strategy 访问它的数据。 协作/工作流程 Strategy 和 Context 相互作用，以实现选定的算法。 Context 将算法需要的参数传给 Strategy，或 Context 将自己作为参数传给 Strategy。 Context 将它的客户的请求转发给它的 Strategy。 客户通常创建并传递一个 ConcreteStrategy 对象给该 Context（客户仅与 Context 交互）。 客户通常可以选择一系列的 ConcreteStrategy。 2.</description></item><item><title>设计模式 —— 简单工厂模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>简单工厂模式 别称：静态工厂方法 简单工厂并不是一种模式，而是一种编程习惯。——《Head First 设计模式》 代码比较简单，就不写代码的 Readme 了 1. 基础概念 定义/意图：无 类图： 类图 出场嘉宾 产品/Product：产品，抽象类（或接口） 具体产品/Concrete Product：具体产品，继承/实现 Product 工厂/Creator：工厂，用于生产 Product 2. 解决什么问题？如何解决？ 无
3. 优缺点是什么？ 3.1 优点 把变化集中到一块，易于管理。 &amp;ldquo;消费对象&amp;quot;不需要直接创建具体产品 (Concrete Product)，把对象创建和使用分开。 3.2 缺点 工厂类集中了多个其他类，违反了高内聚责任分配原则。【？！】 有新的具体产品时，需要修改代码，不符合开闭原则。 随着具体产品增加，判断添加回变多，维护回变难。 这些缺点在工厂方法模式中得到解决。
4. 使用场景是什么？ 工厂类负责创建的对象固定、较小。（变动不频繁） 对创建对象的逻辑不关心。 5. 注意 由于简单工厂模式容易违反高内聚责任分配原则，因此一般只在较简单的情况下应用。 6. 应用实例？ 无 x. 疑问 y.</description></item><item><title>设计模式 —— 组合模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：将对象组合成树形结构以表示部分-整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 别名：Composite 类图 1： 类图 类图 2： 类图 典型对象图： 对象图 出场嘉宾 Component: 组合 为组合中的对象声明接口。 在适当情况下，实现公共接口的缺省行为。 声明一个接口用于访问和管理Component 组件。 Leaf: 叶节点，叶子部件 在组合中表示叶节点对象，叶节点没有子节点。 定义节点对象的具体的行为。 Composite: 组合部件，有孩子的部件。 定义有孩子节点的节点的行为。 存储孩子节点。 在 Component 接口中实现与子节点有关的操作。 Client： 通过 Component 接口操纵组合部件的对象。 协作/工作流程 Client 使用 Component 接口与组合结构中的对象 (Composite/Leaf) 进行交互。 如果接收者是叶节点，则直接处理请求。 如果接收者是 Composite，通常转发请求给它的子部件，在转发之前或之后，可能执行一些辅助操作。 2.</description></item><item><title>设计模式 —— 装饰者模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>装饰者模式——不改变接口，但加入责任 1. 基础概念 定义：动态地给一个对象添加一些额外的职责。
注意是针对对象而不是类 类图： 类图
出场嘉宾：
[基础]组件 (Conponent): 被装饰者，定义一个对象接口（Java：接口，C++：抽象类）； 具体[基础]组件 (Concrete Conponent): 定义一个具体的基础组件对象，可以给这个对象添加一些职责（装饰该对象）。 装饰者 (Decorator): 维持一个指向组件对象的指针，并定义一个与组件接口一致的接口。(指针是为了知道所修饰的是什么) 具体装饰者 (Concrete Decorator): 可以向具体组件添加职责（修饰）。 2. 解决什么问题？如何解决？ 解决用继承给对象添加功能不够灵活的问题。 通常拓展一个类都是用继承的方法，这是静态拓展，随着拓展增多，子类会膨胀。 解决方法：具体组件和修饰者都继承自公共的类，使一个对象能装饰另一个对象。 3. 优缺点是什么？ 3.1 优点 拓展功能时，提供比继承更有弹性的解决方案。（可增加、删除职责） 比静态继承更灵活。 可通过动态的方式在运行时选择不同的具体装饰类，实现不同的行为。 可以对一个对象进行多次修饰（甚至多次相同的修饰）。 符合开闭原则，具体组件和具体修饰者可以独立变化，用户根据需要添加组件或装饰者，原代码不需修改。 装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的 3.2 缺点 可能有许多小对象，排错难度加大、代码阅读难度加大。 可能不同的东西，继承自一个公共类。（个人理解） 4. 使用场景是什么？ 在不影响其他对象的情况下，已动态、透明的方式给单个对象添加职责。 处理那些可以撤销的职责。 怎么实现撤销？？？ 当不能使用子类/继承的方法进行扩充时。 情况一：类定义被隐藏，因此无法用于生成子类。 情况二：有大量独立的扩展，为支持每一种组合将产生大量子类。（使子类书目爆炸性增长） 5.</description></item><item><title>设计模式 —— 观察者模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>观察者模式 1. 基础概念 定义：定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 类图： 类图 出场嘉宾 主题 (Subject)：出版者、被观察者、 观察者 (Observer)：订阅者、 具体主题 (Concrete Subject): 对主题的实现 具体观察者 (Concrete Observer): 对观察者的实现 观察者模式就和报纸订阅/取消订阅、邮件订阅/取消订阅类似。 出版者（主题）+ 订阅者（观察者）=观察者模式
2. 解决什么问题？如何解决？ （易用、低耦合、高度协作）解决一个对象状态改变通知其他多个对象的问题。 3. 优缺点是什么？ 3.1 优点 支持一对多通信。 符合开闭原则。【疑问？？？】 在主题和观察者之间建立一个抽象的耦合。【抽象的耦合？？？】 3.2 缺点 当一个主题的观察者过多时，通知会比较耗费时间。 当 主题 和 观察者有循环依赖时，会导致循环调用。 观察者无法知道变化过程，只能知道变化结果。 4. 使用场景是什么？ 一个对象要通知其他[多个]对象自己改变时（可能并不知道这些对象是谁）； 一个对象要导致其他[多个]对象自己改变时； 需要创建触发链时； 5. 应用实例？ 天气预报服务器数据更新，客户端实时展示更新后的数据。（《Head First 设计模式》示例） 电子商务网站向多个用户推送商品信息。 x.</description></item><item><title>设计模式 —— 迭代器模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>迭代器模式——提供不暴露聚合对象内部表示的访问聚合对象各个元素的方法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露改对象的内部表示。 别名：游标（Cursor） 分类：对象行为型模式 类图： 类图 出场嘉宾 Iterator: 迭代器 定义访问和遍历元素的接口。 ConcreteIterator: 具体迭代器 实现对具体聚合对象的迭代器接口。 对聚合对象遍历时，跟踪当前位置。 Aggregate：聚合 定义创建相应迭代器对象的接口。 ConcreteAggregate：具体聚合 实现创建相应迭代器的接口 返回 ConcreteIterator 的一个适当实例。 协作/工作流程 通过 ConcreteAggregate 创建 ConcreteIterator； 通过 ConcreteIterator 访问/遍历 ConcreteAggregate。 2. 优缺点是什么？ 2.1 优点 支持以不同的方式遍历一个聚合。 复杂的聚合可用多种方式进行遍历。 迭代器简化了聚合的接口。 用了迭代器的遍历接口，聚合就不需要提供遍历接口，于是就简化了聚合的接口。 同一个聚合上可以有多个聚合。 每个迭代器保持自己的遍历状态，因此可以同时进行多个遍历。 2.</description></item><item><title>设计模式 —— 适配器模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式——将一个接口转换成另一个接口 目标： 初接触此模式时，熟悉最常用的使用方式。如，对象适配器。 有更深的理解后，再研究其他使用方法。如，类适配器和双向适配器 1. 基础概念 定义/意图： 将一个类的接口转换成另一个接口。适配器 (Adapter) 模式使得原来接口不兼容的类可以一起工作。 把一个东西，伪装成另一个东西！ 别名：包装器（Wrapper） 类图 1：类适配器类图（使用多重继承对一个接口与另一个接口进行匹配） 类图 类图 2：对象适配器类图 类图 出场嘉宾 Target: 定义 Client 使用的与特定领域相关的接口。 Client：与符合 Target 接口的对象协同。 Adaptee：已存在的接口，被适配者。 Adapter：对 Adaptee 接口与 Target 接口进行适配，适配器。 协作/工作流程 Client 在 Adapter 实例上调用一些操作。 Adapter 调用 Adaptee 的操作，以实现用户请求。 2. 解决什么问题？如何解决？ 在不改变原有 Target 和 Adaptee 代码情况下，对 Adaptee 用 Target 的方式访问。 解决方法：在两者之间添加一个中间层——Adapter。 3.</description></item><item><title>Valgrind 快速上手</title><link>https://isshe.site/p/valgrind-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link><pubDate>Sun, 20 Aug 2023 20:30:05 +0800</pubDate><guid>https://isshe.site/p/valgrind-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid><description>Valgrind 快速上手 1、介绍 Valgrind 工具集提供了一系列调试和剖析工具，可以帮助我们写出更快更正确的程序。 其中最常用的工具是 Memcheck。可以检测很多 C 或 C++ 程序中导致奔溃或未知行为的内存错误。
2、准备程序 使用 -g 选项编译程序，使程序包含调试信息（debug info），这样可以让 Memcheck 的错误信息包含详细的行号。 如果可以允许程序变慢，使用 -O0 来编译最好；如果是 -O1 则行号可能有错，不过一般能正常工作，速度相对 -O0 也提升明显；-O2 或以上的优化级别则不建议使用，可能导致 Memcheck 报告未初始化值的错误。
使用 Valgrind 执行程序 如果程序正常是使用以下方式执行：
myprog arg1 arg 则，改为下面的方式：
valgrind --leak-check=yes myprog arg1 arg2 这个命令中没有指定 Memcheck，是因为 Memcheck 是默认的工具；--leak-check 选项打开详细的内存泄露检测器。 此时程序可能比平时慢很多（例如 20、30 倍），并且会使用多很多内存。Memcheck 将显示检测到的内存错误或内存泄露信息。
解释 Memcheck 的输出 // example.c #include &amp;lt;stdlib.h&amp;gt;void f(void) { int* x = malloc(10 * sizeof(int)); x[10] = 0; // problem 1: heap block overrun // problem 2: memory leak -- x not freed } int main(void) { f(); return 0; } 这是一个有内存泄露和内存错误的程序。</description></item><item><title>动态追踪 —— BPFTool</title><link>https://isshe.site/p/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-bpftool/</link><pubDate>Sun, 20 Aug 2023 20:30:05 +0800</pubDate><guid>https://isshe.site/p/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-bpftool/</guid><description>BPFTool 安装 git clone git@github.com:torvalds/linux.git git checkout v5.4 cd tools/bpf/bpftool make &amp;amp;&amp;amp; make install 使用 特征查看 查看当前系统所支持的所有特征。
bpftool feature 启用 jit cat /proc/sys/net/core/bpf_jit_enable echo 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable 获取系统中已运行的 BPF 程序 bpftool prog show bpftool prog show id &amp;lt;ID&amp;gt; bpftool prog show id &amp;lt;ID&amp;gt; --json bpftool prog dump xlated id &amp;lt;ID&amp;gt; bpftool prog dump xlated id &amp;lt;ID&amp;gt; visual &amp;amp;&amp;gt; output.out # sudo apt install graphviz dot -Tpng output.out -o visual-graph.png 启用 BPF 统计信息 sysctl -w kernel.</description></item><item><title>数据库 —— Postgresql 慢查询分析</title><link>https://isshe.site/p/%E6%95%B0%E6%8D%AE%E5%BA%93-postgresql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</link><pubDate>Wed, 01 Feb 2023 06:00:04 -0400</pubDate><guid>https://isshe.site/p/%E6%95%B0%E6%8D%AE%E5%BA%93-postgresql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</guid><description>Postgresql 慢查询语句记录与分析 1. 记录 postgresql 以 12 版本为例
我们需要先打开 postgresql 的慢查询日志，此为前置条件，先记录下我们时间较长的查询。
编辑配置文件：/var/postgres12/data/postgresql.conf #log_min_duration_statement = -1 # -1 is disabled, 0 logs all statements # and their durations, &amp;gt; 0 logs only # statements running at least this number # of milliseconds 修改 -1 为 200，表示大于等于 200 毫秒的操作将被记录到日志。
重载配置 /path/to/pg_ctl reload -D /path/to/pgdata 2. 获取慢查询语句 2.1 切 postgresql 超户 sudo su - postgres 2.2 获取慢查询语句 打开日志文件 less /path/to/pg_log/postgresql.</description></item><item><title>个人感悟 —— 国家公祭日有感</title><link>https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/</link><pubDate>Sat, 25 Dec 2021 02:22:19 -0400</pubDate><guid>https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/</guid><description>2021 年国家公祭日有感 我是一个南方人，一直以来，都不太愿意去了解这些同胞受难的事情，不愿意面对；同时，也不知道该以什么样的心情去面对。
我不确定一个人、一个军队，在祖国强盛、自己满怀荣光的情况下，如何能够做出这样的事情。 一个人为之，或许可以称之为堕落；一个军队，大概是集体兽化了吧。
何为人？这个提问出自《一人之下》。
“张三”说：法律是道德的最低标准，我们不应该以不违法来标榜自己。 我也是这么认为的。 但是对于我个人来说，我希望我更有原则，更加旗帜鲜明：
旗帜鲜明地表达自己的立场——热爱自己、热爱家人、热爱祖国、热爱这片土地； 旗帜鲜明地反对屠杀之类禽兽行为； 牢记历史，热爱和平。</description></item></channel></rss>