<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 树深时间录</title><link>https://isshe.site/post/</link><description>Recent content in Posts on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 13 Dec 2021 16:07:25 +0000</lastBuildDate><atom:link href="https://isshe.site/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 内核 —— 中断</title><link>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</guid><description>中断 1. 硬件中断注册 #include &amp;lt;linux/interrupt.h&amp;gt; static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) 作用：申请一个中断线。 参数： irq: 中断线号 handler: 中断处理函数 flags: name: dev: 2. 硬件中断释放 #include &amp;lt;linux/interrupt.h&amp;gt; const void *free_irq(unsigned int irq, void *dev_id); 作用：释放一个中断线。如果没有其他设备注册该IRQ线，就关闭该IRQ。 参数： irq: 中断线号。 dev_id: 设备标识。 3. 中断类型 网络设备常见的中断事件类型：
接收一帧：最常见、标准的情况。 传输失败； DMA传输已成功完成； drivers/net/3c59x.c有相关范例。 设备有足够内存处理新传输； 4.</description></item><item><title>Linux 命令 —— gdb</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</guid><description>gdb gdb - GNU调试器。
调试器(如GDB)的目的是允许你查看其他程序在执行时的&amp;quot;内部&amp;quot;的内容，或者程序奔溃的时候正在做什么。 GDB可以做4种主要的事情来帮助你捕捉bug：
启动你的程序，指定任何可能影响程序行为的内容。 使程序在指定条件下停止。 检查你程序停止时，正在发生的事情。 更改程序中的内容，以便你可以尝试纠正一个错误的影响并继续了解另一个错误。 你可以用GDB来调试C、C++、Fortran、Modula-2编写的程序。 使用gdb命令来调用GDB。一旦启动，它会从中断读取命令，直到你用GDB命令&amp;quot;exit&amp;quot;告诉它退出。你可以用GDB命令help来查看帮助（不用退出gdb）。 你可以运行没有参数或选项的gdb ; 但是最常用的启动GDB的方法是使用一个或两个参数，将可执行程序指定为参数：
gdb program
您还可以从可执行程序和指定的core文件开始：
gdb program core
如果要调试正在运行的进程，则可以将进程ID指定为第二个参数：
gdb program 1234 gdb -p 1234
将GDB附加(attach)到1234进程（除非你由一个名字为1234的core文件，gdb会先查找core文件）。 以下是一些常用的GDB命令:
break [file:]function 在函数(文件)中设置断点。 缩写：b。 用法： b &amp;lt;行号&amp;gt;，如：b 8 b &amp;lt;函数名称&amp;gt;，如：b main b *&amp;lt;函数名称&amp;gt;，如：b *main（在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”） b *&amp;lt;代码地址&amp;gt;，如：b *0x804835c。 d [breakpoint number] 删除断点 run [arglist] 开始你的程序（arglist是参数列表） 缩写：r bt 回溯(backtrace)：显示程序堆栈。 print expr 显示表达式expr的值。 缩写：p c 继续运行你的程序（在停止后，例如断电）。continue的缩写。 next 继续下一行(在停止后)；不进入函数的单步调试。 缩写：n edit [file:]function 查看程序当前停止的行。 list [file:]function 在当前停止的位置附近键入程序的文本。 step 继续下一行(在停止后)；进入函数的单步调试。 缩写：s i 显示各类信息。如：i r，显示寄存器的信息 help [name] 显示GDB命令name的信息，或有关使用GDB的一般信息。 quit 退出GDB。 缩写：q 有关GDB的完整详细信息，请参阅：A Guide to the GNU Source-Level Debugger</description></item><item><title>Linux 命令 —— git</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</guid><description>git submodule 添加submodule： git submodule add &amp;lt;subproject URL&amp;gt; &amp;gt; git submodule add https://github.com/isshe/gitsubproject 查看subproject的commit： git diff --cached &amp;lt;subproject dir&amp;gt; &amp;gt; git diff --cached gitsubproject/ 查看subproject的.gitmodules： git diff --cached --submodule 自动clone每个submodule： git clone --recursive &amp;lt;your repository url&amp;gt; &amp;gt; git clone --recursive https://github.com/isshe/gitproject 拉取子模块： git submodule init git submodule update &amp;gt; 更常用的是：递归更新 git submodule update --init --recursive 子模块的后续更新：
git submodule update --remote 调整submodule的commit： git pull origin xxx 切submodule的分支： git config -f .gitmodules submodule.</description></item><item><title>Linux 命令 —— ip</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</guid><description>ip 显示/操纵路由、设备、策略路由、隧道。
概要 ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics } OPTIONS := { -V[ersion] | -h[uman-readable] | -s[tatistics] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -n[etns] name | -a[ll] | -c[olor] } OBJECT:</description></item><item><title>Linux 命令 —— modprobe</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</guid><description>modprobe modprobe - 向Linux内核添加或从内核移除模块。
modprobe智能地从Linux内核添加或删除模块：
注意，模块名称中-和_没有区别（自动执行下划线转换）。 modprobe在模块目录/lib/modules/'uname -r'(符号冲突了，用'代替)中查找所有模块和其他文件。 除了/etc/modprobe.d目录是的可选配置文件。详见modprobe.d modprobe还将以&amp;lt;module&amp;gt;.&amp;lt;option&amp;gt;的形式使用内核命令行上指定的模块选项。 modprobe.blacklist=&amp;lt;module&amp;gt;的形式使用黑名单。 如果在modulename之后给出了任何参数，它们将被传递给内核。 除了配置文件中列出的选项。 用法 modprobe [-v] [-V] [-C config-file] [-n] [-i] [-q] [-b] [modulename] [module parameters...] modprobe [-r] [-v] [-n] [-i] [modulename...] modprobe [-c] modprobe [--dump-modversions] [filename] 选项 -a, --all 加载命令行中指定的所有模块。 -b, --use-blacklist 此选项使modprobe将配置文件（如果有）中的黑名单命令也应用于模块名称。 它通常由udev(7)使用。 -C, --config 此选项会覆盖缺省配置目录（/etc/modprobe.d） 此选项通过安装或删除命令传递给 MODPROBE_OPTIONS环境变量中 的其他modprobe命令。 -c, --showconfig 输出config目录中的有效配置并退出。 --dump-modversions 打印出模块所需的模块版本信息列表。 分发版通常使用此选项，以便使用模块版本控制deps(依赖？)打包Linux内核模块。 -d, --dirname 模块的根目录，默认是`/`。 --first-time 通常，如果告知插入已存在的模块或删除不存在的模块，modprobe将成功（并且不执行任何操作）。 这是简单脚本的理想选择; 然而，更复杂的脚本通常想知道modprobe是否真的做了一些事情： 这个选项使modprobe失败，因为它实际上没有做任何事情。 --force-vermagic 每个模块都包含一个包含重要信息的小字符串，例如内核和编译器版本。 如果模块无法加载并且内核抱怨`version magic`不匹配，则可以使用此选项将其删除(抱怨)。 当然，这个检查是为了保护你的，所以这个使用选项是危险的，除非你知道你在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 --force-modversion 当使用CONFIG_MODVERSIONS集编译模块时，会创建模块使用（或由模块提供）的每个接口的版本的详细说明。 如果模块无法加载并且内核抱怨模块不同意某个接口的版本，则可以使用“--force-modversion”来完全删除版本信息。 当然，这项检查是为了保护您的，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -f, --force 尝试从模块中删除任何可能阻止加载的版本信息：这与使用--force-vermagic和--force-modversion相同。 当然，这些检查是为了您的保护，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -i, --ignore-install, --ignore-remove 此选项使modprobe忽略命令行中，指定的模块的配置文件（如果有）中的安装和删除命令（任何相关模块仍然受配置文件中为它们设置的命令的限制）。 当使用此选项时，无论是否仅使用--ignore-install或--ignore-remove中的一个或其他（而不是两个）更具体地进行请求，将忽略安装和删除命令。 详见modprobe.</description></item><item><title>Linux 命令 —— netstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</guid><description>netstat 显示当前的连接情况。（UDP、TCP、UNIX、ICMP等） 显示路由表、网络接口列表、网络统计信息、多播信息、伪装连接等。
1. 介绍 1.1 用法 netstat [-vWeenNcCF] [&amp;lt;Af&amp;gt;] -r netstat {-V|--version|-h|--help} netstat [-vWnNcaeol] [&amp;lt;Socket&amp;gt; ...] netstat { [-vWeenNac] -i | [-cWnNe] -M | -s } 1.2 选项 -r, --route 显示路由表 -i, --interfaces 显示接口列表 -g, --groups 显示多播组成员 -s, --statistics 显示网络统计信息 -M, --masquerade display masqueraded connections【？？？】 -v, --verbose 详细 -W, --wide 不要截断IP地址 -n, --numeric 不要解析IP成域名（直接使用IP，不经过域名服务器） --numeric-hosts 不要解析主机名 --numeric-ports 不要解析端口名 --numeric-users 不要解析用户名 -N, --symbolic 解析硬件名 【？？？】 -e, --extend 显示更多信息 -p, --programs 显示进程ID和进程名 -c, --continuous 持续列出网络状态 -l, --listening 显示LISTENING状态的连接 -a, --all, --listening 显示所有连接(默认: 显示CONNECTED的连接) -o, --timers 显示计时器 【netstat -to】 -F, --fib 显示转发信息库（Forwarding Information Base），默认显示 -C, --cache 显示路由缓存(routing cache)而不是FIB -t, --tcp 显示TCP信息 -u, --udp 显示UDP信息 -w, --raw 实现raw信息 -x, --unix 显示unix信息 --ax25 显示AMPR AX.</description></item><item><title>Linux 命令 —— ssh</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</guid><description>ssh 隧道 场景：家里内网机器 A 想要访问公司的内网机器 B。 条件：需要一个公网机器 C （假设IP是 1.1.1.1）。
打开公网机器的转发
在 B 上执行:
ssh -p 22 -NR 0.0.0.0:10443:0.0.0.0:443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：C 的信息 # 后面部分 0.0.0.0:443：B 的信息 注意：此时链接会一直保持，终端不会返回。
在 A 上执行: ssh -p 22 -NL 0.0.0.0:10443:0.0.0.0:10443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：A 的信息 # 后面部分 0.0.0.0:10443：C 的信息 注意：此时链接会一直保持，终端不会返回。
此时，在 A 上通过 localhost:10443 即可访问 B 的 443。
端口映射 此方法相比上面的更为简化，直接把内网端口映射到外网设备上，直接访问外网设备映射的端口即可。
修改公网设备的 ssh 配置 sudo vi /etc/ssh/sshd_config # 设置 GatewayPorts yes # 重启 ssh 服务 sudo systemctl restart sshd 进行端口映射 在内网机器上：</description></item><item><title>Linux 命令 —— strace</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</guid><description>strace strace - 跟踪系统调用和信号。
在最简单的情况下，strace运行指定的命令直到它退出。 它拦截并记录由进程调用的系统调用和进程接收的信号。 每个系统调用的名称，其参数和返回值都打印在标准错误或使用-o选项指定的文件上。 strace是一种有用的诊断，指导和调试工具。 跟踪中的每一行都包含系统调用名称，后跟括号中的参数及其返回值。如：
open(&amp;#34;/dev/null&amp;#34;, O_RDONLY) = 3 系统调用错误，如：(返回 -1，并打印出错原因)
open(&amp;#34;/foo/bar&amp;#34;, O_RDONLY) = -1 ENOENT (No such file or directory) 信号，如：
sigsuspend([] &amp;lt;unfinished ...&amp;gt; --- SIGINT (Interrupt) --- +++ killed by SIGINT +++ 正在执行系统调用的同时，另一个线程/进程调用另一个系统调用，则strace将尝试保留这些事件的顺序并将正在进行的调用标记为未完成。 当调用返回时，它将被标记为已恢复：
[pid 28772] select(4, [3], NULL, NULL, NULL &amp;lt;unfinished ...&amp;gt; [pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0 [pid 28772] &amp;lt;... select resumed&amp;gt; ) = 1 (in [3]) 系统调用被中断后重启，如：
read(0, 0x7ffff72cf5cf, 1) = ?</description></item><item><title>Linux 命令 —— tcpdump</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</guid><description>tcpdump tcpdump - dump traffic on a network（转储网络上的流量）。
用法 tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ -Q in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,.</description></item><item><title>Linux 命令 —— vmstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</guid><description>vmstat 报告虚拟内存统计信息：进程，内存，分页，块IO，陷阱(traps)、磁盘和cpu活动。
用法 vmstat [options] [delay [count]] vmstat [-f] [-s] [-m] vmstat [-S unit] vmstat [-d] vmstat [-p disk partition] vmstat [-V] 选项 delay 更新之间的延迟，以秒为单位。如果未指定延迟，则仅打印一个报告：自引导以来的平均值。 count 更新次数。如果未指定计数且指定了延迟(delay)，则count默认为无穷大。 -a, --active 显示活动和非活动内存（2.5.41及之后的版本） -f, --forks 显示自引导以来的fork数。 这包括fork，vfork和clone系统调用，并且是相当于创建的任务总数。 每个进程由一个或多个任务表示，具体取决于线程用法。此显示不重复（也就是只显示一次）。 -m, --slabs 显示slabinfo。【相关字段含义见下面部分】 -n, --one-header 标题仅显示一次而不是定期显示。 -s, --stats 显示各种事件计数器和内存统计信息。此显示不重复（也就是只显示一次）。 -d, --disk 报告磁盘信息（2.5.70及之后版本） -D, --disk-sum 报告一些有关磁盘活动的摘要统计信息。 -p, --partition device 分区的详细统计信息。 (2.5.70及之后版本). -S, --unit character 更换输出的单位：1000(k)，1024(K)，1000000(m)，1048576(M) 字节。 注意，这不会改变交换(si/so)或块(bi/bo)字段。 -t, --timestamp 为每一行附加时间戳。 -w, --wide 宽屏输出模式（对于具有较高内存量的系统非常有用，其中默认输出模式会受到不必要的列断裂影响）。 输出宽度会超过每行80个字符。 -V, --version 显示版本信息并退出。 -h, --help 显示帮助信息并退出。 字段描述 VM 模式字段描述 进程 r: 可运行进程的数量 (正在运行+就绪状态)。 b: 处于不可中断睡眠的进程数量。 内存 swpd: 使用的虚拟内存量。 free: 空闲内存量。(idle) buff: 用作缓冲区(buffer)的内存量。 cache: 用作缓存(cache)的内存量。 inact: 非活动内存量。（-a选项） active: 活动内存量。（-a选项） 交换内存 si: 从磁盘交换的内存量（/s）。 so: 交换到磁盘的内存量（/s）。 IO bi: 从块设备接收的块数（blocks/s）。 bo: 发送到块设备的块数（blocks/ s）。 系统 in: 每秒的中断数，包括时钟。 cs: 每秒上下文切换次数。 CPU 这些是总CPU时间的占比。 us: 运行非内核代码所花费的时间。 (用户时间, 包括nice时间) sy: 运行内核代码所花费的时间。 (系统时间) id: 空闲时间。在2.</description></item><item><title>VLAN 介绍</title><link>https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/vlan-%E4%BB%8B%E7%BB%8D/</guid><description>VLAN VLAN - 虚拟局域网（Virtual Local Area Network）。 在IEEE 802.1Q中，给定以太网上的最大VLAN数为4094。（12位VID。减去头尾的0和4095）
作用 VLAN可以为网络提供以下作用： 广播控制 带宽利用 降低延迟 安全性（非设计作用，本身功能所附加出的） 采用虚拟局域网技术实现交换机以太网的广播隔离。 一个VLAN相当于OSI模型第2层的广播域，它能将广播控制在一个VLAN内部。 不同VLAN之间或VLAN与LAN/WAN的数据通信必须通过第3层（网络层）完成。 原理（划分方式） 物理层(physical layer) 以交换机端口作为划分VLAN的基础。 适合规模不大的组织。 数据链路层(data link layer) 以每台主机的MAC地址作为划分VLAN的基础。 实现方法： 创建一个MAC与VLAN映射的数据库。 当网络设备连接到端口后，交换机向VMPS(VLAN管理策略服务器)请求这个数据库。 找到相应的映射，完成VLAN的分配。 优点： 计算机物理位置的不同，也不影响VLAN的运作。 缺点： 人为建立MAC与VLAN的映射关系；因此导致管理复杂度增加。 网络层 以IP地址作为划分VLAN的基础；以子网视为VLAN设置的依据。【？？？】 优点： 网管人员已经将内部网段做好规划与分配后，将可大辐降低规划并设置VLANs架构的复杂度。 缺点： 交换机需要对帧进行处理（原本不需要），降低交换机接收和分派分组的效率。</description></item><item><title>个人感悟 —— 国家公祭日有感</title><link>https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5%E6%9C%89%E6%84%9F/</guid><description>2021 年国家公祭日有感 我是一个南方人，一直以来，都不太愿意去了解这些同胞受难的事情，不愿意面对；同时，也不知道该以什么样的心情去面对。 我不确定一个人、一个军队，在祖国强盛、自己满怀荣光的情况下，如何能够做出这样的事情。 一个人为之，或许可以称之为堕落；一个军队，大概是集体兽化了吧。 何为人？这个提问出自《一人之下》。 “张三”说：法律是道德的最低标准，我们不应该以不违法来标榜自己。 我也是这么认为的。 但是对于我个人来说，我希望我更有原则，更加旗帜鲜明：
旗帜鲜明地表达自己的立场——我热爱自己、热爱家人、热爱祖国、热爱这片土地； 旗帜鲜明地反对屠杀之类禽兽行为；</description></item><item><title>操作系统 —— 信号</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</guid><description>信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为： 1.信号发送和信号接收 待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数: #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;signal.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 发送sig指定信号到pid进程 int kill(pid_t pid, int sig); // 向自己发送SIGALRM信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题 待处理信号被阻塞。
例如：一个进程捕获一个信号SIGINT然后去处理程序处理信号，此时又来一个SIGINT信号，此信号会被阻塞。[疑问][1] （第2个信号不是SIGINT信号，那是否也还是阻塞？） 待处理信号不会排队等待。
任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？） 系统调用可以被中断。
如read、wait、accept这样的慢速系统调用被信号打断，但是信号处理函数返回后不再继续被打断的系统调用，而是立即返回错误，errno为EINTR。 详见ex_SIGCHLD.c
教训：不可以用信号来对其他进程中发生的时间计数
3.</description></item><item><title>操作系统 —— 进程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程是操作系统中最核心的概念。
定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。 逻辑流(逻辑控制流）：程序计数器PC值的序列。 异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。 并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发(concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。 1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程； 1.进程地址空间 1.1 典型进程地址空间1 典型进程地址空间1
代码段起始地址： 32位：0x08048000 64位：0x00400000 进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。 1.2 典型进程地址空间2 典型进程地址空间2
2. 进程状态 2.1 状态转换图 状态转换图 2.2 基本状态 1）运行态：进程实际占用CPU； 2）就绪态：可运行； 3）阻塞态：除非某种外部事件发生(使进程满足运行条件)，否则进程不能运行。 2.3 引入的状态： 创建状态； 终止状态； 挂起状态；（图中没有） 3.</description></item><item><title>网络协议 —— ARP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-arp/</guid><description>ARP协议 ARP（Address Resolution Protocol）：地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。
工作过程 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址解析成主机B的MAC地址(如果A/B不同网段，则A解析的应该是下一跳的MAC地址)，以下为工作流程：
第1步：主机A根据路由表内容，确定用于访问主机B的转发IP地址。主机A在本地ARP缓存中查找与主机B的IP匹配MAC地址。 第2步：如果主机A没有找到映射，则将ARP请求帧广播到本地网络上的所有主机。 收到请求的主机检查自己的IP是否匹配，不匹配就丢弃此ARP请求。 第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 问题 什么是ARP欺骗？ 地址解析协议是建立在网络中各个主机可互相信任的基础上的，收到应答报文的主机，不会校验报文的真实性，就会加到ARP缓存中。 由此，攻击者可以向某一主机发送伪ARP应答报文，使此主机发送的信息无法到达预期的主机或者到达错误的主机，这就是ARP欺骗。</description></item><item><title>网络协议 —— DNS</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dns/</guid><description>DNS DNS - 域名系统（Domain Name System）。
是一个将域名和IP地址进行映射的分布式数据库。 DNS是应用层协议，使用TCP和UDP的53端口。 每一级域名长度的限制是63个字符，域名总长度不能超过253个字符。 作用 将对人友好的域名转换为对计算机友好的IP地址。 原理/过程 域名层级
主机名.次级域名.顶级域名.根域名 host.sld.tld.root www.isshe.xyz.root abc.isshe.xyz.root 分级查询：从根域名开始，依次查询每一级域名的NS记录。
从根域名服务器查询顶级域名服务器的NS记录和A记录； 根域名服务器是总所周知的，不用查。 从顶级域名服务器查询次级域名服务器的NS记录和A记录； 从次级域名服务器查询主机名的A记录； 分级查询示例：www.isshe.xyz
dig +trace www.isshe.xyz 进行查看
列出根域名服务器： . 227343 IN NS e.root-servers.net. . 227343 IN NS k.root-servers.net. . 227343 IN NS i.root-servers.net. . 227343 IN NS d.root-servers.net. . 227343 IN NS j.root-servers.net. . 227343 IN NS m.</description></item><item><title>网络协议 —— ICMP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/</link><pubDate>Mon, 13 Dec 2021 16:07:25 +0000</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-icmp/</guid><description>ICMP ICMP - 互联网控制消息协议（Internet Control Message Protocol） ICMP是互联网协议族的核心协议之一。 IMCP用于发送控制消息，提供可能发生在通信环境中的各种问题反馈。 ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。 原理及技术细节 每个路由器在转发数据报的时候都会把IP包头中的TTL值减1。 报文结构 ICMP报头从IP报头的第160位(20字节)开始：（有可选部分另算）
8bit 8bit 8bit 8bit +------+------+------+------+ | Type | Code | Checksum | +------+------+------+------+ | ID | Sequence | +------+------+------+------+ Type: ICMP报文类型。 Code：进一步划分ICMP的类型；该字段用来查找产生错误的原因。 例如，ICMP的目标不可达类型可以把这个位设为1至15等来表示不同的意思。 Checksum：校验和。 ID：ID/标识，在Echo Reply类型的消息中需要返回这个字段。 Sequence：序号，在Echo Reply类型的消息中需要返回这个字段。 报文类型 Type Code Status 描述 查询 差错 备注 0：Echo响应 0 Echo响应 ✓ ping中使用 1 未分配 ✓ 保留 2 未分配 ✓ 保留 3：目的不可达 0 目标网络不可达 ✓ 1 目标主机不可达 ✓ 2 目标协议不可达 ✓ 3 目标端口不可达 ✓ 4 要求分段并(但)设置DF标记 ✓ 5 源路由失败 ✓ 6 未知的目标网络 ✓ 7 未知的目标主机 ✓ 8 源主机隔离（作废不用） ✓ 9 禁止访问的网络 ✓ 10 禁止访问的主机 ✓ 11 对特定的TOS 网络不可达 ✓ 12 对特定的TOS 主机不可达 ✓ 13 由于过滤 网络流量被禁止 ✓ 14 主机越权 ✓ 15 优先权终止生效 ✓ 4：源端关闭 0 弃用 源端关闭（拥塞控制） ✓ 5：重定向 0 重定向网络 ✓ 1 重定向主机 ✓ 2 基于TOS的网络重定向 ✓ 3 基于TOS的主机重定向 ✓ 6 弃用 备用主机地址 7 未分配 保留 8 0 Echo请求 ✓ 9 0 路由通告 ✓ 10 0 路由器的发现/选择/请求 ✓ 11：超时 0 TTL超时 ✓ 1 分片重组超时 ✓ 12：参数问题-IP头部错误 0 IP报文首部参数错误 ✓ 1 丢失必要选项 ✓ 2 不支持的长度 13 0 时间戳请求 ✓ 14 0 时间戳应答 ✓ 15 0 信息请求 ✓ 16 0 信息应答 ✓ 17 0 地址掩码请求 ✓ 18 0 地址掩码应答 ✓ 19 保留 因安全原因保留 20~29 保留 保留用于稳健性实验 30~39 弃用 40 Photuris, Security failures ？？？ 41 用于实验性移动协议，如Seamoby[RFC4065] 42~255 保留 235 实验性 RFC3692 254 实验性 RFC3692 部分报文结构示例 3：目标不可达 目的地不可达由主机或其入站网关生成，以通知客户端由于某种原因目的地不可达。</description></item><item><title>网络协议 —— DHCP</title><link>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/</link><pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate><guid>https://isshe.site/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-dhcp/</guid><description>DHCP DHCP - 动态主机设置协议（Dynamic Host Configuration Protocol）。 DHCP是一个应用层协议。基于UDP。
作用 用于内网或网络服务供应商自动分配IP给用户。 作为内部管理员对所有计算机进行中央管理的手段。 历史 DHCP在1993年10月成为标准协议，它的前身是BOOTP协议。 BOOTP：BOOTP是一种网络协议，让电脑或其他周边仪器可以从服务器下载启动程序。 数据包类型 DHCP发现（DISCOVER）：client在物理子网上发送广播来寻找可用的服务器。 DHCP提供（OFFER）：当DHCP服务器收到一个来自客户的IP租约请求时，它会提供一个IP租约。 DHCP请求（REQUEST）：当客户PC收到一个IP租约提供时，它必须告诉所有其他的DHCP服务器它已经接受了一个租约提供。 DHCP确认（Acknowledge，ACK）：确认租约，包含租期和客户可能请求的其他所有配置信息。 DHCP释放(RELEASE)：客户端向DHCP服务器发送一个请求以释放DHCP资源，并注销其IP地址。 DHCP NAK：服务器回复客户，客户要求的网址不能被分配。 原理/流程 客户主机发送DHCP服务器发现(DISCOVER)广播包。 服务器收到DISCOVER包后，回复OFFER单播或广播包。【疑问？】 客户主机收到OFFER包后，发送REQUEST广播包。 服务器回复ACK单播或广播包。包含分配的IP及网关IP(next server IP)、租约等。 典型DHCP会话的模式
协议结构 +-------+--------+--------+--------+ |8 bits | 8 bits | 8 bits | 8 bits | +-------+--------+--------+--------+ | Op | Htype | Hlen | Hops | +-------+--------+--------+--------+ | Xid | +----------------------------------+ | Secs | Flags | +----------------+-----------------+ | Ciaddr | +----------------------------------+ | Yiaddr | +----------------------------------+ | Siaddr | +----------------------------------+ | Giaddr | +----------------------------------+ | Chaddr (16 bytes) | +----------------------------------+ | Sname (64 bytes) | +----------------------------------+ | File (128 bytes) | +----------------------------------+ | Option (variable) | +----------------------------------+ Op: 信息类型。如：客户端请求为1，服务器回复为2。 Htype：硬件类型。如：Ethernet(0x01) Hlen: 硬件地址长度。如：6。（MAC地址） Hops: 跳数。 Xid：传输ID。 Secs: 过去的时间。【疑问】 Flags：标记。 Ciaddr：客户端IP地址。（这里应该是续约的时候用的） Siaddr：下一个服务器IP地址。 Yiaddr：你的IP。（分配给客户机的IP） Giaddr：中继代理IP。【？？？】 Chaddr：客户机硬件地址。（Ethernet中就是Mac地址） Sname：服务器主机名称。 File：文件名。 Options：选项。详见rfc2132 1：子网掩码； 3：路由(网关)； 12：主机名 50：请求的IP地址 51：租约时间 53：DHCP消息类型。即上面的几种类型。 54：服务器标识。 疑问 DHCP服务器是否可以把一台主机拉黑？ 这个应该由DHCP软件提供。 服务器回复为什么是单播或广播包？ Flags中设置BROADCAST = 0时，则是单播；否则是广播。这是为了健壮性，同时兼容单播和多播。 Secs字段是哪一个时间段？ 从获取到IP地址或者续约过程开始到现在所消耗的时间。 Giaddr字段作用是什么？ giaddr: 中继代理地址。 中继代理相关详见：博客 相关 DHCP: RFC 2131 DHCP6: RFC 3315 DHCP wiki DHCP wiki中文 rfc2132</description></item></channel></rss>