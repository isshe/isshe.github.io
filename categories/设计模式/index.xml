<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 树深时间录</title><link>https://isshe.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2024 20:58:12 +0800</lastBuildDate><atom:link href="https://isshe.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式 —— 代理模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：为某个对象提供一种代理，以控制对这个对象的访问。
控制对象的访问；只有需要时才创建、初始化。 别名：Proxy，Surrogate[ˈsɜ:rəgət]
类图： 类图
可能的对象图 对象图
出场嘉宾
Subject: 定义 RealSubject 和 Proxy 的共用接口。使得可以在任何使用 RealSubject 的地方使用 Proxy。 Proxy: 代理。继承自 Subject。 保存 RealSubject 的引用。 提供与 RealSubject 相同的接口，以代替 RealSubject。 控制对 RealSubject 的存取/访问，并可能负责创建、删除。 针对类型的功能： 远程代理：负责对请求及参数进行编码，编发送给不同地址空间的实体。 虚拟代理：可缓存真实对象的附加信息，以延迟对真实对象的访问/创建。如，图片代理缓存图片的大小，尺寸。 保护代理：检查调用者的权限，保护真实对象。 RealSubject: 真实的对象，被 Proxy 代表的实体。 Client: 使用 Subject。 协作/工作流程</description></item><item><title>设计模式 —— 单件模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid><description>单件模式——独一无二的对象 初看起来好像很简单，实际接触后，发现并不是这么一回事。先给自己几个问题：
创建对象的时候，如何知道现在只有一个？ 如何保证创建对象时候的原子性？（不能保证就有可能创建多于 1 个的对象） 如何获取/访问这个唯一对象？ 1. 基础概念 定义/意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 原理：让类自身保存它的唯一实例，并提供一个访问该实例的方法。实例的唯一性由类来保证。 类图： 类图 出场嘉宾 Singleton：单件类。 定义一个接口，允许客户访问唯一实例。此接口是一个类操作。 负责创建唯一实例。 2. 解决什么问题？如何解决？ 系统中，有些东西只需要一份就够了，因此要保证只有一份。 解决方法：只允许创建一个。但如何保证只有一个呢，见其他部分。 3. 优缺点是什么？ 3.1 优点 对唯一实例的创建是受控的——不允许直接创建（new 或变量）。 对唯一实例的访问是受控的。 缩小命名空间。 此模式是对全局变量的一种改进。 避免了存储唯一实例的全局变量污染命名空间。 （同一命名空间内，两个名字相同，就会冲突。） 允许对操作和表示的精化。【？！】 单件类可以有子类。 可以使用所需的拓展类在运行时配置应用。 允许可变的数目的实例。 比类操作更灵活。 如果使用类操作（C++ 的静态成员函数、Smalltalk 的类方法）的方式来封装单件功能，会使得改变设计以允许多个实例变得困难。 惰性 (lazy) 初始化，惰性创建——不需要的时候，不会创建。 3.2 缺点 4.</description></item><item><title>设计模式 —— 外观模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式——让接口更简单 外观模式：Facade /fəˈsɑːd/
目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：让接口更简单 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 使用外观模式 别名： 类图/结构： 类图 出场嘉宾 Facade：外观 知道哪些子系统负责处理哪些请求； 将客户请求代理给适当的子系统； Subsystem Classes：其他子系统类 实现子系统的功能； 处理由 Facede 指派的任务； 没有 Facade 的任何信息； 协作/工作流程 客户 -&amp;gt; Facade -&amp;gt; Subsystem 客户发送请求给 Facede； Facede 将请求适当转发到子系统； 子系统完成请求工作，返回请求结果给 Facede； Facede 返回请求结果给客户； 2. 解决什么问题？如何解决？ 降低系统间的通信和相互依赖关系。 3.</description></item><item><title>设计模式 —— 工厂方法模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法 工厂方法模式 (Factory Method Pattern) 又称为：
工厂模式； 虚拟构造器 (Virtual Constructor) 模式 多态工厂 (Polymorphic Factory) 模式 它属于类创建型模式。 1. 基础概念 定义/意图：
定义一个创建对象的接口，让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。 框架使用抽象类定义和维护对象之间的关系。 类图： 类图
出场嘉宾
产品/Product: 定义产品。 具体产品/Concrete Product: 定义具体的产品，继承自产品。 创建者/Creator：工厂；工厂的抽象类，声明工厂方法。 创建者可以定义一个默认的缺省实现，返回一个缺省的具体产品。 具体创建者/Concrete Creator: 具体工厂；继承自工厂，用于创建具体产品。 2. 解决什么问题？如何解决？ 3. 优缺点是什么？ 3.1 优点 【简单工厂的优点】 将创建对象的代码集中在一个对象或一个方法中，避免重复代码。 实例化对象时，依赖接口，不依赖具体类。【？！】 添加新产品时，不需修改旧代码，只需添加新的具体产品和具体创建者。 3.2 缺点 必须创建创建者的子类，无论用户想创建的具体产品是一个还是多个。（成对添加） 4.</description></item><item><title>设计模式 —— 抽象工厂模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>设计模式 Readme 模板 1. 基础概念 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
类图： 类图
出场嘉宾
AbstractFactory: 抽象工厂；声明具体工厂的接口——声明了一个创建抽象产品对象的接口。 ConcreteFactory: 具体工厂；继承自抽象工厂，实现了创建具体产品对象的操作。 AbstractProduct: 抽象产品；声明具体产品的接口——声明了一类产品对象的接口。 ConcreteProduct: 具体产品；继承自抽象产品，定义了一个将被具体工厂创建的产品对象，实现了抽象产品的接口， Client: 仅使用由抽象工厂和抽象产品类声明的接口——不使用具体工厂、具体产品的接口/方法。 工作方式：
运行时创建具体工厂对象，具体工厂对象创建具体产品对象。 客户使用不同的具体工厂对象，创建不同的具体产品对象。 抽象工厂将产品对象的创建延迟到具体工厂。 2. 解决什么问题？如何解决？ 需联合使用一系列产品的时候，可使用此模式 其他见【4.使用场景】 3. 优缺点是什么？ 3.1 优点 分离了具体的类： 工厂封装创建产品对象的过程，将客户和类的实现分离。客户通过抽象接口操纵实例。 具体产品的类名也在具体工厂的实现中被分离，它们不会出现在客户代码中。 易于交换产品系列： 一个具体工厂类在一个应用中仅出现一次——它初始化的时候； 改变具体工厂类即可改变产品配置——具体工厂类A换为具体工厂类B,则产品配置从 A 也更换到 B。 有利于产品的一致性：【？？？】 一个系列的产品对象被设计成一起工作的时候，一个应用一次只能使用同一个系列中的对象。【？？？】 3.</description></item><item><title>设计模式 —— 模板方法模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>模板方法模式——用继承改变算法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：定义一个操作的算法的骨架，将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 别名：无 类图： 类图 出场嘉宾 AbstrackClass：抽象类 定义抽象的原语操作(primitive operation)，各个步骤的具体实现交给子类。 实现一个模板方法，定义一个算法的步骤。 实现不变的部分。 ConcreteClass：具体类 实现原语操作，完成特定步骤的具体实现。 实现变动的部分。 协作/工作流程 AbstrackClass 实现不变的部分（或骨架）； ConcreteClass 实现变动的部分； AbstrackClass 和 ConcreteClass 实现整个操作/算法。 效果 模板方法是一种代码复用的基本技术。在类库中尤为重要。 模板方法导致一种反向的控制结构——&amp;ldquo;好莱坞原则&amp;rdquo;——即&amp;quot;别找我们，我们会找你&amp;quot;——父类调用子类的操作。 模板方法可能调用下列类型的操作： 具体的操作：ConcreteClass 或对客户类的操作。 具体的 AbstractClass 的操作：即通常对子类有用的操作。 原语操作：即抽象操作 工厂方法 钩子操作 (hook operation)：提供缺省的行为，子类可在必要时进行扩展。 2. 优缺点是什么？ 2.</description></item><item><title>设计模式 —— 状态模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid><description>状态 (State) 模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：允许一个对象再起内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 别名：状态对象 (Objects for States) 类图： 类图 出场嘉宾 Context: 上下文、环境 定义客户感兴趣的接口。 维护一个 ConcreteState 子类的实例，表示当前状态。 State：状态，抽象类/接口 定义一个接口，以封装与 Context 的特定状态相关的行为。 ConcreteState：具体状态 定义一个具体的状态，实现一个与 Context 的一个状态的相关的行为。 协作/工作流程 Context 保存一个 ConcreteState 对象，表示当前状态。 Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。 Context 可将自身作为一个参数传递给处理请求的状态对象。 Context 是客户使用的主要接口。 Context 和 ConcreteState 都可以决定哪一个状态是后继状态。 2.</description></item><item><title>设计模式 —— 策略模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid><description>策略模式——用委托改变算法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图： 定义一系列算法，把它们一个个封装起来，并使它们可以相互替换。 本模式使得算法可以独立于使用它的客户而变化。 别名：Policy（政策） 类图： 类图 出场嘉宾 Strategy：策略，定义算法的公共接口。 Context 使用这个接口来调用某个 ConcreteStrategy 定义的算法。 ConcreteStrategy：具体策略，实现具体的算法。 Context：上下文 用已成而 ConcreteStrategy 对象来配置；【？？？】 维护一个对 Strategy 对象的引用； 可定义一个接口来让 Strategy 访问它的数据。 协作/工作流程 Strategy 和 Context 相互作用，以实现选定的算法。 Context 将算法需要的参数传给 Strategy，或 Context 将自己作为参数传给 Strategy。 Context 将它的客户的请求转发给它的 Strategy。 客户通常创建并传递一个 ConcreteStrategy 对象给该 Context（客户仅与 Context 交互）。 客户通常可以选择一系列的 ConcreteStrategy。 2.</description></item><item><title>设计模式 —— 简单工厂模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>简单工厂模式 别称：静态工厂方法 简单工厂并不是一种模式，而是一种编程习惯。——《Head First 设计模式》 代码比较简单，就不写代码的 Readme 了 1. 基础概念 定义/意图：无 类图： 类图 出场嘉宾 产品/Product：产品，抽象类（或接口） 具体产品/Concrete Product：具体产品，继承/实现 Product 工厂/Creator：工厂，用于生产 Product 2. 解决什么问题？如何解决？ 无
3. 优缺点是什么？ 3.1 优点 把变化集中到一块，易于管理。 &amp;ldquo;消费对象&amp;quot;不需要直接创建具体产品 (Concrete Product)，把对象创建和使用分开。 3.2 缺点 工厂类集中了多个其他类，违反了高内聚责任分配原则。【？！】 有新的具体产品时，需要修改代码，不符合开闭原则。 随着具体产品增加，判断添加回变多，维护回变难。 这些缺点在工厂方法模式中得到解决。
4. 使用场景是什么？ 工厂类负责创建的对象固定、较小。（变动不频繁） 对创建对象的逻辑不关心。 5. 注意 由于简单工厂模式容易违反高内聚责任分配原则，因此一般只在较简单的情况下应用。 6. 应用实例？ 无 x. 疑问 y.</description></item><item><title>设计模式 —— 组合模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：将对象组合成树形结构以表示部分-整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 别名：Composite 类图 1： 类图 类图 2： 类图 典型对象图： 对象图 出场嘉宾 Component: 组合 为组合中的对象声明接口。 在适当情况下，实现公共接口的缺省行为。 声明一个接口用于访问和管理Component 组件。 Leaf: 叶节点，叶子部件 在组合中表示叶节点对象，叶节点没有子节点。 定义节点对象的具体的行为。 Composite: 组合部件，有孩子的部件。 定义有孩子节点的节点的行为。 存储孩子节点。 在 Component 接口中实现与子节点有关的操作。 Client： 通过 Component 接口操纵组合部件的对象。 协作/工作流程 Client 使用 Component 接口与组合结构中的对象 (Composite/Leaf) 进行交互。 如果接收者是叶节点，则直接处理请求。 如果接收者是 Composite，通常转发请求给它的子部件，在转发之前或之后，可能执行一些辅助操作。 2.</description></item><item><title>设计模式 —— 装饰者模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>装饰者模式——不改变接口，但加入责任 1. 基础概念 定义：动态地给一个对象添加一些额外的职责。
注意是针对对象而不是类 类图： 类图
出场嘉宾：
[基础]组件 (Conponent): 被装饰者，定义一个对象接口（Java：接口，C++：抽象类）； 具体[基础]组件 (Concrete Conponent): 定义一个具体的基础组件对象，可以给这个对象添加一些职责（装饰该对象）。 装饰者 (Decorator): 维持一个指向组件对象的指针，并定义一个与组件接口一致的接口。(指针是为了知道所修饰的是什么) 具体装饰者 (Concrete Decorator): 可以向具体组件添加职责（修饰）。 2. 解决什么问题？如何解决？ 解决用继承给对象添加功能不够灵活的问题。 通常拓展一个类都是用继承的方法，这是静态拓展，随着拓展增多，子类会膨胀。 解决方法：具体组件和修饰者都继承自公共的类，使一个对象能装饰另一个对象。 3. 优缺点是什么？ 3.1 优点 拓展功能时，提供比继承更有弹性的解决方案。（可增加、删除职责） 比静态继承更灵活。 可通过动态的方式在运行时选择不同的具体装饰类，实现不同的行为。 可以对一个对象进行多次修饰（甚至多次相同的修饰）。 符合开闭原则，具体组件和具体修饰者可以独立变化，用户根据需要添加组件或装饰者，原代码不需修改。 装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的 3.2 缺点 可能有许多小对象，排错难度加大、代码阅读难度加大。 可能不同的东西，继承自一个公共类。（个人理解） 4. 使用场景是什么？ 在不影响其他对象的情况下，已动态、透明的方式给单个对象添加职责。 处理那些可以撤销的职责。 怎么实现撤销？？？ 当不能使用子类/继承的方法进行扩充时。 情况一：类定义被隐藏，因此无法用于生成子类。 情况二：有大量独立的扩展，为支持每一种组合将产生大量子类。（使子类书目爆炸性增长） 5.</description></item><item><title>设计模式 —— 观察者模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>观察者模式 1. 基础概念 定义：定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 类图： 类图 出场嘉宾 主题 (Subject)：出版者、被观察者、 观察者 (Observer)：订阅者、 具体主题 (Concrete Subject): 对主题的实现 具体观察者 (Concrete Observer): 对观察者的实现 观察者模式就和报纸订阅/取消订阅、邮件订阅/取消订阅类似。 出版者（主题）+ 订阅者（观察者）=观察者模式
2. 解决什么问题？如何解决？ （易用、低耦合、高度协作）解决一个对象状态改变通知其他多个对象的问题。 3. 优缺点是什么？ 3.1 优点 支持一对多通信。 符合开闭原则。【疑问？？？】 在主题和观察者之间建立一个抽象的耦合。【抽象的耦合？？？】 3.2 缺点 当一个主题的观察者过多时，通知会比较耗费时间。 当 主题 和 观察者有循环依赖时，会导致循环调用。 观察者无法知道变化过程，只能知道变化结果。 4. 使用场景是什么？ 一个对象要通知其他[多个]对象自己改变时（可能并不知道这些对象是谁）； 一个对象要导致其他[多个]对象自己改变时； 需要创建触发链时； 5. 应用实例？ 天气预报服务器数据更新，客户端实时展示更新后的数据。（《Head First 设计模式》示例） 电子商务网站向多个用户推送商品信息。 x.</description></item><item><title>设计模式 —— 迭代器模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>迭代器模式——提供不暴露聚合对象内部表示的访问聚合对象各个元素的方法 目标： 初接触此模式时，熟悉最常用的使用方式。 有更深的理解后，再研究其他使用方法。 1. 基础概念 定义/意图：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露改对象的内部表示。 别名：游标（Cursor） 分类：对象行为型模式 类图： 类图 出场嘉宾 Iterator: 迭代器 定义访问和遍历元素的接口。 ConcreteIterator: 具体迭代器 实现对具体聚合对象的迭代器接口。 对聚合对象遍历时，跟踪当前位置。 Aggregate：聚合 定义创建相应迭代器对象的接口。 ConcreteAggregate：具体聚合 实现创建相应迭代器的接口 返回 ConcreteIterator 的一个适当实例。 协作/工作流程 通过 ConcreteAggregate 创建 ConcreteIterator； 通过 ConcreteIterator 访问/遍历 ConcreteAggregate。 2. 优缺点是什么？ 2.1 优点 支持以不同的方式遍历一个聚合。 复杂的聚合可用多种方式进行遍历。 迭代器简化了聚合的接口。 用了迭代器的遍历接口，聚合就不需要提供遍历接口，于是就简化了聚合的接口。 同一个聚合上可以有多个聚合。 每个迭代器保持自己的遍历状态，因此可以同时进行多个遍历。 2.</description></item><item><title>设计模式 —— 适配器模式</title><link>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Mar 2024 20:58:12 +0800</pubDate><guid>https://isshe.site/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式——将一个接口转换成另一个接口 目标： 初接触此模式时，熟悉最常用的使用方式。如，对象适配器。 有更深的理解后，再研究其他使用方法。如，类适配器和双向适配器 1. 基础概念 定义/意图： 将一个类的接口转换成另一个接口。适配器 (Adapter) 模式使得原来接口不兼容的类可以一起工作。 把一个东西，伪装成另一个东西！ 别名：包装器（Wrapper） 类图 1：类适配器类图（使用多重继承对一个接口与另一个接口进行匹配） 类图 类图 2：对象适配器类图 类图 出场嘉宾 Target: 定义 Client 使用的与特定领域相关的接口。 Client：与符合 Target 接口的对象协同。 Adaptee：已存在的接口，被适配者。 Adapter：对 Adaptee 接口与 Target 接口进行适配，适配器。 协作/工作流程 Client 在 Adapter 实例上调用一些操作。 Adapter 调用 Adaptee 的操作，以实现用户请求。 2. 解决什么问题？如何解决？ 在不改变原有 Target 和 Adaptee 代码情况下，对 Adaptee 用 Target 的方式访问。 解决方法：在两者之间添加一个中间层——Adapter。 3.</description></item></channel></rss>