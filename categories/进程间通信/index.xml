<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程间通信 on 树深时间录</title><link>https://isshe.site/categories/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><description>Recent content in 进程间通信 on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 16 Oct 2022 12:00:00 +0800</lastBuildDate><atom:link href="https://isshe.site/categories/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统 —— 进程间通信之 FIFO</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-fifo/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-fifo/</guid><description>FIFO FIFO 有时被称为命名管道。 FIFO 是一种文件类型。 支持在无亲缘进程间使用。 1. FIFO 创建 创建 FIFO 类似于创建文件；FIFO 的路径名存在于文件系统中。 2. 创建 FIFO 相关函数 #include &amp;lt;sys/stat.h&amp;gt;int mkfifo(const char *path, mode_t mode); // 在 fd 表示的目录相关位置，创建一个 FIFO。 // * path 为绝对路径，则忽略 fd // * path 为相对路径，则 fd 参数是一个打开的目录的文件描述符。路径名和目录有关【？？？】 // * path 为相对路径，并且 fd 参数有特殊值 AT_FDCWD，则路径名以当前目录开始。 int mkfifoat(int fd, const char *path, mode_t mode); 3. 其他 open 一个 FIFO 时，非阻塞标记 (O_NONBLOCK) 会产生的影响： 一般情况下 (没有指定 O_NONBLOCK)， 只读 open 要阻塞到其他进程为写打开此 FIFO 为止； 只写 open 要阻塞到其他进程为读打开此 FIFO 为止； 如果指定了 O_NONBLOCK，则： 只读 open 时，立即返回。【返回啥？正常返回？】 只写 open 时，如果没有其他进程为读打开此 FIFO，则此只写 open 返回 -1，errno 置为 ENXIO。 若 write 一个没有进程为读打开的 FIFO，则产生信号 SIGPIPE。（类似 pipe） 若 FIFO 的最后一个写进程关闭了该 FIFO，则将为改 FIFO 的读进程产生一个文件结束标记。（类似于 pipe） FIFO 的两种用途： shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件； 客户——服务器进程应用中，FIFO 用作汇聚点，在客户和服务器进程间传递数据； 4.</description></item><item><title>操作系统 —— 进程间通信之 Posix 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>Posix 信号量 信号量是一种提供不同进程间或一个进程的不同线程间同步手段的原语。 Posix 提供两类信号量：
有名 (named) 信号量 基于内存 (memory-base) 的信号量。【macOS 不支持】 Posix 信号量的函数调用 Posix 有名信号量至少具有岁内核的持续性。 Posix 信号量是计数信号量。 1.相关函数 #include &amp;lt;fcntl.h&amp;gt; /* For O_* constants */#include &amp;lt;sys/stat.h&amp;gt; /* For mode constants */#include &amp;lt;semaphore.h&amp;gt; // 打开 sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); // 关闭 int sem_close(sem_t *sem); // 删除 int sem_unlink(const char *name); // &amp;#34;加锁&amp;#34;——测试指定信号量的值，如果大于 0，将它 -1 int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // “解锁”——信号量 +1 int sem_post(sem_t *sem); // 获取信号量的值 (macOS 不支持) int sem_getvalue(sem_t *sem, int *sval); // 基于内存的信号量 (macOS 不支持) int sem_init(sem_t *sem, int shared, unsigned int value); int sem_destroy(sem_t *sem); A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 Posix.1 提供了两种无亲缘关系进程间共享内存区的方法：（都需要调用 mmap）
内存映射文件 (memory-mapped file)：由 open 函数打开，由 mmap 函数把得到的描述符映射到当前进程地址空间中的一个文件。 共享内存区对象 (share-memory object)：由 shm_open 打开一个 Posix.1 IPC 名字，所返回的描述符由 mmap 函数映射到当前进程的地址空间。 1. 相关函数 #include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 只是打开一个内存区对象，返回 fd // oflag: 必须函数 O_RDONLY、O_RDWR 中的一个。 // mode: // * 指定权限为，在指定了 O_CREAT 的前提下使用。 // * 与 mq_open 和 sem_open 不同，shm_open 的 mode 参数必须指定。 int shm_open(const char *name, int oflag, ...); // 删除一个共享内存区对象的名字。（删除一个名字不会影响低层支撑对象的现有引用。） int shm_unlink(const char *name); // 裁剪普通文件或者共享内存区对象 int ftruncate(int fd, off_t length); //获取打开的共享内存对象的信息 int fstat(int fildes, struct stat *buf); 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>Posix 信息队列 消息队列可认为是一个消息链表。具有随内核的持续性 有读权限的线程可以从队列中取走信息； 有写权限的线程可以从队列中放置信息； 允许异步事件通知。 1. 相关函数 #include &amp;lt;mqueue.h&amp;gt;// 打开消息队列 mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr */); // 关闭消息队列，调用进程不用，但不会被删除消息队列 int mq_close(mqd_t mqdes); // 从系统中删除消息队列 // mq_unlink(const char *name); // int mq_notify(mqd_t mqdes, const struct sigevent *notification); A. Posix 消息队列和 SystemV 消息队列的区别 Posix 消息队列的读总是返回最高优先级的最早消息；System V 消息队列的读可以返回任意指定优先级的消息。 往空队列放置一个消息时，Posix 消息队列允许产生一个信号或者启动一个线程。System V 没有类似的机制。</description></item><item><title>操作系统 —— 进程间通信之 SystemV 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>System V 信号量 1. 概述 二值信号量 (binary semaphore): 其值为 0 或 1 的信号量； 计数信号量 (counting semaphore): 其值为 0~某个限制值之间的信号量； 以上两种信号量，等待 (waiting) 操作都等待信号量的值变为大于 0； 计数信号量集 (set of counting semaphores): 一个或多个信号量 (构成一个集合), 其中的每个都是计数信号量。 System V 信号量通过此概念给信号量增加了一级复杂度。 当讨论 System V 信号量时，都是指计数信号量集；当讨论 Posix 信号量时，都是指计数信号量。
约定： semval: 信号量当前值 semncnt: 等待 semval 变为大于其当前值的线程数； semzcnt: 等待 semval 变为 0 的线程数； semadj: 所指定信号量针对调用进程的调整值；【？？？】 2.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>System V 共享内存区 1. 概述 System V 共享内存区在概念上类似于 Posix 共享内存区； Posix 共享内存区：先调用 shm_open，后调用 mmap; System V 共享内存区：先调用 shmget, 后调用 shmat; 2. shmget 函数 #include &amp;lt;sys/shm.h&amp;gt; int shmget(key_t key, size_t size, int shmflg); 作用：创建一个新的共享内存区或者访问一个已存在的共享内存区。 参数： key: ftok 的返回值或者 IPC_PRIVATE。 如果 key=IPC_PRIVATE 并且 shmflg 指定 IPC_CREAT 标记，则创建共享内存区。 如果没有 key 对应的共享内存标识符并且指定 IPC_CREAT，则创建共享内存区。 创建内存区会初始化内存区为 0。（size 字节） 创建共享内存区会分配shmid_ds结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation permissions */ int shm_segsz; /* size of segment in bytes */ pid_t shm_lpid; /* pid of last shm op */ pid_t shm_cpid; /* pid of creator */ short shm_nattch; /* # of current attaches */ time_t shm_atime; /* last shmat() time*/ time_t shm_dtime; /* last shmdt() time */ time_t shm_ctime; /* last change by shmctl() */ void *shm_internal; /* sysv stupidity */ }; size: 大小 shmflg：标记 返回：共享内存区标识符 (整数) 3.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 在新的应用程序中，不应再使用消息队列。【分布式系统里面，好像很常用！需要时再了解！】 详见此 Readme 2.4 节 若需要客户进程和服务器进程之间的双向数据流，用UNIX域套接字或全双工管道。 队列：消息队列。信息的链接表，存储在内核中，由标识符标识。 队列 ID：消息队列标识符。 与队列关联的数据结构：定义队列的当前状态 struct msqid_ds { struct ipc_perm msg_perm; msgqnum_t msg_qnum; // 队列里的消息长度/数量 msglen_t msg_qbytes; // 队列中能容纳的最大字节数 pid_t msg_lspid; // 最后 msgsnd() 的 pid pid_t msg_lrpid; // 最后 msgrcv() 的 pid time_t msg_stime; // 最后 msgsnd() 的时间 time_t msg_rtime; // 最后 msgrcv() 的时间 time_t msg_ctime; // 最后改变时间 } 1. 消息队列的系统限制 消息队列的系统限制</description></item><item><title>操作系统 —— 进程间通信之共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 共享内存区是可用 IPC 形式中最快的。 一旦内存区映射到共享它的进程的地址空间，这些进程间的数据传递就不需要经过内核了；但是读写内存区时，需要进行同步。 非共享缓冲区读文件传给另一个进程写：4 次内核与内核的交互 非共享缓冲区读文件传给另一个进程写 共享缓冲区读文件传给另一个进程写：2 次内核与进程的交互 共享缓冲区读文件传给另一个进程写 1. 相关函数 1.1 mmap mmap: 把一个文件或一个 Posix 共享内存区对象映射到调用进程的地址空间。 使用此函数有 3 个目的： 使用普通文件以提供内存映射 I/O； 使用特殊文件以提供匿名内存映射； 使用 shm_open 以提供无亲缘关系进程间的 Posix 共享内存区。 映射文件示意图： 映射文件示意图 #include &amp;lt;sys/mman.h&amp;gt; // addr: 指定 fd 映射到的进程内空间的起始地址； // len: 映射的长度——字节数； // offset: 从被映射文件开头起 offset 字节开始映射； // prot: 属性/模式 (PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE) // * PROT_NONE Pages may not be accessed.</description></item><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 16 Oct 2022 12:00:00 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定 PIPE_BUF 的值。 当管道的一端被关闭后，适用的规则：
当读 (read) 一个写端被关闭的管道，在所有数据被读取后，read 返回 0； 当写 (write) 一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write 返回 -1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.</description></item></channel></rss>