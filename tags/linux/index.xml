<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on 树深时间录</title><link>https://isshe.site/tags/linux/</link><description>Recent content in linux on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2024 21:06:54 +0800</lastBuildDate><atom:link href="https://isshe.site/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 内核 —— 中断</title><link>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</guid><description>中断 1. 硬件中断注册 #include &amp;lt;linux/interrupt.h&amp;gt; static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) 作用：申请一个中断线。 参数： irq: 中断线号 handler: 中断处理函数 flags: name: dev: 2. 硬件中断释放 #include &amp;lt;linux/interrupt.h&amp;gt; const void *free_irq(unsigned int irq, void *dev_id); 作用：释放一个中断线。如果没有其他设备注册该 IRQ 线，就关闭该 IRQ。 参数： irq: 中断线号。 dev_id: 设备标识。 3. 中断类型 网络设备常见的中断事件类型：
接收一帧：最常见、标准的情况。 传输失败； DMA 传输已成功完成； drivers/net/3c59x.</description></item><item><title>Linux 内核 —— 设备驱动</title><link>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid><description>设备驱动 NIC 可用之前，相关联的 net_device 数据结构必须先初始化，添加至内核网络设备数据库、配置并开启。 注册/注销/开启/关闭是四个不同的操作，不要混淆。 相关讨论，主要以网络设备为主。
设备注册 触发网络设备注册的情况：
加载 NIC 设备驱动程序：内建在内核，则引导期间初始化；模块形式，则在运行期间初始化。 例如，注册 PCI 设备驱动程序时，会导致pci_driver-&amp;gt;probe被调用。 插入可热插拔网络设备：内核通知其驱动程序，驱动程序注册该设备。 注册流程：以 ethernet 设备为例，流程都是一样，只是细节不同。 示例可见：drivers/net/ethernet/intel/e100.c
xxx_probe/module_init | |---&amp;gt;dev = alloc_etherdev(sizeof(driver_private_structure)) | | | +---&amp;gt; alloc_etherdev(sizeof_priv, &amp;#34;eth%d&amp;#34;, ether_setup) | | | |---&amp;gt; dev = kmalloc(sizeof(net_device)) + sizeof_prive + padding) | |---&amp;gt; ether_setup(dev) | |---&amp;gt; strcpy(dev-&amp;gt;name, &amp;#34;eth%d&amp;#34;) | +---&amp;gt; return(dev) | ... ... ... |---&amp;gt; netdev_boot_setup_check(dev) | ... ... ... +---&amp;gt; register_netdev(dev) | +---&amp;gt; register_netdevice(dev) 注销 触发网络设备注销的情况：</description></item><item><title>Linux 命令 —— gdb</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-gdb/</guid><description>gdb gdb - GNU 调试器。
调试器 (如 GDB) 的目的是允许你查看其他程序在执行时的&amp;quot;内部&amp;quot;的内容，或者程序奔溃的时候正在做什么。 GDB 可以做 4 种主要的事情来帮助你捕捉 bug：
启动你的程序，指定任何可能影响程序行为的内容。 使程序在指定条件下停止。 检查你程序停止时，正在发生的事情。 更改程序中的内容，以便你可以尝试纠正一个错误的影响并继续了解另一个错误。 你可以用 GDB 来调试 C、C++、Fortran、Modula-2 编写的程序。 使用gdb命令来调用 GDB。一旦启动，它会从中断读取命令，直到你用 GDB 命令&amp;quot;exit&amp;quot;告诉它退出。你可以用 GDB 命令help来查看帮助（不用退出 gdb）。 你可以运行没有参数或选项的 gdb ; 但是最常用的启动 GDB 的方法是使用一个或两个参数，将可执行程序指定为参数：
gdb program
您还可以从可执行程序和指定的 core 文件开始：
gdb program core
如果要调试正在运行的进程，则可以将进程 ID 指定为第二个参数：
gdb program 1234 gdb -p 1234
将 GDB 附加 (attach) 到 1234 进程（除非你由一个名字为 1234 的 core 文件，gdb 会先查找 core 文件）。 以下是一些常用的 GDB 命令：</description></item><item><title>Linux 命令 —— git</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-git/</guid><description>git submodule 添加 submodule： git submodule add &amp;lt;subproject URL&amp;gt; &amp;gt; git submodule add https://github.com/isshe/gitsubproject 查看 subproject 的 commit： git diff --cached &amp;lt;subproject dir&amp;gt; &amp;gt; git diff --cached gitsubproject/ 查看 subproject 的.gitmodules： git diff --cached --submodule 自动 clone 每个 submodule： git clone --recursive &amp;lt;your repository url&amp;gt; &amp;gt; git clone --recursive https://github.com/isshe/gitproject 拉取子模块： git submodule init git submodule update &amp;gt; 更常用的是：递归更新 git submodule update --init --recursive 子模块的后续更新：
git submodule update --remote 调整 submodule 的 commit： git pull origin xxx 切 submodule 的分支： git config -f .</description></item><item><title>Linux 命令 —— ip</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ip/</guid><description>ip 显示/操纵路由、设备、策略路由、隧道。
概要 ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics } OPTIONS := { -V[ersion] | -h[uman-readable] | -s[tatistics] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -n[etns] name | -a[ll] | -c[olor] } OBJECT:</description></item><item><title>Linux 命令 —— modprobe</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-modprobe/</guid><description>modprobe modprobe - 向 Linux 内核添加或从内核移除模块。
modprobe 智能地从 Linux 内核添加或删除模块：
注意，模块名称中-和_没有区别（自动执行下划线转换）。 modprobe 在模块目录/lib/modules/'uname -r'(符号冲突了，用'代替) 中查找所有模块和其他文件。 除了/etc/modprobe.d目录是的可选配置文件。详见modprobe.d modprobe 还将以&amp;lt;module&amp;gt;.&amp;lt;option&amp;gt;的形式使用内核命令行上指定的模块选项。 modprobe.blacklist=&amp;lt;module&amp;gt;的形式使用黑名单。 如果在 modulename 之后给出了任何参数，它们将被传递给内核。 除了配置文件中列出的选项。 用法 modprobe [-v] [-V] [-C config-file] [-n] [-i] [-q] [-b] [modulename] [module parameters...] modprobe [-r] [-v] [-n] [-i] [modulename...] modprobe [-c] modprobe [--dump-modversions] [filename] 选项 -a, --all 加载命令行中指定的所有模块。 -b, --use-blacklist 此选项使modprobe将配置文件（如果有）中的黑名单命令也应用于模块名称。 它通常由udev(7)使用。 -C, --config 此选项会覆盖缺省配置目录（/etc/modprobe.d） 此选项通过安装或删除命令传递给 MODPROBE_OPTIONS环境变量中 的其他modprobe命令。 -c, --showconfig 输出config目录中的有效配置并退出。 --dump-modversions 打印出模块所需的模块版本信息列表。 分发版通常使用此选项，以便使用模块版本控制deps(依赖？)打包Linux内核模块。 -d, --dirname 模块的根目录，默认是`/`。 --first-time 通常，如果告知插入已存在的模块或删除不存在的模块，modprobe将成功（并且不执行任何操作）。 这是简单脚本的理想选择; 然而，更复杂的脚本通常想知道modprobe是否真的做了一些事情： 这个选项使modprobe失败，因为它实际上没有做任何事情。 --force-vermagic 每个模块都包含一个包含重要信息的小字符串，例如内核和编译器版本。 如果模块无法加载并且内核抱怨`version magic`不匹配，则可以使用此选项将其删除(抱怨)。 当然，这个检查是为了保护你的，所以这个使用选项是危险的，除非你知道你在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 --force-modversion 当使用CONFIG_MODVERSIONS集编译模块时，会创建模块使用（或由模块提供）的每个接口的版本的详细说明。 如果模块无法加载并且内核抱怨模块不同意某个接口的版本，则可以使用“--force-modversion”来完全删除版本信息。 当然，这项检查是为了保护您的，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -f, --force 尝试从模块中删除任何可能阻止加载的版本信息：这与使用--force-vermagic和--force-modversion相同。 当然，这些检查是为了您的保护，所以使用此选项是危险的，除非您知道自己在做什么。 这适用于插入的任何模块：命令行上的模块（或别名）以及它所依赖的任何模块。 -i, --ignore-install, --ignore-remove 此选项使modprobe忽略命令行中，指定的模块的配置文件（如果有）中的安装和删除命令（任何相关模块仍然受配置文件中为它们设置的命令的限制）。 当使用此选项时，无论是否仅使用--ignore-install或--ignore-remove中的一个或其他（而不是两个）更具体地进行请求，将忽略安装和删除命令。 详见modprobe.</description></item><item><title>Linux 命令 —— netstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-netstat/</guid><description>netstat 显示当前的连接情况。（UDP、TCP、UNIX、ICMP 等） 显示路由表、网络接口列表、网络统计信息、多播信息、伪装连接等。
1. 介绍 1.1 用法 netstat [-vWeenNcCF] [&amp;lt;Af&amp;gt;] -r netstat {-V|--version|-h|--help} netstat [-vWnNcaeol] [&amp;lt;Socket&amp;gt; ...] netstat { [-vWeenNac] -i | [-cWnNe] -M | -s } 1.2 选项 -r, --route 显示路由表 -i, --interfaces 显示接口列表 -g, --groups 显示多播组成员 -s, --statistics 显示网络统计信息 -M, --masquerade display masqueraded connections【？？？】 -v, --verbose 详细 -W, --wide 不要截断IP地址 -n, --numeric 不要解析IP成域名（直接使用IP，不经过域名服务器） --numeric-hosts 不要解析主机名 --numeric-ports 不要解析端口名 --numeric-users 不要解析用户名 -N, --symbolic 解析硬件名 【？？？】 -e, --extend 显示更多信息 -p, --programs 显示进程ID和进程名 -c, --continuous 持续列出网络状态 -l, --listening 显示LISTENING状态的连接 -a, --all, --listening 显示所有连接(默认: 显示CONNECTED的连接) -o, --timers 显示计时器 【netstat -to】 -F, --fib 显示转发信息库（Forwarding Information Base），默认显示 -C, --cache 显示路由缓存(routing cache)而不是FIB -t, --tcp 显示TCP信息 -u, --udp 显示UDP信息 -w, --raw 实现raw信息 -x, --unix 显示unix信息 --ax25 显示AMPR AX.</description></item><item><title>Linux 命令 —— ssh</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-ssh/</guid><description>ssh 隧道 场景：家里内网机器 A 想要访问公司的内网机器 B。 条件：需要一个公网机器 C（假设 IP 是 1.1.1.1）。
打开公网机器的转发
在 B 上执行：
ssh -p 22 -NR 0.0.0.0:10443:0.0.0.0:443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：C 的信息 # 后面部分 0.0.0.0:443：B 的信息 注意：此时链接会一直保持，终端不会返回。
在 A 上执行： ssh -p 22 -NL 0.0.0.0:10443:0.0.0.0:10443 root@1.1.1.1 # 前面部分 0.0.0.0:10443：A 的信息 # 后面部分 0.0.0.0:10443：C 的信息 注意：此时链接会一直保持，终端不会返回。
此时，在 A 上通过 localhost:10443 即可访问 B 的 443。
端口映射 此方法相比上面的更为简化，直接把内网端口映射到外网设备上，直接访问外网设备映射的端口即可。
修改公网设备的 ssh 配置 sudo vi /etc/ssh/sshd_config # 设置 GatewayPorts yes # 重启 ssh 服务 sudo systemctl restart sshd 进行端口映射 在内网机器上：</description></item><item><title>Linux 命令 —— strace</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-strace/</guid><description>strace strace - 跟踪系统调用和信号。
在最简单的情况下，strace 运行指定的命令直到它退出。 它拦截并记录由进程调用的系统调用和进程接收的信号。 每个系统调用的名称，其参数和返回值都打印在标准错误或使用-o选项指定的文件上。 strace 是一种有用的诊断，指导和调试工具。 跟踪中的每一行都包含系统调用名称，后跟括号中的参数及其返回值。如：
open(&amp;#34;/dev/null&amp;#34;, O_RDONLY) = 3 系统调用错误，如：(返回 -1，并打印出错原因)
open(&amp;#34;/foo/bar&amp;#34;, O_RDONLY) = -1 ENOENT (No such file or directory) 信号，如：
sigsuspend([] &amp;lt;unfinished ...&amp;gt; --- SIGINT (Interrupt) --- +++ killed by SIGINT +++ 正在执行系统调用的同时，另一个线程/进程调用另一个系统调用，则 strace 将尝试保留这些事件的顺序并将正在进行的调用标记为未完成。 当调用返回时，它将被标记为已恢复：
[pid 28772] select(4, [3], NULL, NULL, NULL &amp;lt;unfinished ...&amp;gt; [pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0 [pid 28772] &amp;lt;... select resumed&amp;gt; ) = 1 (in [3]) 系统调用被中断后重启，如：</description></item><item><title>Linux 命令 —— tcpdump</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-tcpdump/</guid><description>tcpdump tcpdump - dump traffic on a network（转储网络上的流量）。
用法 tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ --number ] [ -Q in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,.</description></item><item><title>Linux 命令 —— vmstat</title><link>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/linux-%E5%91%BD%E4%BB%A4-vmstat/</guid><description>vmstat 报告虚拟内存统计信息：进程，内存，分页，块 IO，陷阱 (traps)、磁盘和 cpu 活动。
用法 vmstat [options] [delay [count]] vmstat [-f] [-s] [-m] vmstat [-S unit] vmstat [-d] vmstat [-p disk partition] vmstat [-V] 选项 delay 更新之间的延迟，以秒为单位。如果未指定延迟，则仅打印一个报告：自引导以来的平均值。 count 更新次数。如果未指定计数且指定了延迟(delay)，则count默认为无穷大。 -a, --active 显示活动和非活动内存（2.5.41及之后的版本） -f, --forks 显示自引导以来的fork数。 这包括fork，vfork和clone系统调用，并且是相当于创建的任务总数。 每个进程由一个或多个任务表示，具体取决于线程用法。此显示不重复（也就是只显示一次）。 -m, --slabs 显示slabinfo。【相关字段含义见下面部分】 -n, --one-header 标题仅显示一次而不是定期显示。 -s, --stats 显示各种事件计数器和内存统计信息。此显示不重复（也就是只显示一次）。 -d, --disk 报告磁盘信息（2.5.70及之后版本） -D, --disk-sum 报告一些有关磁盘活动的摘要统计信息。 -p, --partition device 分区的详细统计信息。 (2.5.70及之后版本). -S, --unit character 更换输出的单位：1000(k)，1024(K)，1000000(m)，1048576(M) 字节。 注意，这不会改变交换(si/so)或块(bi/bo)字段。 -t, --timestamp 为每一行附加时间戳。 -w, --wide 宽屏输出模式（对于具有较高内存量的系统非常有用，其中默认输出模式会受到不必要的列断裂影响）。 输出宽度会超过每行80个字符。 -V, --version 显示版本信息并退出。 -h, --help 显示帮助信息并退出。 字段描述 VM 模式字段描述 进程 r: 可运行进程的数量 (正在运行 + 就绪状态)。 b: 处于不可中断睡眠的进程数量。 内存 swpd: 使用的虚拟内存量。 free: 空闲内存量。(idle) buff: 用作缓冲区 (buffer) 的内存量。 cache: 用作缓存 (cache) 的内存量。 inact: 非活动内存量。（-a 选项） active: 活动内存量。（-a 选项） 交换内存 si: 从磁盘交换的内存量（/s）。 so: 交换到磁盘的内存量（/s）。 IO bi: 从块设备接收的块数（blocks/s）。 bo: 发送到块设备的块数（blocks/ s）。 系统 in: 每秒的中断数，包括时钟。 cs: 每秒上下文切换次数。 CPU 这些是总 CPU 时间的占比。 us: 运行非内核代码所花费的时间。 (用户时间，包括 nice 时间) sy: 运行内核代码所花费的时间。 (系统时间) id: 空闲时间。在 2.</description></item><item><title>操作系统 —— IO 多路复用之 epoll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</guid><description>epoll I/O 事件通知设施 (I/O event notification facility)。
1. epoll_create #include &amp;lt;sys/epoll.h&amp;gt; int epoll_create(int size); int epoll_create1(int flags); 作用：打开一个 epoll 文件描述符。 参数： size：Linux 2.6.8 后不再使用，但是必须大于 0。 flags： 0：和 epoll_create 行为一样。 O_CLOEXEC: 进程退出时关闭文件描述符。 返回： 失败：-1，设置 errno；否则： 返回一个指向一个新 epoll 实例的文件描述符；当不再使用此描述符时，应使用 close 关闭。 当所有指向此 epoll 实例的描述符都被关闭时，内核会释放相关资源。 2. epoll_ctl typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 作用：epoll 文件描述符的控制接口。 参数： epfd: epoll fd，epoll 文件描述符； op: EPOLL_CTL_ADD：注册 fd 到 epfd； EPOLL_CTL_MOD：修改与 fd 的关联 evnet 事件。 EPOLL_CTL_DEL：从 epfd 中删除 fd； fd: 要操作 (op) 的 fd； event: 与 fd 关联的事件。EPOLL_CTL_DEL 时这个参数被忽略，也可以直接为 NULL； 返回： 正常：0； 异常：-1，设置 errno； 数据结构说明； struct epoll_event的events的是位掩码的形式，取值是： EPOLLIN: 相关文件可读。(read) EPOLLOUT: 相关文件可写。(write) EPOLLRDHUP: 流套接字对端关闭连接，或关闭写入一半的连接。(在使用边沿触发时，此标志对于编写简单代码以检测对端关闭特别有用。) EPOLLPRI: 有紧急数据可读。 EPOLLERR: 相关文件描述符发生错误。（默认设置，不用手动设置） EPOLLHUP: 相关文件描述符被挂起。（默认设置，不用手动设置） EPOLLET: 相关文件描述符设置为边缘触发。（默认是水平触发） EPOLLONESHOT: 对相关描述符设置一次性行为。epoll_wait 一次后，不会再 wait，除非使用 EPOLL_CTL_MOD 重新设置。 EPOLLWAKEUP: 设置此标记，使事件排队时系统保持唤醒。 当系统设置了自动休眠模式 (/sys/power/autosleep) 时，为了保持设备唤醒直到事件处理完成，必须使用此标记。 EPOLLEXCLUSIVE：为附加到目标文件描述符 fd 的 epoll 文件描述符设置独占唤醒模式。【？？？】 3.</description></item><item><title>操作系统 —— IO 多路复用之 poll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</guid><description>poll 相关函数 #include &amp;lt;poll.h&amp;gt; struct pollfd { int fd; /* file descriptor */ short events; /* events to look for */ short revents; /* events returned */ }; int poll(struct pollfd fds[], nfds_t nfds, int timeout); 作用：类似于 select。（指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。） 参数： fds[]: 指向一个结构数组第一个元素的指针。 nfds: 指定 fds 中的元素个数。 timeout: INFTIM：永远等待；(INFTIM 被定义为一个负值) 0：立即返回； &amp;gt; 0: 等待指定数据的毫秒数。 返回： 成功：就绪描述符数目 超时：0 出错：-1 数据结构说明： events: 要测试的条件； revents: 返回描述符的状态。 events/revents标记： 常值 说明 能作为 evnets 的输入吗？ 能作为 revents 的输入吗？ POLLIN 普通或优先级带数据可读 + + POLLRDNORM 普通数据可读 + + POLLRDBAND 优先级带数据可读 + + POLLPRI 高优先级数据可读 + + POLLOUT 普通数据可写 + + POLLWRNORM 普通数据可写 + + POLLWRBAND 优先级带数据可写 + + POLLERR 发生错误 + POLLHUP 发生挂起 + POLLNVAL 描述符不是一个打开的文件 + 数据分类 poll 识别三类数据：普通 (normal)、优先级带 (priority band)、高优先级 (high priority)</description></item><item><title>操作系统 —— IO 多路复用之 select</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</guid><description>select select 函数允许进程指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。
1. select #include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); 作用：指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。 参数： nfds: 待测试的最大描述符 +1； readfds: 监听读的 fd 集合； writefds: 监听写得 fd 集合； errorfds: 监听异常的 fd 集合； timeout: 等待超时时间。 NULL: 永远等下去； 非 NULL 且不为值 0: 等待指定时间； 非 NULL 且值为 0: 不等待，检查描述符后立即返回。（轮询） 返回： 返回： 成功：就绪描述符数目 超时：0 出错：-1 2.</description></item><item><title>操作系统 —— 信号</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</guid><description>信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为： 1.信号发送和信号接收 待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix 系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数： #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;signal.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 发送 sig 指定信号到 pid 进程 int kill(pid_t pid, int sig); // 向自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题 待处理信号被阻塞。
例如：一个进程捕获一个信号 SIGINT 然后去处理程序处理信号，此时又来一个 SIGINT 信号，此信号会被阻塞。[疑问][1] （第 2 个信号不是 SIGINT 信号，那是否也还是阻塞？） 待处理信号不会排队等待。
任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？） 系统调用可以被中断。</description></item><item><title>操作系统 —— 线程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</guid><description>线程 当一个程序由 exec 启动执行时，系统将创建一个称为初始线程(initail thread)或主线程(main thread)的单个线程。 线程取消在8.5章，被取消的线程要释放相关资源（锁等），需要注意。 线程创建可能比进程创建快 10~100 倍； 线程或者是可汇合的(joinable)或者是脱离/分离的(detached)。（默认可汇合的） 可汇合的线程可以被其他线程回收其资源和杀死。 当可汇合的线程终止时，其线程 ID 和退出状态将保留，直到另一个线程调用 pthread_join; 脱离的线程则像守护进程：终止时，所有资源都释放，因此不能等待它终止； 线程是运行在进程上下文中的逻辑流。 1. 共享及私有 线程共享的内容：
进程指令； 大多数数据； 打开的文件（如描述符）； 信号处理程序和信号处置； 当前工作目录； 用户 ID 和组 ID； 线程私有的内容： 线程 ID； 寄存器集合（包括程序计数器和栈指针）； 栈； 栈指针； 程序计数器； errno； 信号掩码； 优先级； 2. 相关函数 2.1 pthread_create #include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); 作用：创建线程 参数： tid：线程 ID；这是结果参数； attr: 线程属性，如优先级、初始栈大小、是否是一个守护线程等；通常采用默认值； start_routine: 创建的线程所需要执行的函数；称为线程启动函数(thread start function); arg: 参数；如果有多个，则打包成一个结构即可； 返回： 成功：0 失败：Exxx 值 2.</description></item><item><title>操作系统 —— 进程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程是操作系统中最核心的概念。
定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。 逻辑流(逻辑控制流）：程序计数器 PC 值的序列。 异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。 并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发 (concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。 1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程； 1.进程地址空间 1.1 典型进程地址空间 1 典型进程地址空间 1
代码段起始地址： 32 位：0x08048000 64 位：0x00400000 进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。 1.2 典型进程地址空间 2 典型进程地址空间 2
2. 进程状态 2.1 状态转换图 状态转换图 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>Posix 信号量 信号量是一种提供不同进程间或一个进程的不同线程间同步手段的原语。 Posix 提供两类信号量：
有名 (named) 信号量 基于内存 (memory-base) 的信号量。【macOS 不支持】 Posix 信号量的函数调用 Posix 有名信号量至少具有岁内核的持续性。 Posix 信号量是计数信号量。 1.相关函数 #include &amp;lt;fcntl.h&amp;gt; /* For O_* constants */#include &amp;lt;sys/stat.h&amp;gt; /* For mode constants */#include &amp;lt;semaphore.h&amp;gt; // 打开 sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); // 关闭 int sem_close(sem_t *sem); // 删除 int sem_unlink(const char *name); // &amp;#34;加锁&amp;#34;——测试指定信号量的值，如果大于 0，将它 -1 int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // “解锁”——信号量 +1 int sem_post(sem_t *sem); // 获取信号量的值 (macOS 不支持) int sem_getvalue(sem_t *sem, int *sval); // 基于内存的信号量 (macOS 不支持) int sem_init(sem_t *sem, int shared, unsigned int value); int sem_destroy(sem_t *sem); A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 Posix.1 提供了两种无亲缘关系进程间共享内存区的方法：（都需要调用 mmap）
内存映射文件 (memory-mapped file)：由 open 函数打开，由 mmap 函数把得到的描述符映射到当前进程地址空间中的一个文件。 共享内存区对象 (share-memory object)：由 shm_open 打开一个 Posix.1 IPC 名字，所返回的描述符由 mmap 函数映射到当前进程的地址空间。 1. 相关函数 #include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 只是打开一个内存区对象，返回 fd // oflag: 必须函数 O_RDONLY、O_RDWR 中的一个。 // mode: // * 指定权限为，在指定了 O_CREAT 的前提下使用。 // * 与 mq_open 和 sem_open 不同，shm_open 的 mode 参数必须指定。 int shm_open(const char *name, int oflag, ...); // 删除一个共享内存区对象的名字。（删除一个名字不会影响低层支撑对象的现有引用。） int shm_unlink(const char *name); // 裁剪普通文件或者共享内存区对象 int ftruncate(int fd, off_t length); //获取打开的共享内存对象的信息 int fstat(int fildes, struct stat *buf); 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>Posix 信息队列 消息队列可认为是一个消息链表。具有随内核的持续性 有读权限的线程可以从队列中取走信息； 有写权限的线程可以从队列中放置信息； 允许异步事件通知。 1. 相关函数 #include &amp;lt;mqueue.h&amp;gt;// 打开消息队列 mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr */); // 关闭消息队列，调用进程不用，但不会被删除消息队列 int mq_close(mqd_t mqdes); // 从系统中删除消息队列 // mq_unlink(const char *name); // int mq_notify(mqd_t mqdes, const struct sigevent *notification); A. Posix 消息队列和 SystemV 消息队列的区别 Posix 消息队列的读总是返回最高优先级的最早消息；System V 消息队列的读可以返回任意指定优先级的消息。 往空队列放置一个消息时，Posix 消息队列允许产生一个信号或者启动一个线程。System V 没有类似的机制。</description></item><item><title>操作系统 —— 进程间通信之 SystemV 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>System V 信号量 1. 概述 二值信号量 (binary semaphore): 其值为 0 或 1 的信号量； 计数信号量 (counting semaphore): 其值为 0~某个限制值之间的信号量； 以上两种信号量，等待 (waiting) 操作都等待信号量的值变为大于 0； 计数信号量集 (set of counting semaphores): 一个或多个信号量 (构成一个集合), 其中的每个都是计数信号量。 System V 信号量通过此概念给信号量增加了一级复杂度。 当讨论 System V 信号量时，都是指计数信号量集；当讨论 Posix 信号量时，都是指计数信号量。
约定： semval: 信号量当前值 semncnt: 等待 semval 变为大于其当前值的线程数； semzcnt: 等待 semval 变为 0 的线程数； semadj: 所指定信号量针对调用进程的调整值；【？？？】 2.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>System V 共享内存区 1. 概述 System V 共享内存区在概念上类似于 Posix 共享内存区； Posix 共享内存区：先调用 shm_open，后调用 mmap; System V 共享内存区：先调用 shmget, 后调用 shmat; 2. shmget 函数 #include &amp;lt;sys/shm.h&amp;gt; int shmget(key_t key, size_t size, int shmflg); 作用：创建一个新的共享内存区或者访问一个已存在的共享内存区。 参数： key: ftok 的返回值或者 IPC_PRIVATE。 如果 key=IPC_PRIVATE 并且 shmflg 指定 IPC_CREAT 标记，则创建共享内存区。 如果没有 key 对应的共享内存标识符并且指定 IPC_CREAT，则创建共享内存区。 创建内存区会初始化内存区为 0。（size 字节） 创建共享内存区会分配shmid_ds结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation permissions */ int shm_segsz; /* size of segment in bytes */ pid_t shm_lpid; /* pid of last shm op */ pid_t shm_cpid; /* pid of creator */ short shm_nattch; /* # of current attaches */ time_t shm_atime; /* last shmat() time*/ time_t shm_dtime; /* last shmdt() time */ time_t shm_ctime; /* last change by shmctl() */ void *shm_internal; /* sysv stupidity */ }; size: 大小 shmflg：标记 返回：共享内存区标识符 (整数) 3.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 在新的应用程序中，不应再使用消息队列。【分布式系统里面，好像很常用！需要时再了解！】 详见此 Readme 2.4 节 若需要客户进程和服务器进程之间的双向数据流，用UNIX域套接字或全双工管道。 队列：消息队列。信息的链接表，存储在内核中，由标识符标识。 队列 ID：消息队列标识符。 与队列关联的数据结构：定义队列的当前状态 struct msqid_ds { struct ipc_perm msg_perm; msgqnum_t msg_qnum; // 队列里的消息长度/数量 msglen_t msg_qbytes; // 队列中能容纳的最大字节数 pid_t msg_lspid; // 最后 msgsnd() 的 pid pid_t msg_lrpid; // 最后 msgrcv() 的 pid time_t msg_stime; // 最后 msgsnd() 的时间 time_t msg_rtime; // 最后 msgrcv() 的时间 time_t msg_ctime; // 最后改变时间 } 1. 消息队列的系统限制 消息队列的系统限制</description></item><item><title>操作系统 —— 进程间通信之FIFO</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</guid><description>FIFO FIFO 有时被称为命名管道。 FIFO 是一种文件类型。 支持在无亲缘进程间使用。 1. FIFO 创建 创建 FIFO 类似于创建文件；FIFO 的路径名存在于文件系统中。 2. 创建 FIFO 相关函数 #include &amp;lt;sys/stat.h&amp;gt;int mkfifo(const char *path, mode_t mode); // 在 fd 表示的目录相关位置，创建一个 FIFO。 // * path 为绝对路径，则忽略 fd // * path 为相对路径，则 fd 参数是一个打开的目录的文件描述符。路径名和目录有关【？？？】 // * path 为相对路径，并且 fd 参数有特殊值 AT_FDCWD，则路径名以当前目录开始。 int mkfifoat(int fd, const char *path, mode_t mode); 3. 其他 open 一个 FIFO 时，非阻塞标记 (O_NONBLOCK) 会产生的影响： 一般情况下 (没有指定 O_NONBLOCK)， 只读 open 要阻塞到其他进程为写打开此 FIFO 为止； 只写 open 要阻塞到其他进程为读打开此 FIFO 为止； 如果指定了 O_NONBLOCK，则： 只读 open 时，立即返回。【返回啥？正常返回？】 只写 open 时，如果没有其他进程为读打开此 FIFO，则此只写 open 返回 -1，errno 置为 ENXIO。 若 write 一个没有进程为读打开的 FIFO，则产生信号 SIGPIPE。（类似 pipe） 若 FIFO 的最后一个写进程关闭了该 FIFO，则将为改 FIFO 的读进程产生一个文件结束标记。（类似于 pipe） FIFO 的两种用途： shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件； 客户——服务器进程应用中，FIFO 用作汇聚点，在客户和服务器进程间传递数据； 4.</description></item><item><title>操作系统 —— 进程间通信之共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 共享内存区是可用 IPC 形式中最快的。 一旦内存区映射到共享它的进程的地址空间，这些进程间的数据传递就不需要经过内核了；但是读写内存区时，需要进行同步。 非共享缓冲区读文件传给另一个进程写：4 次内核与内核的交互 非共享缓冲区读文件传给另一个进程写 共享缓冲区读文件传给另一个进程写：2 次内核与进程的交互 共享缓冲区读文件传给另一个进程写 1. 相关函数 1.1 mmap mmap: 把一个文件或一个 Posix 共享内存区对象映射到调用进程的地址空间。 使用此函数有 3 个目的： 使用普通文件以提供内存映射 I/O； 使用特殊文件以提供匿名内存映射； 使用 shm_open 以提供无亲缘关系进程间的 Posix 共享内存区。 映射文件示意图： 映射文件示意图 #include &amp;lt;sys/mman.h&amp;gt; // addr: 指定 fd 映射到的进程内空间的起始地址； // len: 映射的长度——字节数； // offset: 从被映射文件开头起 offset 字节开始映射； // prot: 属性/模式 (PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE) // * PROT_NONE Pages may not be accessed.</description></item><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定 PIPE_BUF 的值。 当管道的一端被关闭后，适用的规则：
当读 (read) 一个写端被关闭的管道，在所有数据被读取后，read 返回 0； 当写 (write) 一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write 返回 -1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.</description></item><item><title>操作系统 —— 进线程同步之互斥锁、条件变量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>互斥锁与条件变量 互斥锁及条件变量是同步的基本组成部分。 互斥锁及条件变量出自Posix.1线程标准； 可以用来同步一个进程内的各个线程； 也可以用在进程间同步：互斥锁放在多个进程的共享内存区中。 1.互斥锁 互斥锁：相互排斥，是最基本的同步形式。 作用：保护临界区（critical region）。 保护的是数据：临界区中被操纵的数据；进程/线程共享的数据。 互斥锁是协作性锁，也就是锁无法防止一些进程/线程不先获取锁就访问数据。（需要靠自觉） 1.1 相关函数 静态分配使用PTHREAD_MUTEX_INITIALIZER进行初始化 #include &amp;lt;pthread.h&amp;gt; // 互斥锁初始化、销毁 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); // 上锁、解锁 int pthread_mutex_lock(pthread_mutex_t *mptr); int pthread_mutex_trylock(pthread_mutex_t *mptr); int pthread_mutex_unlock(pthread_mutex_t *mptr); // 属性初始化、销毁 int pthread_mutexattr_init(pthread_mutexattr_t *attr); int pthread_mutexattr_destroy(pthread_mutexattr_t *attr) // 属性设置：进程间共享等（MACOS 和 LINUX 相关函数有所不同） // 均返回：成功：0，失败：正的 Exxx 值 2. 条件变量 互斥锁用于上锁，条件变量用于等待。 每个条件变量总是与一个互斥锁相关联。 2.</description></item><item><title>操作系统 —— 进线程同步之读写锁</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 1. 什么是读写锁 互斥锁把试图进入临界区的 (多余) 线程都阻塞住，无论是读还是写。（不区分读写） 独占锁。 读写锁区分读和写，同时只能一个线程写 (写时不能读)；允许同时多个线程读 (读时没有写)。 读为共享锁，写为独占锁。 读比写更频繁的应用中，用读写锁更好。 2. 读写锁的分配规则 只要没有线程持有读写锁用于写，任意数目的线程可以持有该读写锁用于读。 仅当没有线程持有读写锁时 (用于读或写)，才能分配读写锁用于写。 3. 相关函数 静态分配用PTHREAD_RWLOCK_INITIALIZER进行初始化。 #include &amp;lt;pthread.h&amp;gt; // 初始化、销毁 int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy(pthread_rwlock_t *lock); // 加锁、解锁 int pthread_rwlock_rdlock(pthread_rwlock_t *lock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock); int pthread_rwlock_wrlock(pthread_rwlock_t *lock); int pthread_rwlock_trywrlock(pthread_rwlock_t *lock); int pthread_rwlock_unlock(pthread_rwlock_t *lock); // 属性初始化、销毁 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); // 属性设置：设置进程间共享：PTHREAD_PROCESS_SHARED/PTHREAD_PROCESS_PRIVATE int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);</description></item></channel></rss>