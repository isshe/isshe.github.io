<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rwlock on 树深时间录</title><link>https://isshe.site/tags/rwlock/</link><description>Recent content in rwlock on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 14 Dec 2021 03:14:49 -0400</lastBuildDate><atom:link href="https://isshe.site/tags/rwlock/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统 —— 进线程同步之读写锁</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Tue, 14 Dec 2021 03:14:49 -0400</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 1. 什么是读写锁 互斥锁把试图进入临界区的(多余)线程都阻塞住，无论是读还是写。（不区分读写） 独占锁。 读写锁区分读和写，同时只能一个线程写(写时不能读)；允许同时多个线程读(读时没有写)。 读为共享锁，写为独占锁。 读比写更频繁的应用中，用读写锁更好。 2. 读写锁的分配规则 只要没有线程持有读写锁用于写，任意数目的线程可以持有该读写锁用于读。 仅当没有线程持有读写锁时(用于读或写)，才能分配读写锁用于写。 3. 相关函数 静态分配用PTHREAD_RWLOCK_INITIALIZER进行初始化。 #include &amp;lt;pthread.h&amp;gt; // 初始化、销毁 int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy(pthread_rwlock_t *lock); // 加锁、解锁 int pthread_rwlock_rdlock(pthread_rwlock_t *lock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock); int pthread_rwlock_wrlock(pthread_rwlock_t *lock); int pthread_rwlock_trywrlock(pthread_rwlock_t *lock); int pthread_rwlock_unlock(pthread_rwlock_t *lock); // 属性初始化、销毁 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); // 属性设置：设置进程间共享: PTHREAD_PROCESS_SHARED/PTHREAD_PROCESS_PRIVATE int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);</description></item></channel></rss>