<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pipe on 树深时间录</title><link>https://isshe.site/tags/pipe/</link><description>Recent content in pipe on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2024 21:06:54 +0800</lastBuildDate><atom:link href="https://isshe.site/tags/pipe/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定 PIPE_BUF 的值。 当管道的一端被关闭后，适用的规则：
当读 (read) 一个写端被关闭的管道，在所有数据被读取后，read 返回 0； 当写 (write) 一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write 返回 -1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.</description></item></channel></rss>