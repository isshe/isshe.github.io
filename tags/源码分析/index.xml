<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on 树深时间录</title><link>https://isshe.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 16 May 2023 13:38:34 -0300</lastBuildDate><atom:link href="https://isshe.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenResty 核心技术点</title><link>https://isshe.site/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/</link><pubDate>Tue, 16 May 2023 13:38:34 -0300</pubDate><guid>https://isshe.site/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/</guid><description>OpenResty 核心技术点 本文档用于汇总学习过程中遇到的核心技术点。 记录逻辑：假设相关功能没有实现，简要描述重新实现的要点。
TODO: 补充以下相关的
lua 堆栈解读（或许应该放到 Luajit 那边去） Lua 接口/数据(变量)注入 有些函数不需要 require 都能进行使用，这是因为 OpenResty 自动进行了相关工作。
在初始化 Lua 虚拟机时，进行 Lua 接口注入。 采用表（table）的形式进行组织 —— lua_createtable。 创建一个表，然后设置键值对，把 key（如 &amp;ldquo;get&amp;rdquo;） 和 C 函数（lua_pushcfunction）或值(lua_pushinteger 等)进行绑定。 各个协程可以设置各自独立的全局表。 cosocket 基于 Lua 协程和 Nginx 的事件模型以及异步 I/O：Lua 接口调用 cosocket 相关函数时，底层的 listen、send 等接口采用非阻塞的方式，使这些调用立即返回。根据返回的状态，设置并监听相关读写事件，然后 yield 让出当前 Lua 协程的执行权，继续执行其他协程。当等待的事件发生后，事件处理函数 resume 唤醒对应的协程，继续执行。 详见 OpenResty cosocket。
Pipe 设计要点 开 2 或 3 个 pipe，分别用于 stdin/stdout/stderr —— 把标准输入、输出、错误重定向到这些 pipe 的 fd。 使用 exec 系列函数来执行命令 读或写数据(命令输入或命令输出)时，先进行一次读写，如果无法一次完成，则设置对应的读写事件，然后 yield 让出执行权；后续通过事件模块 resume 获取执行权。 详见 OpenResty Pipe。</description></item><item><title>OpenResty 线程</title><link>https://isshe.site/p/openresty-%E7%BA%BF%E7%A8%8B/</link><pubDate>Tue, 16 May 2023 13:38:34 -0300</pubDate><guid>https://isshe.site/p/openresty-%E7%BA%BF%E7%A8%8B/</guid><description>OpenResty 协程/线程 后续都称为协程。
通过前面的探索可以看出，ngx_http_lua_run_thread 是相当重要的一个函数，对于协程的调度，都是通过此接口进行。
目的：
了解 OpenResty 协程是什么？ 是否和此函数强关联：ngx_http_lua_run_thread？ OpenResty 的协程与 Luajit 的协程是什么关系？ OpenResty 协程是如何创建的？是何时创建的？（排除前面探究过的轻线程和 coroutine 接口） OpenResty 协程会在何时执行？（排除前面探究过的轻线程和 coroutine 接口） 主协程和其他协程是如何区分的？ Lua VM 和主协程是什么关系？ 这里描述的协程与前面章节中描述的 coroutine 什么关系？ 使用 不涉及
实现 协程的状态 typedef enum { NGX_HTTP_LUA_CO_RUNNING = 0, /* coroutine running */ NGX_HTTP_LUA_CO_SUSPENDED = 1, /* coroutine suspended */ NGX_HTTP_LUA_CO_NORMAL = 2, /* coroutine normal */ NGX_HTTP_LUA_CO_DEAD = 3, /* coroutine dead */ NGX_HTTP_LUA_CO_ZOMBIE = 4, /* coroutine zombie */ } ngx_http_lua_co_status_t; NGX_HTTP_LUA_CO_RUNNING：当前协程正在执行 NGX_HTTP_LUA_CO_SUSPENDED：当前协程已挂起，等待恢复 NGX_HTTP_LUA_CO_NORMAL：正常 NGX_HTTP_LUA_CO_DEAD：协程死亡/终止了 NGX_HTTP_LUA_CO_ZOMBIE：是僵尸协程，等待父协程回收 新建协程：ngx_http_lua_new_thread - ngx_http_lua_new_thread \- ngx_http_get_module_main_conf：获取模块配置 \- if (L == lmcf-&amp;gt;lua &amp;amp;&amp;amp; !</description></item><item><title>OpenResty cosocket</title><link>https://isshe.site/p/openresty-cosocket/</link><pubDate>Thu, 04 May 2023 06:00:05 -0300</pubDate><guid>https://isshe.site/p/openresty-cosocket/</guid><description>OpenResty cosocket 使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？
目的：
学习如何使用 cosocket。 cosocket 是什么？ cosocket 的实现方式、原理是什么？ 使用 ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。
以下接口的上下文皆是：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*。
ngx.socket.tcp 语法：tcpsock = ngx.socket.tcp()
作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。
注意：
此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以永远不要将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也永远不要在不同的 Nginx 请求之间共享 cosocket 对象。 如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭： 当前请求处理程序（handler）执行完成 Lua cosocket 对象被 Lua GC 回收 发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。 tcpsock:bind 此接口需要更新的版本，v0.</description></item><item><title>OpenResty Lua VM 初始化</title><link>https://isshe.site/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Thu, 04 May 2023 06:00:05 -0300</pubDate><guid>https://isshe.site/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>Lua VM 初始化 上一篇关于 ngx.log 文章中，跟踪相关代码时思路几近断裂，因此赶紧来补补 Lua VM 初始化相关内容。
目的：
Lua VM 初始化的时机？（什么时候初始化） 了解 Lua VM 初始化做了哪些工作？为什么这么做（选）？ Lua 虚拟机是共用一个？还是每次调用 Lua 代码起一个？ 注入的接口和 _G 是什么关系？这些接口也在 _G 中吗？ Lua VM 初始化时机 从上一篇文章中，我们已经拿过一个 Lua VM 初始化相关的堆栈，这里截取一部分：
#4 0x000055555570b955 in ngx_http_lua_init_vm (new_vm=0x555555891080, parent_vm=0x0, cycle=0x555555885740, pool=0x5555558856f0, lmcf=0x555555891080, log=0x55555583d280 &amp;lt;ngx_log&amp;gt;, pcln=0x0) at ../ngx_lua-0.10.21/src/ngx_http_lua_util.c:3896 #5 0x00005555556fb450 in ngx_http_lua_init (cf=0x7fffffffd7e0) at ../ngx_lua-0.10.21/src/ngx_http_lua_module.c:865 #6 0x00005555555f4ddc in ngx_http_block (cf=0x7fffffffd7e0, cmd=0x55555581a200 &amp;lt;ngx_http_commands&amp;gt;, conf=0x555555886a20) at src/http/ngx_http.c:310 #7 0x00005555555b9ec7 in ngx_conf_handler (cf=0x7fffffffd7e0, last=1) at src/core/ngx_conf_file.</description></item><item><title>OpenResty 信号量</title><link>https://isshe.site/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Thu, 04 May 2023 06:00:05 -0300</pubDate><guid>https://isshe.site/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>轻线程信号量 和 Linux 系统或者 Nginx 中的信号量类似，都是用于进程/协程同步。当值小于 0 时，表示需要等待资源。 不过 Nginx 中的信号量是会导致进程在等待资源时休眠的，OpenResty 的信号量（后续简称信号量）是不是也是一样呢？我们来探究一番。
目的：
如何使用信号量？ 信号量是如何实现的？ 信号量是否会导致如进程休眠之类的问题？ 不同进程的协程是否能使用信号量？ 使用 Lua 接口的使用都比较简单，我们直接通过一个示例来说明。
-- 引入 ngx.semaphore 模块 local semaphore = require &amp;#34;ngx.semaphore&amp;#34; -- 新建一个 semaphore 对象 -- 此时默认资源是 0 个 -- 也可以传递参数指定信号量初始有多少资源 local sema = semaphore.new() -- 获取资源数量 ngx.say(&amp;#34;main thread: count: &amp;#34;, sema:count()) -- count: 0 -- 新协程的处理函数 local function handler() ngx.say(&amp;#34;sub thread: waiting on sema...&amp;#34;) -- 等待 1 个资源；超时时间是 1 秒，如果资源数量 &amp;gt;= 0，立即返回，如果拿不到（数量 &amp;lt; 0），会 yield。 -- 相当于锁操作中的 加锁（lock）操作。 -- 参数中的 1 表示 1 秒；最小可以为 0.</description></item><item><title>OpenResty 共享字典（内存）</title><link>https://isshe.site/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/</link><pubDate>Wed, 03 May 2023 06:00:05 -0300</pubDate><guid>https://isshe.site/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/</guid><description>OpenResty shared dict 目的：
相关 Lua API 如 ngx.shared.DICT.get 是如何使用的？ 如何定义 lua_shared_dict 的，lua_shared_dict 做了哪些工作？ 详细跟踪各类 Lua 接口（set、get 每类一个）的实现，了解shared dict的设计/实现细节。 这些 Lua 接口是否是原子的？是否需要考虑竞争问题？原子性是如何保证的？ ngx_http_lua_shdict_shctx_t 等关键数据结构是什么作用？它们之间有什么联系？ 使用 使用示例：
http { lua_shared_dict dogs 10m; server { location / { content_by_lua_block { -- 设置 local dogs = ngx.shared.dogs dogs:set(&amp;#34;Jim&amp;#34;, 8) -- 获取 local jim_age = dogs:get(&amp;#34;Jim&amp;#34;) ngx.say(jim_age) -- 替换 dogs:replace(&amp;#34;Jim&amp;#34;, 9) -- 递增, value = 10 dogs:incr(&amp;#34;Jim&amp;#34;) -- 更新/设置超时 dogs:expire(&amp;#34;Jim&amp;#34;, 10) -- 获取 TTL dogs:ttl(&amp;#34;Jim&amp;#34;) -- 删除 dogs:delete(&amp;#34;Jim&amp;#34;) } } } } 以下是所有 Lua Api 的作用：</description></item><item><title>OpenResty Lua 代码加载</title><link>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD/</link><pubDate>Sat, 22 Apr 2023 06:00:02 -0300</pubDate><guid>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD/</guid><description>OpenResty 加载及缓存 Lua 代码 目的：
了解 OpenResty 是如何加载及缓存 Lua 代码的。 加载 Lua 代码之前的代码逻辑见 005-rewrite_by_lua.md，本文接着从 ngx_http_lua_cache_loadbuffer 开始深入。
ngx_http_lua_cache_loadbuffer - ngx_http_lua_cache_loadbuffer: 加载 Lua 代码 \- ngx_http_lua_cache_load_code: 从缓存中加载，有直接返回，没有则继续。 \- lua_pushlightuserdata(L, ngx_http_lua_lightudata_mask(code_cache_key)) \- lua_rawget(L, LUA_REGISTRYINDEX): 把 Lua 代码缓存表加载到栈顶 \- if (*ref == LUA_NOREF): 通过 ref 和 key 结合来获取缓存。如果有 ref，就用 ref，如果没有，就用 key。如果用 key 也没找到，就是没缓存，后续需要加载。 \- lua_isfunction: 这是闭包工厂函数，通过此函数来生成闭包 \- rc = lua_pcall(L, 0, 1, 0): 正式调用闭包工厂，生成闭包，返回值是 0 表示成功，否则就是失败了。 \- ngx_http_lua_clfactory_loadbuffer: 加载闭包工厂 \- lua_load(L, ngx_http_lua_clfactory_getS, &amp;amp;ls, name): 加载 Lua Chunk 成一个函数。这个函数其实是一个闭包 &amp;#34;return function() .</description></item><item><title>OpenResty rewrite_by_lua*</title><link>https://isshe.site/p/openresty-rewrite_by_lua/</link><pubDate>Tue, 18 Apr 2023 06:00:02 -0300</pubDate><guid>https://isshe.site/p/openresty-rewrite_by_lua/</guid><description>rewrite_by_lua* rewrite_by_lua* 充当一个 rewrite 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文: http, server, location, location if 阶段: rewrite tail 注意：执行阶段晚于标准 ngx_http_rewrite_module 模块。 语法： 与 init_by_lua* 类似，不再赘述。 注意： 如果 rewrite_by_lua* 指定的 Lua 代码中通过 ngx.exit(code) 退出，如果 code = ngx.OK（非 ngx.HTTP_OK），则会继续执行! 实现 以 rewrite_by_lua_block 为例
开始前，还是如以往一样，先明确此行的目的：
解析指令时，做了什么？猜测和前面两个没有太大差别。 在什么时候实际执行了 Lua 代码？如何执行的？每个请求都会执行这个，想必处理方法应该不同以往。 还提到“全局环境（沙箱）”，是什么呢？ 指令定义 { ngx_string(&amp;#34;rewrite_by_lua_block&amp;#34;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF |NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_http_lua_rewrite_by_lua_block, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_rewrite_handler_inline }, NGX_HTTP_LIF_CONF：location if 配置 ngx_http_lua_rewrite_by_lua_block：配置解析时执行的函数。 ngx_http_lua_rewrite_handler_inline：实际执行 Lua 代码的函数。 还是围绕 3 点展开：</description></item><item><title>OpenResty 管道（pipe）</title><link>https://isshe.site/p/openresty-%E7%AE%A1%E9%81%93pipe/</link><pubDate>Mon, 10 Apr 2023 06:00:03 -0300</pubDate><guid>https://isshe.site/p/openresty-%E7%AE%A1%E9%81%93pipe/</guid><description>管道 目的：
有哪些使用场景？ 如何使用？在 OR 里面是如何使用的？ 由操作系统 shell 执行的字符串形式的命令行，会阻塞吗？ 如何实现的？ 在 proc_write 中 yield 出去后，是如何 resume 的？ 使用 spawn —— 创建对象 语法：proc, err = pipe_module.spawn(args, opts?)
作用：创建并返回一个新的子流程实例。
参数：
args：数组形式的命令或者是字符串形式的命令。 数组形式示例：{&amp;ldquo;ls&amp;rdquo;, &amp;ldquo;-l&amp;rdquo;} 字符串形式示例：&amp;ldquo;ls -l&amp;rdquo;。当使用此模式时，命令将由操作系统 shell 执行，就像 os.execute 一样。 opts： merge_stderr：如果是 true，将合并 stderr 和 stdout 的输出，相当于 2&amp;gt;&amp;amp;1。 buffer_size：读取操作的缓冲区大小，默认是 4096 字节。 environ：环境变量。如果当前系统不支持环境变量，则返回 nil 和 &amp;ldquo;environ option not supported&amp;rdquo;。示例：{&amp;quot;PATH=/tmp/bin&amp;quot;, &amp;quot;CWD=/tmp/work&amp;quot;} write_timeout：写超时时间，单位是毫秒。默认是 10000，设置为 0 则永不超时。 stdout_read_timeout：标准输出读超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 stderr_read_timeout：标准错误读超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 wait_timeout：等待超时，单位是毫秒，默认是 10000，设置为 0 则永不超时。 返回值：</description></item><item><title>OpenResty *_by_lua* 及阶段</title><link>https://isshe.site/p/openresty-_by_lua-%E5%8F%8A%E9%98%B6%E6%AE%B5/</link><pubDate>Sun, 02 Apr 2023 06:00:02 -0300</pubDate><guid>https://isshe.site/p/openresty-_by_lua-%E5%8F%8A%E9%98%B6%E6%AE%B5/</guid><description>OpenResty 中的 *_by_lua* 及阶段 目的：
了解都有哪些阶段：*_by_lua*。 了解各个阶段的执行时机，各阶段有什么限制：如是否可以 yield，原因是什么。 所有的 *_by_lua*：
执行阶段：指的是对应的 Nginx 的阶段
init_by_lua*：可用于加载配置、初始化全局变量等
上下文：无 执行阶段：初始化阶段是在 master 进程中 设置执行阶段的位置：无 是否可以 yield：否，初始化阶段，无需 yield。 init_worker_by_lua*：可用于加载 Lua 模块等
上下文：NGX_HTTP_LUA_CONTEXT_INIT_WORKER 执行阶段：初始化 worker 进程阶段 设置执行阶段的位置：无 是否可以 yield：否，初始化阶段，无需 yield。 ssl_client_hello_by_lua*：可以用于设置 TLS 算法，HTTP 协议版本(1.1/2/3)。
上下文：NGX_HTTP_LUA_CONTEXT_SSL_CLIENT_HELLO 执行阶段：客户端发来 Client Hello 时后，处理Client Hello 消息前 设置执行阶段的位置：SSL_CTX_set_client_hello_cb 是否可以 yield：是 ssl_session_fetch_by_lua*：根据客户端提供的 Session ID 查找并恢复会话。
上下文：NGX_HTTP_LUA_CONTEXT_SSL_SESS_FETCH 执行阶段：通常会在 ssl_certificate_by_lua* 前调用 设置执行阶段的位置：SSL_CTX_sess_set_get_cb 是否可以 yield：是 注意：使用 TLS session tickets 时，不会执行这个回调。 ssl_certificate_by_lua*：可用于动态设置服务器证书。</description></item><item><title>OpenResty ngx.sleep</title><link>https://isshe.site/p/openresty-ngx.sleep/</link><pubDate>Sun, 02 Apr 2023 06:00:02 -0300</pubDate><guid>https://isshe.site/p/openresty-ngx.sleep/</guid><description>ngx.sleep 在 OpenResty 中，我们可以通过 ngx.sleep() 让出执行权进行“睡眠/挂起”，让当前请求暂停一段时间（单位为秒）后醒来。
目的：
了解 ngx.sleep 的使用。 了解 ngx.sleep 的实现。 ngx.sleep()及其他 cosocket 相关的函数不能用在 init_by_lua/init_worker_by_lua/set_by_lua/header_filter_by_lua/body_filter_by_lua/log_by_lua 的原因是什么? 使用 ngx.sleep 的使用非常简单：
ngx.sleep(0.001) 睡眠时间的精度是毫秒（0.001 秒）。
上下文：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer., ssl_certificate_by_lua, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*
实现 ngx.sleep 也是通过 C 代码注入的方式，对应的处理函数是：ngx_http_lua_ngx_sleep，我们直接来跟踪这个函数的实现。
- ngx_http_lua_ngx_sleep \- delay = (ngx_int_t) (luaL_checknumber(L, 1) * 1000)：将参数转换成毫秒 \- coctx-&amp;gt;sleep.handler = ngx_http_lua_sleep_handler：填充 coctx-&amp;gt;sleep 事件 \- ngx_add_timer(&amp;amp;coctx-&amp;gt;sleep, (ngx_msec_t) delay)：添加定时器 \- return lua_yield(L, 0)：让出执行权 可以看到，时间到了以后，会调用 ngx_http_lua_sleep_handler：
- ngx_http_lua_sleep_handler \- ctx-&amp;gt;cur_co_ctx = coctx：设置当前协程 \- if (ctx-&amp;gt;entered_content_phase)：如果不是 access、rewrite 阶段 \- ngx_http_lua_sleep_resume：直接 resume \- vm = ngx_http_lua_get_lua_vm(r, ctx)：获取 Lua 虚拟机 \- rc = ngx_http_lua_run_thread(vm, r, ctx, 0)：继续跑协程 \- else：否则如果是 access、rewrite 阶段，就设置回调，直接进入核心处理流程 \- ctx-&amp;gt;resume_handler = ngx_http_lua_sleep_resume：设置 resume 回调 \- ngx_http_core_run_phases(r)：然后继续回到核心处理逻辑 \- ngx_http_run_posted_requests：执行后续的请求 在这个函数中，会恢复被暂停的 Lua 协程。</description></item><item><title>OpenResty 模块初始化</title><link>https://isshe.site/p/openresty-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Sun, 05 Mar 2023 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>lua-nginx-module 模块的定义及初始化 lua_nginx_module 其实就是一个 Nginx 模块，定义及实现都需要按照 Nginx 模块的要求。
这篇文章的目的是什么呢？
了解 lua-nginx-module 模块相关数据结构的定义。 了解 lua-nginx-module 模块大致的初始化流程，对 lua-nginx-module 模块有一个总体的概念，然后我们在后续的文章中，去细化追究相关指令的细节。 总分结构 定义 定义个全局的模块变量： ngx_http_lua_module.c 此结构的详细解释可见 Nginx 数据结构 ngx_module_t
ngx_module_t ngx_http_lua_module = { NGX_MODULE_V1, &amp;amp;ngx_http_lua_module_ctx, /* module context */ ngx_http_lua_cmds, /* module directives */ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ ngx_http_lua_init_worker, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ ngx_http_lua_exit_worker, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; 定义一个模块上下文 static ngx_http_module_t ngx_http_lua_module_ctx = { NULL, /* preconfiguration */ ngx_http_lua_init, /* postconfiguration */ ngx_http_lua_create_main_conf, /* create main configuration */ ngx_http_lua_init_main_conf, /* init main configuration */ ngx_http_lua_create_srv_conf, /* create server configuration */ ngx_http_lua_merge_srv_conf, /* merge server configuration */ ngx_http_lua_create_loc_conf, /* create location configuration */ ngx_http_lua_merge_loc_conf /* merge location configuration */ }; 可以看到被定义成了一个 HTTP 模块（NGX_HTTP_MODULE, ngx_http_module_t）。</description></item><item><title>OpenResty 轻量级线程</title><link>https://isshe.site/p/openresty-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 08 Jan 2023 06:00:04 -0400</pubDate><guid>https://isshe.site/p/openresty-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B/</guid><description>轻量级线程 与前一个文档中介绍的协程不同，轻量级线程不需要自行 resume、yield 来调度协程，因此使用起来更方便，有并行操作时，通常会使用此方式。
看是否和此函数强关联：ngx_http_lua_run_thread； 如果此文章无法完成对 ngx_http_lua_run_thread 的理解，则另外文章。
目的：
轻线程如何使用？ 轻线程的使用场景？ 什么是轻线程？ OpenResty 的协程与 Luajit 的协程是什么关系？有什么区别？ 介绍 轻线程是一种由 lua-nginx-module 调度的特殊的 Lua 协程。rewrite/access/content_by_lua* 的 Lua 代码块就是在 lua-nginx-module 自动创建的**样板“轻线程”**中执行，这种样板“轻线程”也称为“入口线程（entry thread）”。
默认情况下，rewrite_by_lua 等 Nginx 处理程序只有在遇到以下情况时才会中止：
入口线程和所有用户轻线程都中止了。 任意一个轻线程调用了 ngx.exit、ngx.exec、ngx.redirect、ngx.req.set_uri(uri, true)。 入口线程触发了 Lua 错误。 不过，用户的轻线程触发了 Lua 错误而中止，并不会导致其他轻线程也中止。
由于 Nginx 子请求模型的限制，一般不允许中止一个正在运行的 Nginx 子请求，因此也不允许中止一个正等待一个或多个子请求终止的正在运行的轻线程，而必须使用 ngx.thread.wait 来等待这些轻线程终止。 一个值得注意的例外是，可以使用状态码 ngx.ERROR(-1), 408, 444 或 499 调用 ngx.exit 来中止挂起的子请求。
轻线程不是以抢的方式进行调度的，也就是不会自动执行时间分片。轻线程会一直运行，知道遇到以下情况：
一个 I/O 操作无法在一次执行中完成。 调用了 coroutine.</description></item><item><title>OpenResty 协程</title><link>https://isshe.site/p/openresty-%E5%8D%8F%E7%A8%8B/</link><pubDate>Sun, 01 Jan 2023 06:00:04 -0400</pubDate><guid>https://isshe.site/p/openresty-%E5%8D%8F%E7%A8%8B/</guid><description>协程 lua-nginx-module 提供了 coroutine 系列 Lua 接口，用于操作协程。
这个与 ngx_http_lua_new_thread 相关的 lua-nginx-module 内部使用的协程不同，切勿搞混了。
这系列函数较为少用，需要并行操作时通常使用轻量级线程（light thread）。
目的：
coroutine Lua 接口的使用？主要使用场景？ 如前面提到，这个较为少用。lua-nginx-module 支持，主要应该是为了兼容第三方 Lua 模块。 coroutine 是如何实现的？ 与 Luajit 的协程是什么关系？ 使用 coroutine.create(f)：创建一个协程并返回此协程，类型为“thread”，f 必须是一个函数。 coroutine.resume (co [, val1, ···])：开始或继续执行协程 co。如果协程执行出错，则返回 false 和错误信息，如果协程执行正常，返回 true。 首次调用会开始调用 f 函数，val1 等作为参数传递给 f。 后续调用会用 yield 的地方继续，val1 等作为 yield 的结果传递给 f。 coroutine.yield (···)：暂停正在执行的协程的执行。传递给 yield 的参数，将作为 resume 额外的结果返回。 coroutine.running ()：返回正在运行的协程，主协程正在运行，则返回 nil。 coroutine.status (co)：返回协程 co 的状态。 running：协程正在执行 suspended：调用了 yield，或者还没开始运行。 normal：激活但没有在运行，意味着它正在 resume 其他协程。 dead：执行完 f 函数，或者出错了。 coroutine.</description></item><item><title>OpenResty 代码结构</title><link>https://isshe.site/p/openresty-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 06 Dec 2022 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</guid><description>Lua Nginx Module 的源码结构 常常提醒自己使用总分思想，这不，发现缺少了一些更为全局的内容，现补充如下。 以 0.10.21 版本为例
目的
大致了解 openresty 是个什么、实现了哪些功能。 ngx_lua-0.10.21 ├── README.markdown ├── src │ ├── api │ │ └── ngx_http_lua_api.h │ ├── ddebug.h：用于调试的头文件 - 各个阶段是处理程序，用于支持 `*_by_lua*` 系列指令 │ ├── ngx_http_lua_initby.c │ ├── ngx_http_lua_initby.h │ ├── ngx_http_lua_initworkerby.c │ ├── ngx_http_lua_initworkerby.h │ ├── ngx_http_lua_ssl_certby.c │ ├── ngx_http_lua_ssl_certby.h │ ├── ngx_http_lua_ssl_client_helloby.c │ ├── ngx_http_lua_ssl_client_helloby.h │ ├── ngx_http_lua_setby.c │ ├── ngx_http_lua_setby.h │ ├── ngx_http_lua_ssl_session_fetchby.c │ ├── ngx_http_lua_ssl_session_fetchby.</description></item><item><title>OpenResty ngx.log</title><link>https://isshe.site/p/openresty-ngx.log/</link><pubDate>Tue, 15 Nov 2022 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-ngx.log/</guid><description>ngx.log 我们都知道，这个接口的功能是打印错误日志，那么它是如何工作的呢？我们来探究一下。
注意，是接口 ngx.log 不是指令 log_by_lua 。*
目的：
它是如何工作的呢？ ngx.log 是如何被定义的？ ngx.log 执行时，做了什么？ 使用 上下文：context: init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer., balancer_by_lua, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*, exit_worker_by_lua*, ssl_client_hello_by_lua*
语法：ngx.log(log_level, ...)
注意：
Lua nil 会被输出为字符串 &amp;ldquo;nil&amp;rdquo;；Lua 的布尔类型会输出为 &amp;ldquo;true&amp;rdquo; or &amp;ldquo;false&amp;rdquo;；ngx.null 被输出为 &amp;ldquo;null&amp;rdquo; 字符串；Lua table 将会调用其元表的 __tostring 函数，调用失败则抛出异常，异常也被输出到错误日志中；如果是 userdata，则输出字符串 &amp;ldquo;null&amp;rdquo;；其他类型一律抛出异常。 Nginx 内核中的错误消息长度有一个硬编码的 2048 字节限制。此限制包括尾部换行符和前置时间戳。如果消息大小超过此限制，Nginx 将相应地截断消息。可以通过编辑 Nginx 源代码树中 src/core/ngx_log.</description></item><item><title>OpenResty log_by_lua*</title><link>https://isshe.site/p/openresty-log_by_lua/</link><pubDate>Sun, 13 Nov 2022 06:00:04 -0400</pubDate><guid>https://isshe.site/p/openresty-log_by_lua/</guid><description>log_by_lua* 在日志处理阶段执行 Lua 源代码，不会替换当前的访问日志，并在打印日志之前运行。
用法 上下文: http, server, location, location if 阶段: log 语法： 与 init_by_lua* 类似，不再赘述。 注意： 以下 API 无法在此指令中使用： Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.exit) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket). 实现 与 005-rewrite_by_lua 类似，不再赘述。
header_filter_by_lua*、 body_filter_by_lua* 等都是一样的套路，就不再赘述了。</description></item><item><title>OpenResty content_by_lua*</title><link>https://isshe.site/p/openresty-content_by_lua/</link><pubDate>Sat, 12 Nov 2022 06:00:04 -0400</pubDate><guid>https://isshe.site/p/openresty-content_by_lua/</guid><description>content_by_lua* content_by_lua* 充当一个 content 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文: location, location if 注意，不能定义在 http、server 块内了。 阶段: content 语法： 与 init_by_lua* 类似，不再赘述。 注意：这个指令不要和其他 content handler 指令（如 proxy_pass）在同一个 location 同时使用。 实现 在《模块初始化》 的 “ngx_http_lua_init 执行流程” 中， 我们了解到 content handler 并没有像 rewrite handler 一样在函数 ngx_http_lua_init 中被放到 cmcf-&amp;gt;phases 数组中，所以接下来我们来探究一下为什么。 因此，我们此行的目的：
了解指令是如何被解析的。（猜测与前面的阶段没有什么差异） 了解 content handler 是被如何设置的，为何于其他阶段的 handler 不同。 了解是何时执行了 Lua 代码，如何执行的。（猜测与前面的阶段没有什么差异） 指令定义 /* content_by_lua &amp;#34;&amp;lt;inline script&amp;gt;&amp;#34; */ { ngx_string(&amp;#34;content_by_lua&amp;#34;), NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1, ngx_http_lua_content_by_lua, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_content_handler_inline }, ngx_http_lua_content_by_lua 执行过程 - ngx_http_lua_content_by_lua \- if (cmd-&amp;gt;post == NULL)：检查是否有指定处理程序，没有直接报错返回。 \- if (llcf-&amp;gt;content_handler)：检查是否已经设置了处理程序，设置了报错返回。 \- if (value[1].</description></item><item><title>OpenResty access_by_lua*</title><link>https://isshe.site/p/openresty-access_by_lua/</link><pubDate>Sun, 06 Nov 2022 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-access_by_lua/</guid><description>access_by_lua* access_by_lua* 充当一个 access 阶段的处理程序，对每个请求执行指定的 Lua 代码，代码会在独立的全局环境（沙箱）中执行。
用法 上下文: http, server, location, location if 阶段: access tail 注意：执行阶段晚于标准 ngx_http_access_module 模块。 语法： 与 init_by_lua* 类似，不再赘述。 实现 实现逻辑与 rewrite_by_lua* 别无二致，不再赘述。</description></item><item><title>OpenResty init_by_lua*</title><link>https://isshe.site/p/openresty-init_by_lua/</link><pubDate>Sun, 06 Nov 2022 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-init_by_lua/</guid><description>init_by_lua* 相关代码逻辑出自 lua-nginx-module v0.10.21 版本
当 Nginx 收到 HUP 信号并开始重新加载配置文件时，Lua VM 会被重新创建，并且 init_by_lua* 会在新的 Lua VM 上再次运行。 如果关闭 lua_code_cache 指令（默认打开），init_by_lua* 处理程序（Lua 代码）将在每个请求上运行，因为在这种特殊模式下，需要为每个请求创建一个独立的 Lua VM。
用法 init_by_lua 已不建议使用，使用 init_by_lua_block 和 init_by_lua_file 代替。
使用场景：
在 init_by_lua* 中，加载 Lua 模块，如 require &amp;quot;cjson&amp;quot;，再在其他阶段（如 content_by_lua*）使用：再次 require，这次 require 会很快，直接从 package.loaded 中获取返回。 执行阶段：loading-config，配置加载阶段
上下文：http
语法：
init_by_lua &amp;#39;lua-script-str&amp;#39; init_by_lua_block { lua-script } init_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt; 示例： init_by_lua 'print(&amp;quot;Hello World&amp;quot;)' init_by_lua_block { print(&amp;quot;Hello World&amp;quot;) } init_by_lua_file /usr/local/openresty/lua/init.</description></item><item><title>OpenResty init_worker_by_lua*</title><link>https://isshe.site/p/openresty-init_worker_by_lua/</link><pubDate>Sun, 06 Nov 2022 06:00:05 -0400</pubDate><guid>https://isshe.site/p/openresty-init_worker_by_lua/</guid><description>init_worker_by_lua* 如果没有启用 master 进程则此指令的 Lua 代码将在 init_by_lua* 指令的 Lua 代码之后运行。
启用 master 进程：表示非 master-worker 的模式 用法 使用场景
通常用于启动定时器执行每 worker 相关的内容，或者后端健康检查等。 执行阶段：starting-worker，工作进程启动阶段
上下文：http
语法：
与 init_by_lua* 类似，不再赘述。
实现 以 init_worker_by_lua_file 为例
通过前面的探索，我们已经知道指令的解析会在配置解析阶段，而对应的 Lua 代码会在后续才执行。 因此，我们接下来目的很明确：
解析 init_worker_by_lua_file 指令时，做了什么？ 在什么时候实际执行了 Lua 代码？如何执行的？ 我们以 init_worker_by_lua_file 指令为例。
指令定义 { ngx_string(&amp;#34;init_worker_by_lua_file&amp;#34;), NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1, ngx_http_lua_init_worker_by_lua, NGX_HTTP_MAIN_CONF_OFFSET, 0, (void *) ngx_http_lua_init_worker_by_file }, ngx_http_lua_init_worker_by_lua：指令解析时调用的函数。 ngx_http_lua_init_worker_by_file：指令结构的 post 字段的值。 解析指令时，会调用 ngx_http_lua_init_worker_by_lua，我们来跟踪一下。</description></item><item><title>OpenResty Lua 代码执行实例跟踪</title><link>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8B%E8%B7%9F%E8%B8%AA/</link><pubDate>Sun, 30 Oct 2022 06:00:04 -0300</pubDate><guid>https://isshe.site/p/openresty-lua-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8B%E8%B7%9F%E8%B8%AA/</guid><description>Lua 代码执行实例跟踪 实际跟踪 Lua 代码的执行情况（主要是出错情况）。
异常情况 由于使用 bpftrace 得到的堆栈不符合预期，直接用 gdb 来获取：
指令：
# index a nil value init_by_lua 'return a.b'; 对 nil 值进行索引。
错误输出：
nginx: [error] init_by_lua error: init_by_lua:1: attempt to index global 'a' (a nil value) stack traceback: init_by_lua:1: in main chunk 命令：
$ gdb sbin/nginx &amp;gt; set args -p /NGINX/CONFIG/PATH &amp;gt; b ngx_http_lua_traceback &amp;gt; run &amp;gt; bt 从 init_by_lua 的文章中，已经知道了 ngx_http_lua_traceback 是错误处理函数，因此我们直接追踪它。
结果：
#0 ngx_http_lua_traceback (L=0x7ffff76f02e8) at ngx_lua-0.</description></item></channel></rss>