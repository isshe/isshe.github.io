<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>操作系统 on 树深时间录</title><link>https://isshe.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 操作系统 on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2023 06:00:05 -0400</lastBuildDate><atom:link href="https://isshe.site/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统 —— IO 多路复用之 epoll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</link><pubDate>Wed, 15 Feb 2023 06:00:05 -0400</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</guid><description>epoll I/O事件通知设施(I/O event notification facility)。
1. epoll_create #include &amp;lt;sys/epoll.h&amp;gt; int epoll_create(int size); int epoll_create1(int flags); 作用：打开一个epoll文件描述符。 参数： size： Linux 2.6.8后不再使用，但是必须大于0。 flags： 0：和epoll_create行为一样。 O_CLOEXEC: 进程退出时关闭文件描述符。 返回： 失败：-1，设置errno；否则： 返回一个指向一个新epoll实例的文件描述符；当不再使用此描述符时，应使用close关闭。 当所有指向此epoll实例的描述符都被关闭时，内核会释放相关资源。 2. epoll_ctl typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 作用：epoll文件描述符的控制接口。 参数： epfd: epoll fd，epoll文件描述符； op: EPOLL_CTL_ADD：注册fd到epfd； EPOLL_CTL_MOD：修改与fd的关联evnet事件。 EPOLL_CTL_DEL：从epfd中删除fd； fd: 要操作(op)的fd； event: 与fd关联的事件。EPOLL_CTL_DEL时这个参数被忽略，也可以直接为NULL； 返回： 正常：0； 异常：-1，设置errno； 数据结构说明； struct epoll_event的events的是位掩码的形式，取值是： EPOLLIN: 相关文件可读。(read) EPOLLOUT: 相关文件可写。(write) EPOLLRDHUP: 流套接字对端关闭连接，或关闭写入一半的连接。(在使用边沿触发时，此标志对于编写简单代码以检测对端关闭特别有用。) EPOLLPRI: 有紧急数据可读。 EPOLLERR: 相关文件描述符发生错误。（默认设置，不用手动设置） EPOLLHUP: 相关文件描述符被挂起。（默认设置，不用手动设置） EPOLLET: 相关文件描述符设置为边缘触发。（默认是水平触发） EPOLLONESHOT: 对相关描述符设置一次性行为。 epoll_wait一次后，不会再wait，除非使用EPOLL_CTL_MOD重新设置。 EPOLLWAKEUP: 设置此标记，使事件排队时系统保持唤醒。 当系统设置了自动休眠模式(/sys/power/autosleep)时，为了保持设备唤醒直到事件处理完成，必须使用此标记。 EPOLLEXCLUSIVE：为附加到目标文件描述符fd的epoll文件描述符设置独占唤醒模式。【？？？】 3.</description></item><item><title>操作系统 —— IO 多路复用之 poll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</guid><description>poll 相关函数 #include &amp;lt;poll.h&amp;gt; struct pollfd { int fd; /* file descriptor */ short events; /* events to look for */ short revents; /* events returned */ }; int poll(struct pollfd fds[], nfds_t nfds, int timeout); 作用：类似于select。（指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。） 参数： fds[]: 指向一个结构数组第一个元素的指针。 nfds: 指定fds中的元素个数。 timeout: INFTIM： 永远等待；(INFTIM被定义为一个负值) 0：立即返回； &amp;gt; 0: 等待指定数据的毫秒数。 返回： 成功：就绪描述符数目 超时：0 出错：-1 数据结构说明： events: 要测试的条件； revents: 返回描述符的状态。 events/revents标记： 常值 说明 能作为evnets的输入吗？ 能作为revents的输入吗？ POLLIN 普通或优先级带数据可读 + + POLLRDNORM 普通数据可读 + + POLLRDBAND 优先级带数据可读 + + POLLPRI 高优先级数据可读 + + POLLOUT 普通数据可写 + + POLLWRNORM 普通数据可写 + + POLLWRBAND 优先级带数据可写 + + POLLERR 发生错误 + POLLHUP 发生挂起 + POLLNVAL 描述符不是一个打开的文件 + 数据分类 poll识别三类数据：普通(normal)、优先级带(priority band)、高优先级(high priority)</description></item><item><title>操作系统 —— IO 多路复用之 select</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</guid><description>select select函数允许进程指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。
1. select #include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); 作用：指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。 参数： nfds: 待测试的最大描述符+1； readfds: 监听读的fd集合； writefds: 监听写得fd集合； errorfds: 监听异常的fd集合； timeout: 等待超时时间。 NULL: 永远等下去； 非NULL且不为值0: 等待指定时间； 非NULL且值为0: 不等待，检查描述符后立即返回。（轮询） 返回： 返回： 成功：就绪描述符数目 超时：0 出错：-1 2. 描述符就绪条件 读就绪： 该套接字接收缓冲区的数据字节数&amp;gt;=套接字缓冲区低水位标记的当前大小。 高于水位，认为可读。 该套接字的读半部关闭(接收了FIN的TCP连接)。 返回EOF 该套接字是一个监听套接字且已完成的连接数不为0。 此时accept通常不阻塞。 其上有一个套接字错误待处理。 读操作不阻塞、返回-1，并设置errno。 待处理错误，可通过getsockoptvidkSO_ERROR套接字获取并清除。 写就绪： 发送缓冲区的数据字节数&amp;gt;=套接字缓冲区低水位标记的当前大小。 该连接的写半部关闭。 此时写，会产生SIGPIPE信号。 使用非阻塞connect的套接字已建立连接，或者connect已经以失败告终。 其上有一个套接字错误待处理。 异常就绪：（？！） 套接字存在带外数据或者仍处于带外标记。 注意：当某个套接字上发生错误时，它将由select标记为可读又可写。 汇总： 条件 可读吗？ 可写吗？ 异常吗？ 有数据可读 + 关闭连接的读一半 + 给监听套接字准备好新连接 + 有可用于写得空间 + 关闭连接的写一半 + 待处理错误 + + TCP带外数据 + 3.</description></item><item><title>操作系统 —— 信号</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</guid><description>信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为： 1.信号发送和信号接收 待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数: #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;signal.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 发送sig指定信号到pid进程 int kill(pid_t pid, int sig); // 向自己发送SIGALRM信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题 待处理信号被阻塞。
例如：一个进程捕获一个信号SIGINT然后去处理程序处理信号，此时又来一个SIGINT信号，此信号会被阻塞。[疑问][1] （第2个信号不是SIGINT信号，那是否也还是阻塞？） 待处理信号不会排队等待。
任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？） 系统调用可以被中断。
如read、wait、accept这样的慢速系统调用被信号打断，但是信号处理函数返回后不再继续被打断的系统调用，而是立即返回错误，errno为EINTR。 详见ex_SIGCHLD.c
教训：不可以用信号来对其他进程中发生的时间计数
3.</description></item><item><title>操作系统 —— 线程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</guid><description>线程 当一个程序由exec启动执行时，系统将创建一个称为初始线程(initail thread)或主线程(main thread)的单个线程。 线程取消在8.5章，被取消的线程要释放相关资源（锁等），需要注意。 线程创建可能比进程创建快10~100倍； 线程或者是可汇合的(joinable)或者是脱离/分离的(detached)。（默认可汇合的） 可汇合的线程可以被其他线程回收其资源和杀死。 当可汇合的线程终止时，其线程ID和退出状态将保留，直到另一个线程调用pthread_join; 脱离的线程则像守护进程：终止时，所有资源都释放，因此不能等待它终止； 线程是运行在进程上下文中的逻辑流。 1. 共享及私有 线程共享的内容：
进程指令； 大多数数据； 打开的文件（如描述符）； 信号处理程序和信号处置； 当前工作目录； 用户ID和组ID； 线程私有的内容： 线程ID； 寄存器集合（包括程序计数器和栈指针）； 栈； 栈指针； 程序计数器； errno； 信号掩码； 优先级； 2. 相关函数 2.1 pthread_create #include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); 作用：创建线程 参数： tid：线程ID；这是结果参数； attr: 线程属性，如优先级、初始栈大小、是否是一个守护线程等；通常采用默认值； start_routine: 创建的线程所需要执行的函数；称为线程启动函数(thread start function); arg: 参数；如果有多个，则打包成一个结构即可； 返回： 成功：0 失败：Exxx值 2.</description></item><item><title>操作系统 —— 进程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程是操作系统中最核心的概念。
定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。 逻辑流(逻辑控制流）：程序计数器PC值的序列。 异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。 并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发(concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。 1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程； 1.进程地址空间 1.1 典型进程地址空间1 典型进程地址空间1
代码段起始地址： 32位：0x08048000 64位：0x00400000 进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。 1.2 典型进程地址空间2 典型进程地址空间2
2. 进程状态 2.1 状态转换图 状态转换图 2.2 基本状态 1）运行态：进程实际占用CPU； 2）就绪态：可运行； 3）阻塞态：除非某种外部事件发生(使进程满足运行条件)，否则进程不能运行。 2.3 引入的状态： 创建状态； 终止状态； 挂起状态；（图中没有） 3.</description></item><item><title>操作系统 —— 进程间通信之 Posix 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>Posix信号量 信号量是一种提供不同进程间或一个进程的不同线程间同步手段的原语。 Posix提供两类信号量：
有名(named)信号量 基于内存(memory-base)的信号量。【macOS不支持】 Posix信号量的函数调用 Posix有名信号量至少具有岁内核的持续性。 Posix信号量是计数信号量。 1.相关函数 #include &amp;lt;fcntl.h&amp;gt; /* For O_* constants */#include &amp;lt;sys/stat.h&amp;gt; /* For mode constants */#include &amp;lt;semaphore.h&amp;gt; // 打开 sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); // 关闭 int sem_close(sem_t *sem); // 删除 int sem_unlink(const char *name); // &amp;#34;加锁&amp;#34;——测试指定信号量的值，如果大于0，将它-1 int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // “解锁”——信号量+1 int sem_post(sem_t *sem); // 获取信号量的值(macOS不支持) int sem_getvalue(sem_t *sem, int *sval); // 基于内存的信号量(macOS不支持) int sem_init(sem_t *sem, int shared, unsigned int value); int sem_destroy(sem_t *sem); A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix共享内存区 Posix.1提供了两种无亲缘关系进程间共享内存区的方法：（都需要调用mmap）
内存映射文件(memory-mapped file)：由open函数打开，由mmap函数把得到的描述符映射到当前进程地址空间中的一个文件。 共享内存区对象(share-memory object)：由shm_open打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。 1. 相关函数 #include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 只是打开一个内存区对象，返回fd // oflag: 必须函数O_RDONLY、O_RDWR中的一个。 // mode: // * 指定权限为，在指定了O_CREAT的前提下使用。 // * 与mq_open和sem_open不同，shm_open的mode参数必须指定。 int shm_open(const char *name, int oflag, ...); // 删除一个共享内存区对象的名字。（删除一个名字不会影响低层支撑对象的现有引用。） int shm_unlink(const char *name); // 裁剪普通文件或者共享内存区对象 int ftruncate(int fd, off_t length); //获取打开的共享内存对象的信息 int fstat(int fildes, struct stat *buf); 2. 示例 共享计数器持续+1 示例6_1 示例6_2 向服务器发送消息 A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>Posix 信息队列 消息队列可认为是一个消息链表。具有随内核的持续性 有读权限的线程可以从队列中取走信息； 有写权限的线程可以从队列中放置信息； 允许异步事件通知。 1. 相关函数 #include &amp;lt;mqueue.h&amp;gt;// 打开消息队列 mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr */); // 关闭消息队列，调用进程不用，但不会被删除消息队列 int mq_close(mqd_t mqdes); // 从系统中删除消息队列 // mq_unlink(const char *name); // int mq_notify(mqd_t mqdes, const struct sigevent *notification); A. Posix消息队列和SystemV消息队列的区别 Posix消息队列的读总是返回最高优先级的最早消息；System V消息队列的读可以返回任意指定优先级的消息。 往空队列放置一个消息时，Posix消息队列允许产生一个信号或者启动一个线程。System V没有类似的机制。</description></item><item><title>操作系统 —— 进程间通信之 SystemV 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>System V 信号量 1. 概述 二值信号量(binary semaphore): 其值为0或1的信号量； 计数信号量(counting semaphore): 其值为0~某个限制值之间的信号量； 以上两种信号量，等待(waiting)操作都等待信号量的值变为大于0； 计数信号量集(set of counting semaphores): 一个或多个信号量(构成一个集合), 其中的每个都是计数信号量。 System V信号量通过此概念给信号量增加了一级复杂度。 当讨论System V信号量时，都是指计数信号量集；当讨论Posix信号量时，都是指计数信号量。
约定： semval: 信号量当前值 semncnt: 等待semval变为大于其当前值的线程数； semzcnt: 等待semval变为0的线程数； semadj: 所指定信号量针对调用进程的调整值；【？？？】 2.信号量集相关数据结构 信号量集结构图
struct semid_ds { struct ipc_perm sem_perm; // 操作权限 struct sem *sem_base; // 指向信号量集数组的指针 ushort sem_nsems; // 信号量集中信号量的数量 time_t sem_otime; // 最后semop()的时间 time_t sem_ctime; // 最后创建或IPC_SET的时间 } struct sem { ushort_t semval; // 信号量值 short sempid; // 最后成功semop()/SETVAL, SETALL的PID ushort_t semncnt; // awaiting semval &amp;gt; current vale的数量 ushort_t semzcnt; // awaiting semval = 0 的数量 } // 给信号量集中某个特定的信号量指定一个操作 // 不能静态初始化，顺序根据实现不同而不同 struct sembuf { short sem_num; // 信号量号：0, 1, .</description></item><item><title>操作系统 —— 进程间通信之 SystemV 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>System V 共享内存区 1. 概述 System V 共享内存区在概念上类似于Posix共享内存区； Posix共享内存区：先调用shm_open，后调用mmap; System V 共享内存区：先调用shmget, 后调用shmat; 2. shmget函数 #include &amp;lt;sys/shm.h&amp;gt; int shmget(key_t key, size_t size, int shmflg); 作用：创建一个新的共享内存区或者访问一个已存在的共享内存区。 参数： key: ftok的返回值或者IPC_PRIVATE。 如果key=IPC_PRIVATE并且shmflg指定IPC_CREAT标记，则创建共享内存区。 如果没有key对应的共享内存标识符并且指定IPC_CREAT，则创建共享内存区。 创建内存区会初始化内存区为0。（size字节） 创建共享内存区会分配shmid_ds结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation permissions */ int shm_segsz; /* size of segment in bytes */ pid_t shm_lpid; /* pid of last shm op */ pid_t shm_cpid; /* pid of creator */ short shm_nattch; /* # of current attaches */ time_t shm_atime; /* last shmat() time*/ time_t shm_dtime; /* last shmdt() time */ time_t shm_ctime; /* last change by shmctl() */ void *shm_internal; /* sysv stupidity */ }; size: 大小 shmflg： 标记 返回：共享内存区标识符(整数) 3.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 在新的应用程序中，不应再使用消息队列。【分布式系统里面，好像很常用！需要时再了解！】 详见此Readme 2.4节 若需要客户进程和服务器进程之间的双向数据流，用UNIX域套接字或全双工管道。 队列：消息队列。信息的链接表，存储在内核中，由标识符标识。 队列ID：消息队列标识符。 与队列关联的数据结构：定义队列的当前状态 struct msqid_ds { struct ipc_perm msg_perm; msgqnum_t msg_qnum; // 队列里的消息长度/数量 msglen_t msg_qbytes; // 队列中能容纳的最大字节数 pid_t msg_lspid; // 最后msgsnd()的pid pid_t msg_lrpid; // 最后msgrcv()的pid time_t msg_stime; // 最后msgsnd()的时间 time_t msg_rtime; // 最后msgrcv()的时间 time_t msg_ctime; // 最后改变时间 } 1. 消息队列的系统限制 消息队列的系统限制
导出的：这种限制来源于其他限制。 如：Linux系统中，最大消息数受限于最大队列数，最大队列数受限于系统安装的RAM大小/数量。 2. 相关函数 key转换标识符的规则，见Readme 创建新队列、引用现有队列。 #include &amp;lt;sys/msg.</description></item><item><title>操作系统 —— 进程间通信之FIFO</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</guid><description>FIFO FIFO有时被称为命名管道。 FIFO是一种文件类型。 支持在无亲缘进程间使用。 1. FIFO创建 创建FIFO类似于创建文件；FIFO的路径名存在于文件系统中。 2. 创建FIFO 相关函数 #include &amp;lt;sys/stat.h&amp;gt;int mkfifo(const char *path, mode_t mode); // 在fd表示的目录相关位置，创建一个FIFO。 // * path为绝对路径，则忽略fd // * path为相对路径，则fd参数是一个打开的目录的文件描述符。路径名和目录有关【？？？】 // * path为相对路径，并且fd参数有特殊值AT_FDCWD，则路径名以当前目录开始。 int mkfifoat(int fd, const char *path, mode_t mode); 3. 其他 open一个FIFO时，非阻塞标记(O_NONBLOCK)会产生的影响： 一般情况下(没有指定O_NONBLOCK)， 只读open要阻塞到其他进程为写打开此FIFO为止； 只写open要阻塞到其他进程为读打开此FIFO为止； 如果指定了O_NONBLOCK，则： 只读open时，立即返回。【返回啥？正常返回？】 只写open时，如果没有其他进程为读打开此FIFO，则此只写open返回-1，errno置为ENXIO。 若write一个没有进程为读打开的FIFO，则产生信号SIGPIPE。（类似pipe） 若FIFO的最后一个写进程关闭了该FIFO，则将为改FIFO的读进程产生一个文件结束标记。（类似于pipe） FIFO的两种用途： shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件； 客户——服务器进程应用中，FIFO用作汇聚点，在客户和服务器进程间传递数据； 4.</description></item><item><title>操作系统 —— 进程间通信之共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix共享内存区 共享内存区是可用IPC形式中最快的。 一旦内存区映射到共享它的进程的地址空间，这些进程间的数据传递就不需要经过内核了；但是读写内存区时，需要进行同步。 非共享缓冲区读文件传给另一个进程写：4次内核与内核的交互 非共享缓冲区读文件传给另一个进程写 共享缓冲区读文件传给另一个进程写：2次内核与进程的交互 共享缓冲区读文件传给另一个进程写 1. 相关函数 1.1 mmap mmap: 把一个文件或一个Posix共享内存区对象映射到调用进程的地址空间。 使用此函数有3个目的： 使用普通文件以提供内存映射I/O； 使用特殊文件以提供匿名内存映射； 使用shm_open以提供无亲缘关系进程间的Posix共享内存区。 映射文件示意图： 映射文件示意图 #include &amp;lt;sys/mman.h&amp;gt; // addr: 指定fd映射到的进程内空间的起始地址； // len: 映射的长度——字节数； // offset: 从被映射文件开头起offset字节开始映射； // prot: 属性/模式(PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE) // * PROT_NONE Pages may not be accessed. // * PROT_READ Pages may be read. // * PROT_WRITE Pages may be written. // * PROT_EXEC Pages may be executed.</description></item><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定PIPE_BUF的值。 当管道的一端被关闭后，适用的规则：
当读(read)一个写端被关闭的管道，在所有数据被读取后，read返回0； 当写(write)一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write返回-1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.c</description></item><item><title>操作系统 —— 进线程同步之互斥锁、条件变量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>互斥锁与条件变量 互斥锁及条件变量是同步的基本组成部分。 互斥锁及条件变量出自Posix.1线程标准； 可以用来同步一个进程内的各个线程； 也可以用在进程间同步：互斥锁放在多个进程的共享内存区中。 1.互斥锁 互斥锁：相互排斥，是最基本的同步形式。 作用：保护临界区（critical region）。 保护的是数据：临界区中被操纵的数据；进程/线程共享的数据。 互斥锁是协作性锁，也就是锁无法防止一些进程/线程不先获取锁就访问数据。（需要靠自觉） 1.1 相关函数 静态分配使用PTHREAD_MUTEX_INITIALIZER进行初始化 #include &amp;lt;pthread.h&amp;gt; // 互斥锁初始化、销毁 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); // 上锁、解锁 int pthread_mutex_lock(pthread_mutex_t *mptr); int pthread_mutex_trylock(pthread_mutex_t *mptr); int pthread_mutex_unlock(pthread_mutex_t *mptr); // 属性初始化、销毁 int pthread_mutexattr_init(pthread_mutexattr_t *attr); int pthread_mutexattr_destroy(pthread_mutexattr_t *attr) // 属性设置：进程间共享等（MACOS和LINUX相关函数有所不同） // 均返回：成功：0，失败：正的Exxx值 2. 条件变量 互斥锁用于上锁，条件变量用于等待。 每个条件变量总是与一个互斥锁相关联。 2.1 相关函数 静态分配使用PTHREAD_COND_INITIALIZER进行初始化 #include &amp;lt;pthread.</description></item><item><title>操作系统 —— 进线程同步之读写锁</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Sun, 16 Oct 2022 12:23:30 -0300</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 1. 什么是读写锁 互斥锁把试图进入临界区的(多余)线程都阻塞住，无论是读还是写。（不区分读写） 独占锁。 读写锁区分读和写，同时只能一个线程写(写时不能读)；允许同时多个线程读(读时没有写)。 读为共享锁，写为独占锁。 读比写更频繁的应用中，用读写锁更好。 2. 读写锁的分配规则 只要没有线程持有读写锁用于写，任意数目的线程可以持有该读写锁用于读。 仅当没有线程持有读写锁时(用于读或写)，才能分配读写锁用于写。 3. 相关函数 静态分配用PTHREAD_RWLOCK_INITIALIZER进行初始化。 #include &amp;lt;pthread.h&amp;gt; // 初始化、销毁 int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy(pthread_rwlock_t *lock); // 加锁、解锁 int pthread_rwlock_rdlock(pthread_rwlock_t *lock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock); int pthread_rwlock_wrlock(pthread_rwlock_t *lock); int pthread_rwlock_trywrlock(pthread_rwlock_t *lock); int pthread_rwlock_unlock(pthread_rwlock_t *lock); // 属性初始化、销毁 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); // 属性设置：设置进程间共享: PTHREAD_PROCESS_SHARED/PTHREAD_PROCESS_PRIVATE int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);</description></item></channel></rss>