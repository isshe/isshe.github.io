<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>application on 树深时间录</title><link>https://isshe.site/tags/application/</link><description>Recent content in application on 树深时间录</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2024 21:06:54 +0800</lastBuildDate><atom:link href="https://isshe.site/tags/application/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统 —— IO 多路复用之 epoll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/</guid><description>epoll I/O 事件通知设施 (I/O event notification facility)。
1. epoll_create #include &amp;lt;sys/epoll.h&amp;gt; int epoll_create(int size); int epoll_create1(int flags); 作用：打开一个 epoll 文件描述符。 参数： size：Linux 2.6.8 后不再使用，但是必须大于 0。 flags： 0：和 epoll_create 行为一样。 O_CLOEXEC: 进程退出时关闭文件描述符。 返回： 失败：-1，设置 errno；否则： 返回一个指向一个新 epoll 实例的文件描述符；当不再使用此描述符时，应使用 close 关闭。 当所有指向此 epoll 实例的描述符都被关闭时，内核会释放相关资源。 2. epoll_ctl typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 作用：epoll 文件描述符的控制接口。 参数： epfd: epoll fd，epoll 文件描述符； op: EPOLL_CTL_ADD：注册 fd 到 epfd； EPOLL_CTL_MOD：修改与 fd 的关联 evnet 事件。 EPOLL_CTL_DEL：从 epfd 中删除 fd； fd: 要操作 (op) 的 fd； event: 与 fd 关联的事件。EPOLL_CTL_DEL 时这个参数被忽略，也可以直接为 NULL； 返回： 正常：0； 异常：-1，设置 errno； 数据结构说明； struct epoll_event的events的是位掩码的形式，取值是： EPOLLIN: 相关文件可读。(read) EPOLLOUT: 相关文件可写。(write) EPOLLRDHUP: 流套接字对端关闭连接，或关闭写入一半的连接。(在使用边沿触发时，此标志对于编写简单代码以检测对端关闭特别有用。) EPOLLPRI: 有紧急数据可读。 EPOLLERR: 相关文件描述符发生错误。（默认设置，不用手动设置） EPOLLHUP: 相关文件描述符被挂起。（默认设置，不用手动设置） EPOLLET: 相关文件描述符设置为边缘触发。（默认是水平触发） EPOLLONESHOT: 对相关描述符设置一次性行为。epoll_wait 一次后，不会再 wait，除非使用 EPOLL_CTL_MOD 重新设置。 EPOLLWAKEUP: 设置此标记，使事件排队时系统保持唤醒。 当系统设置了自动休眠模式 (/sys/power/autosleep) 时，为了保持设备唤醒直到事件处理完成，必须使用此标记。 EPOLLEXCLUSIVE：为附加到目标文件描述符 fd 的 epoll 文件描述符设置独占唤醒模式。【？？？】 3.</description></item><item><title>操作系统 —— IO 多路复用之 poll</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-poll/</guid><description>poll 相关函数 #include &amp;lt;poll.h&amp;gt; struct pollfd { int fd; /* file descriptor */ short events; /* events to look for */ short revents; /* events returned */ }; int poll(struct pollfd fds[], nfds_t nfds, int timeout); 作用：类似于 select。（指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。） 参数： fds[]: 指向一个结构数组第一个元素的指针。 nfds: 指定 fds 中的元素个数。 timeout: INFTIM：永远等待；(INFTIM 被定义为一个负值) 0：立即返回； &amp;gt; 0: 等待指定数据的毫秒数。 返回： 成功：就绪描述符数目 超时：0 出错：-1 数据结构说明： events: 要测试的条件； revents: 返回描述符的状态。 events/revents标记： 常值 说明 能作为 evnets 的输入吗？ 能作为 revents 的输入吗？ POLLIN 普通或优先级带数据可读 + + POLLRDNORM 普通数据可读 + + POLLRDBAND 优先级带数据可读 + + POLLPRI 高优先级数据可读 + + POLLOUT 普通数据可写 + + POLLWRNORM 普通数据可写 + + POLLWRBAND 优先级带数据可写 + + POLLERR 发生错误 + POLLHUP 发生挂起 + POLLNVAL 描述符不是一个打开的文件 + 数据分类 poll 识别三类数据：普通 (normal)、优先级带 (priority band)、高优先级 (high priority)</description></item><item><title>操作系统 —— IO 多路复用之 select</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-select/</guid><description>select select 函数允许进程指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。
1. select #include &amp;lt;sys/select.h&amp;gt; int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); 作用：指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。 参数： nfds: 待测试的最大描述符 +1； readfds: 监听读的 fd 集合； writefds: 监听写得 fd 集合； errorfds: 监听异常的 fd 集合； timeout: 等待超时时间。 NULL: 永远等下去； 非 NULL 且不为值 0: 等待指定时间； 非 NULL 且值为 0: 不等待，检查描述符后立即返回。（轮询） 返回： 返回： 成功：就绪描述符数目 超时：0 出错：-1 2.</description></item><item><title>操作系统 —— 信号</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E5%8F%B7/</guid><description>信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。 信号的默认行为： 1.信号发送和信号接收 待处理信号：一个发出而没有被接收的信号。 内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 Unix 系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组(process group)的。 相关函数： #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;signal.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 发送 sig 指定信号到 pid 进程 int kill(pid_t pid, int sig); // 向自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 2.信号处理问题 待处理信号被阻塞。
例如：一个进程捕获一个信号 SIGINT 然后去处理程序处理信号，此时又来一个 SIGINT 信号，此信号会被阻塞。[疑问][1] （第 2 个信号不是 SIGINT 信号，那是否也还是阻塞？） 待处理信号不会排队等待。
任意类型至多只有一个待处理信号。[疑问][2] （不同类型的信号就可以有多个吗？） 系统调用可以被中断。</description></item><item><title>操作系统 —— 线程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/</guid><description>线程 当一个程序由 exec 启动执行时，系统将创建一个称为初始线程(initail thread)或主线程(main thread)的单个线程。 线程取消在8.5章，被取消的线程要释放相关资源（锁等），需要注意。 线程创建可能比进程创建快 10~100 倍； 线程或者是可汇合的(joinable)或者是脱离/分离的(detached)。（默认可汇合的） 可汇合的线程可以被其他线程回收其资源和杀死。 当可汇合的线程终止时，其线程 ID 和退出状态将保留，直到另一个线程调用 pthread_join; 脱离的线程则像守护进程：终止时，所有资源都释放，因此不能等待它终止； 线程是运行在进程上下文中的逻辑流。 1. 共享及私有 线程共享的内容：
进程指令； 大多数数据； 打开的文件（如描述符）； 信号处理程序和信号处置； 当前工作目录； 用户 ID 和组 ID； 线程私有的内容： 线程 ID； 寄存器集合（包括程序计数器和栈指针）； 栈； 栈指针； 程序计数器； errno； 信号掩码； 优先级； 2. 相关函数 2.1 pthread_create #include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); 作用：创建线程 参数： tid：线程 ID；这是结果参数； attr: 线程属性，如优先级、初始栈大小、是否是一个守护线程等；通常采用默认值； start_routine: 创建的线程所需要执行的函数；称为线程启动函数(thread start function); arg: 参数；如果有多个，则打包成一个结构即可； 返回： 成功：0 失败：Exxx 值 2.</description></item><item><title>操作系统 —— 进程</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程是操作系统中最核心的概念。
定义：一个执行中的程序的实例。（对正在运行程序的一个抽象） 是资源分配的基本单位。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像程序独占地使用存储器系统。 逻辑流(逻辑控制流）：程序计数器 PC 值的序列。 异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。 并发流(concurrent flow)：一个逻辑流的执行在时间上与另一个流重叠。 并发：多条流并发地执行的一般现象称为并发 (concurrecy)。 多任务(multitasking)：一个进程和其他进程轮流运行的概念称为多任务。 时间片(time slice)：一个进程执行它的控制流的一部分的每一时间段。 并行流(parallel flow)：两个流运行在不同的处理器上或者不同的计算机上。 上下文(context)：内核重新启动一个被抢占的进程所需要的状态。 上下文切换：内核为每个进程维护一个上下文(context)，多任务的实现依赖上下文切换。 1）保存当前进程的上下文； 2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程； 1.进程地址空间 1.1 典型进程地址空间 1 典型进程地址空间 1
代码段起始地址： 32 位：0x08048000 64 位：0x00400000 进程从用户模式变为内核模式的方法是：中断、故障、陷入系统调用。 1.2 典型进程地址空间 2 典型进程地址空间 2
2. 进程状态 2.1 状态转换图 状态转换图 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>Posix 信号量 信号量是一种提供不同进程间或一个进程的不同线程间同步手段的原语。 Posix 提供两类信号量：
有名 (named) 信号量 基于内存 (memory-base) 的信号量。【macOS 不支持】 Posix 信号量的函数调用 Posix 有名信号量至少具有岁内核的持续性。 Posix 信号量是计数信号量。 1.相关函数 #include &amp;lt;fcntl.h&amp;gt; /* For O_* constants */#include &amp;lt;sys/stat.h&amp;gt; /* For mode constants */#include &amp;lt;semaphore.h&amp;gt; // 打开 sem_t *sem_open(const char *name, int oflag); sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); // 关闭 int sem_close(sem_t *sem); // 删除 int sem_unlink(const char *name); // &amp;#34;加锁&amp;#34;——测试指定信号量的值，如果大于 0，将它 -1 int sem_wait(sem_t *sem); int sem_trywait(sem_t *sem); int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // “解锁”——信号量 +1 int sem_post(sem_t *sem); // 获取信号量的值 (macOS 不支持) int sem_getvalue(sem_t *sem, int *sval); // 基于内存的信号量 (macOS 不支持) int sem_init(sem_t *sem, int shared, unsigned int value); int sem_destroy(sem_t *sem); A.</description></item><item><title>操作系统 —— 进程间通信之 Posix 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 Posix.1 提供了两种无亲缘关系进程间共享内存区的方法：（都需要调用 mmap）
内存映射文件 (memory-mapped file)：由 open 函数打开，由 mmap 函数把得到的描述符映射到当前进程地址空间中的一个文件。 共享内存区对象 (share-memory object)：由 shm_open 打开一个 Posix.1 IPC 名字，所返回的描述符由 mmap 函数映射到当前进程的地址空间。 1. 相关函数 #include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; // 只是打开一个内存区对象，返回 fd // oflag: 必须函数 O_RDONLY、O_RDWR 中的一个。 // mode: // * 指定权限为，在指定了 O_CREAT 的前提下使用。 // * 与 mq_open 和 sem_open 不同，shm_open 的 mode 参数必须指定。 int shm_open(const char *name, int oflag, ...); // 删除一个共享内存区对象的名字。（删除一个名字不会影响低层支撑对象的现有引用。） int shm_unlink(const char *name); // 裁剪普通文件或者共享内存区对象 int ftruncate(int fd, off_t length); //获取打开的共享内存对象的信息 int fstat(int fildes, struct stat *buf); 2.</description></item><item><title>操作系统 —— 进程间通信之 Posix 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>Posix 信息队列 消息队列可认为是一个消息链表。具有随内核的持续性 有读权限的线程可以从队列中取走信息； 有写权限的线程可以从队列中放置信息； 允许异步事件通知。 1. 相关函数 #include &amp;lt;mqueue.h&amp;gt;// 打开消息队列 mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr */); // 关闭消息队列，调用进程不用，但不会被删除消息队列 int mq_close(mqd_t mqdes); // 从系统中删除消息队列 // mq_unlink(const char *name); // int mq_notify(mqd_t mqdes, const struct sigevent *notification); A. Posix 消息队列和 SystemV 消息队列的区别 Posix 消息队列的读总是返回最高优先级的最早消息；System V 消息队列的读可以返回任意指定优先级的消息。 往空队列放置一个消息时，Posix 消息队列允许产生一个信号或者启动一个线程。System V 没有类似的机制。</description></item><item><title>操作系统 —— 进程间通信之 SystemV 信号量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>System V 信号量 1. 概述 二值信号量 (binary semaphore): 其值为 0 或 1 的信号量； 计数信号量 (counting semaphore): 其值为 0~某个限制值之间的信号量； 以上两种信号量，等待 (waiting) 操作都等待信号量的值变为大于 0； 计数信号量集 (set of counting semaphores): 一个或多个信号量 (构成一个集合), 其中的每个都是计数信号量。 System V 信号量通过此概念给信号量增加了一级复杂度。 当讨论 System V 信号量时，都是指计数信号量集；当讨论 Posix 信号量时，都是指计数信号量。
约定： semval: 信号量当前值 semncnt: 等待 semval 变为大于其当前值的线程数； semzcnt: 等待 semval 变为 0 的线程数； semadj: 所指定信号量针对调用进程的调整值；【？？？】 2.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>System V 共享内存区 1. 概述 System V 共享内存区在概念上类似于 Posix 共享内存区； Posix 共享内存区：先调用 shm_open，后调用 mmap; System V 共享内存区：先调用 shmget, 后调用 shmat; 2. shmget 函数 #include &amp;lt;sys/shm.h&amp;gt; int shmget(key_t key, size_t size, int shmflg); 作用：创建一个新的共享内存区或者访问一个已存在的共享内存区。 参数： key: ftok 的返回值或者 IPC_PRIVATE。 如果 key=IPC_PRIVATE 并且 shmflg 指定 IPC_CREAT 标记，则创建共享内存区。 如果没有 key 对应的共享内存标识符并且指定 IPC_CREAT，则创建共享内存区。 创建内存区会初始化内存区为 0。（size 字节） 创建共享内存区会分配shmid_ds结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation permissions */ int shm_segsz; /* size of segment in bytes */ pid_t shm_lpid; /* pid of last shm op */ pid_t shm_cpid; /* pid of creator */ short shm_nattch; /* # of current attaches */ time_t shm_atime; /* last shmat() time*/ time_t shm_dtime; /* last shmdt() time */ time_t shm_ctime; /* last change by shmctl() */ void *shm_internal; /* sysv stupidity */ }; size: 大小 shmflg：标记 返回：共享内存区标识符 (整数) 3.</description></item><item><title>操作系统 —— 进程间通信之 SystemV 消息队列</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B-systemv-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 在新的应用程序中，不应再使用消息队列。【分布式系统里面，好像很常用！需要时再了解！】 详见此 Readme 2.4 节 若需要客户进程和服务器进程之间的双向数据流，用UNIX域套接字或全双工管道。 队列：消息队列。信息的链接表，存储在内核中，由标识符标识。 队列 ID：消息队列标识符。 与队列关联的数据结构：定义队列的当前状态 struct msqid_ds { struct ipc_perm msg_perm; msgqnum_t msg_qnum; // 队列里的消息长度/数量 msglen_t msg_qbytes; // 队列中能容纳的最大字节数 pid_t msg_lspid; // 最后 msgsnd() 的 pid pid_t msg_lrpid; // 最后 msgrcv() 的 pid time_t msg_stime; // 最后 msgsnd() 的时间 time_t msg_rtime; // 最后 msgrcv() 的时间 time_t msg_ctime; // 最后改变时间 } 1. 消息队列的系统限制 消息队列的系统限制</description></item><item><title>操作系统 —— 进程间通信之FIFO</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bfifo/</guid><description>FIFO FIFO 有时被称为命名管道。 FIFO 是一种文件类型。 支持在无亲缘进程间使用。 1. FIFO 创建 创建 FIFO 类似于创建文件；FIFO 的路径名存在于文件系统中。 2. 创建 FIFO 相关函数 #include &amp;lt;sys/stat.h&amp;gt;int mkfifo(const char *path, mode_t mode); // 在 fd 表示的目录相关位置，创建一个 FIFO。 // * path 为绝对路径，则忽略 fd // * path 为相对路径，则 fd 参数是一个打开的目录的文件描述符。路径名和目录有关【？？？】 // * path 为相对路径，并且 fd 参数有特殊值 AT_FDCWD，则路径名以当前目录开始。 int mkfifoat(int fd, const char *path, mode_t mode); 3. 其他 open 一个 FIFO 时，非阻塞标记 (O_NONBLOCK) 会产生的影响： 一般情况下 (没有指定 O_NONBLOCK)， 只读 open 要阻塞到其他进程为写打开此 FIFO 为止； 只写 open 要阻塞到其他进程为读打开此 FIFO 为止； 如果指定了 O_NONBLOCK，则： 只读 open 时，立即返回。【返回啥？正常返回？】 只写 open 时，如果没有其他进程为读打开此 FIFO，则此只写 open 返回 -1，errno 置为 ENXIO。 若 write 一个没有进程为读打开的 FIFO，则产生信号 SIGPIPE。（类似 pipe） 若 FIFO 的最后一个写进程关闭了该 FIFO，则将为改 FIFO 的读进程产生一个文件结束标记。（类似于 pipe） FIFO 的两种用途： shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件； 客户——服务器进程应用中，FIFO 用作汇聚点，在客户和服务器进程间传递数据； 4.</description></item><item><title>操作系统 —— 进程间通信之共享内存</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>Posix 共享内存区 共享内存区是可用 IPC 形式中最快的。 一旦内存区映射到共享它的进程的地址空间，这些进程间的数据传递就不需要经过内核了；但是读写内存区时，需要进行同步。 非共享缓冲区读文件传给另一个进程写：4 次内核与内核的交互 非共享缓冲区读文件传给另一个进程写 共享缓冲区读文件传给另一个进程写：2 次内核与进程的交互 共享缓冲区读文件传给另一个进程写 1. 相关函数 1.1 mmap mmap: 把一个文件或一个 Posix 共享内存区对象映射到调用进程的地址空间。 使用此函数有 3 个目的： 使用普通文件以提供内存映射 I/O； 使用特殊文件以提供匿名内存映射； 使用 shm_open 以提供无亲缘关系进程间的 Posix 共享内存区。 映射文件示意图： 映射文件示意图 #include &amp;lt;sys/mman.h&amp;gt; // addr: 指定 fd 映射到的进程内空间的起始地址； // len: 映射的长度——字节数； // offset: 从被映射文件开头起 offset 字节开始映射； // prot: 属性/模式 (PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE) // * PROT_NONE Pages may not be accessed.</description></item><item><title>操作系统 —— 进程间通信之管道</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</guid><description>管道 管道的局限性 半双工：数据只能在一个方向上流动； 只能在具有共同祖先的两个进程间使用。 1. 管道创建 相关函数 #include &amp;lt;unistd.h&amp;gt; int pipe(int fd[2]); fd[0]为读而打开；
fd[1]为写而打开；
fd[1]的输出是fd[0]的输入；【？！】
PIPE_BUF规定内核的管道缓冲区的大小。
pathconf及fpathconf可以确定 PIPE_BUF 的值。 当管道的一端被关闭后，适用的规则：
当读 (read) 一个写端被关闭的管道，在所有数据被读取后，read 返回 0； 当写 (write) 一个读端被关闭的管道，则产生信号SIGPIPE。 忽略/捕捉信号并从信号处理程序返回后，write 返回 -1，errno=EPIPE。 A. 疑问 fd[1]的输出是fd[0]的输入？ fd[1]写端往管道写数据，即fd[1]的输出。 fd[0]读端从管道读数据，即fd[0]的输入。 详见示例：2_ex_pipe_copy_file_toless_or_more.c 多个进程使用相同的fd[2]的时候，管道的读写是怎么样的？ 管道是多个进程共用的，谁都可以写，也都可以读。因此写入/读取的信息可能混杂在一起。 详见示例：3_ex_read_and_write.</description></item><item><title>操作系统 —— 进线程同步之互斥锁、条件变量</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>互斥锁与条件变量 互斥锁及条件变量是同步的基本组成部分。 互斥锁及条件变量出自Posix.1线程标准； 可以用来同步一个进程内的各个线程； 也可以用在进程间同步：互斥锁放在多个进程的共享内存区中。 1.互斥锁 互斥锁：相互排斥，是最基本的同步形式。 作用：保护临界区（critical region）。 保护的是数据：临界区中被操纵的数据；进程/线程共享的数据。 互斥锁是协作性锁，也就是锁无法防止一些进程/线程不先获取锁就访问数据。（需要靠自觉） 1.1 相关函数 静态分配使用PTHREAD_MUTEX_INITIALIZER进行初始化 #include &amp;lt;pthread.h&amp;gt; // 互斥锁初始化、销毁 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); // 上锁、解锁 int pthread_mutex_lock(pthread_mutex_t *mptr); int pthread_mutex_trylock(pthread_mutex_t *mptr); int pthread_mutex_unlock(pthread_mutex_t *mptr); // 属性初始化、销毁 int pthread_mutexattr_init(pthread_mutexattr_t *attr); int pthread_mutexattr_destroy(pthread_mutexattr_t *attr) // 属性设置：进程间共享等（MACOS 和 LINUX 相关函数有所不同） // 均返回：成功：0，失败：正的 Exxx 值 2. 条件变量 互斥锁用于上锁，条件变量用于等待。 每个条件变量总是与一个互斥锁相关联。 2.</description></item><item><title>操作系统 —— 进线程同步之读写锁</title><link>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Sun, 24 Mar 2024 21:06:54 +0800</pubDate><guid>https://isshe.site/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 1. 什么是读写锁 互斥锁把试图进入临界区的 (多余) 线程都阻塞住，无论是读还是写。（不区分读写） 独占锁。 读写锁区分读和写，同时只能一个线程写 (写时不能读)；允许同时多个线程读 (读时没有写)。 读为共享锁，写为独占锁。 读比写更频繁的应用中，用读写锁更好。 2. 读写锁的分配规则 只要没有线程持有读写锁用于写，任意数目的线程可以持有该读写锁用于读。 仅当没有线程持有读写锁时 (用于读或写)，才能分配读写锁用于写。 3. 相关函数 静态分配用PTHREAD_RWLOCK_INITIALIZER进行初始化。 #include &amp;lt;pthread.h&amp;gt; // 初始化、销毁 int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy(pthread_rwlock_t *lock); // 加锁、解锁 int pthread_rwlock_rdlock(pthread_rwlock_t *lock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock); int pthread_rwlock_wrlock(pthread_rwlock_t *lock); int pthread_rwlock_trywrlock(pthread_rwlock_t *lock); int pthread_rwlock_unlock(pthread_rwlock_t *lock); // 属性初始化、销毁 int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); // 属性设置：设置进程间共享：PTHREAD_PROCESS_SHARED/PTHREAD_PROCESS_PRIVATE int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);</description></item></channel></rss>