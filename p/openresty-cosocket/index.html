<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="OpenResty cosocket 使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？
目的：
 学习如何使用 cosocket。 cosocket 是什么？ cosocket 的实现方式、原理是什么？  使用 ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。
以下接口的上下文皆是：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*。
ngx.socket.tcp   语法：tcpsock = ngx.socket.tcp()
  作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。
  注意：
 此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以永远不要将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也永远不要在不同的 Nginx 请求之间共享 cosocket 对象。 如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭：  当前请求处理程序（handler）执行完成 Lua cosocket 对象被 Lua GC 回收   发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。    tcpsock:bind  此接口需要更新的版本，v0."><title>OpenResty cosocket</title>
<link rel=canonical href=https://isshe.site/p/openresty-cosocket/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="OpenResty cosocket">
<meta property="og:description" content="OpenResty cosocket 使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？
目的：
 学习如何使用 cosocket。 cosocket 是什么？ cosocket 的实现方式、原理是什么？  使用 ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。
以下接口的上下文皆是：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*。
ngx.socket.tcp   语法：tcpsock = ngx.socket.tcp()
  作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。
  注意：
 此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以永远不要将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也永远不要在不同的 Nginx 请求之间共享 cosocket 对象。 如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭：  当前请求处理程序（handler）执行完成 Lua cosocket 对象被 Lua GC 回收   发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。    tcpsock:bind  此接口需要更新的版本，v0.">
<meta property="og:url" content="https://isshe.site/p/openresty-cosocket/">
<meta property="og:site_name" content="树深时间录">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="openresty"><meta property="article:tag" content="工具"><meta property="article:tag" content="源码分析"><meta property="article:tag" content="nginx"><meta property="article:tag" content="OpenResty"><meta property="article:published_time" content="2023-05-04T06:00:05-03:00"><meta property="article:modified_time" content="2023-05-04T06:00:05-03:00"><meta property="og:image" content="https://isshe.site/p/openresty-cosocket/image.jpg">
<meta name=twitter:title content="OpenResty cosocket">
<meta name=twitter:description content="OpenResty cosocket 使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？
目的：
 学习如何使用 cosocket。 cosocket 是什么？ cosocket 的实现方式、原理是什么？  使用 ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。
以下接口的上下文皆是：rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*。
ngx.socket.tcp   语法：tcpsock = ngx.socket.tcp()
  作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。
  注意：
 此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以永远不要将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也永远不要在不同的 Nginx 请求之间共享 cosocket 对象。 如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭：  当前请求处理程序（handler）执行完成 Lua cosocket 对象被 Lua GC 回收   发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。    tcpsock:bind  此接口需要更新的版本，v0."><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://isshe.site/p/openresty-cosocket/image.jpg">
<link rel="shortcut icon" href=/favicon/favicon-ss.svg>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YRCL8C5MTX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-YRCL8C5MTX',{anonymize_ip:!1})}</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/p/openresty-cosocket/>
<img src=/p/openresty-cosocket/image_hu791dd9063814c22195f4ea220a5b559d_225821_800x0_resize_q75_box.jpg srcset="/p/openresty-cosocket/image_hu791dd9063814c22195f4ea220a5b559d_225821_800x0_resize_q75_box.jpg 800w, /p/openresty-cosocket/image_hu791dd9063814c22195f4ea220a5b559d_225821_1600x0_resize_q75_box.jpg 1600w" width=800 height=450 loading=lazy alt="Featured image of post OpenResty cosocket">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/openresty/ style=background-color:#a1b557;color:#fff>
OpenResty
</a>
<a href=/categories/%E5%B7%A5%E5%85%B7/ style=background-color:#c18bc6;color:#fff>
工具
</a>
<a href=/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ style=background-color:#d7905c;color:#fff>
源码分析
</a>
<a href=/categories/nginx/ style=background-color:#90de7b;color:#fff>
Nginx
</a>
</header>
<h2 class=article-title>
<a href=/p/openresty-cosocket/>OpenResty cosocket</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>May 04, 2023</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 5 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h1 id=openresty-cosocket>OpenResty cosocket</h1>
<p>使用 openresty 过程中，常常听说 cosocket，那么，cosocket 是什么呢？</p>
<p>目的：</p>
<ul>
<li>学习如何使用 cosocket。</li>
<li>cosocket 是什么？</li>
<li>cosocket 的实现方式、原理是什么？</li>
</ul>
<h2 id=使用>使用</h2>
<p>ngx.socket.udp 和 ngx.socket.tcp 都是使用 cosocket 的方式实现的，由于 TCP 更常用，因此下面以 TCP 相关接口为例。</p>
<p>以下接口的上下文皆是：<code>rewrite_by_lua*</code>, <code>access_by_lua*</code>, <code>content_by_lua*</code>, <code>ngx.timer.*</code>, <code>ssl_certificate_by_lua*</code>, <code>ssl_session_fetch_by_lua*</code>, <code>ssl_client_hello_by_lua*</code>。</p>
<h3 id=ngxsockettcp>ngx.socket.tcp</h3>
<ul>
<li>
<p>语法：<code>tcpsock = ngx.socket.tcp()</code></p>
</li>
<li>
<p>作用：创建并返回一个 TCP 或 面向流的 UNIX 套接字对象。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>此 API 创建的 cosocket 对象与创建它的 Lua 处理程序具有完全相同的生命周期。所以<strong>永远不要</strong>将 cosocket 对象传递给任何其他 Lua 处理程序（包括 ngx.timer 回调函数），也<strong>永远不要</strong>在不同的 Nginx 请求之间共享 cosocket 对象。</li>
<li>如果没有显式关闭 cosocket 对象的底层连接或把连接放回到连接池，那么连接将在以下情况下自动关闭：
<ul>
<li>当前请求处理程序（handler）执行完成</li>
<li>Lua cosocket 对象被 Lua GC 回收</li>
</ul>
</li>
<li>发生致命错误时，也会自动关闭连接，读超时是唯一的不致命错误。</li>
</ul>
</li>
</ul>
<h3 id=tcpsockbind>tcpsock:bind</h3>
<blockquote>
<p>此接口需要更新的版本，v0.10.21 版本中还未实现。</p>
</blockquote>
<ul>
<li>
<p>语法：<code>ok, err = tcpsock:bind(address)</code></p>
</li>
<li>
<p>作用：像标准的 proxy_bind 指令一样，此 api 使到上游服务器的传出连接源自指定的本地 IP 地址。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>address 参数只能指定 IP 地址</li>
</ul>
</li>
</ul>
<h3 id=tcpsockconnect>tcpsock:connect</h3>
<ul>
<li>
<p>语法：<code>ok, err = tcpsock:connect(host, port, options_table?)</code></p>
</li>
<li>
<p>参数：</p>
<ul>
<li>host：地址或者是 UNIX 域套接字文件。</li>
<li>port：端口</li>
<li>options_tables：
<ul>
<li>pool：内存池名称，如果不指定，则是 <code>&lt;host>:&lt;port></code> 或 <code>&lt;unix-socket-path></code>。</li>
<li>pool_size：
<ul>
<li>粒度是 worker 进程级别，不是程序级别，并且连接池创建后，大小就无法修改了。</li>
<li>如果没有指定此参数并且 <code>backlog</code> 参数也没有指定，则不会创建连接池。</li>
<li>如果没有指定此参数但指定 <code>backlog</code>，则连接池大小为 backlog。</li>
<li>如果连接池内连接数量超了，则会根据最近最少使用的方式关闭连接。</li>
</ul>
</li>
<li>backlog：限制指定连接池打开的连接总数。
<ul>
<li>任何时候，打开的连接都不能超过 pool_size 指定的数量。</li>
<li>如果连接池满了，就会积压到 backlog 队列中，如果队列也满了，就会返回 <code>nil</code> 并报错。</li>
<li>如果等待时间超过 connect_timeout（可通过 settimeouts 指定），则会返回 <code>nil</code> 并报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回值：</p>
<ul>
<li>ok：成功时返回 1，失败返回 nil。</li>
<li>err：失败时的错误信息。</li>
</ul>
</li>
<li>
<p>作用：尝试在不阻塞的情况下将 TCP 套接字对象连接到远程服务器或 UNIX 域套接字文件。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>在进行域名解析并连接到远端之前，这个接口始终在连接池中查找之前由此接口或 ngx.socket.connect 接口创建的空闲连接。</li>
<li>host 支持 IP 地址和域名，对于域名，将使用 Nginx 核心的动态解析器​​来无阻塞地解析域名。（Nginx 的解析器通过 resolver 指令来配置）。</li>
<li>如果域名解析返回多个 IP，将随机选择一个 IP 进行连接。</li>
<li>对已经连接 cosocket 对象再次调用此接口，将会首先关闭原始连接。</li>
</ul>
</li>
</ul>
<h3 id=tcpsocksend>tcpsock:send</h3>
<ul>
<li>
<p>语法：<code>bytes, err = tcpsock:send(data)</code></p>
</li>
<li>
<p>参数：</p>
<ul>
<li>data：需要发送的数据。字符串或者是一个字符串数组（table）。</li>
</ul>
</li>
<li>
<p>返回值：</p>
<ul>
<li>bytes：发送了的字节数，失败返回 nil。</li>
<li>err：失败时的错误信息。</li>
</ul>
</li>
<li>
<p>作用：在当前连接上发送数据。</p>
</li>
<li>
<p>注意：这是一个同步操作。直到所有数据发送到系统 socket 发送缓冲区或者出错才返回。</p>
</li>
</ul>
<h3 id=tcpsockreceive>tcpsock:receive</h3>
<ul>
<li>
<p>语法：</p>
<ul>
<li><code>data, err, partial = tcpsock:receive(size)</code></li>
<li><code>data, err, partial = tcpsock:receive(pattern?)</code></li>
</ul>
</li>
<li>
<p>参数：</p>
<ul>
<li>size：接收指定字节的数据，支持数字或者字符串。</li>
<li>pattern：支持 <code>*l</code> 和 <code>*a</code>，默认是行模式 <code>*l</code>。
<ul>
<li><code>*l</code>：从套接字中读取<strong>一行</strong>文本。该行以换行 (LF) 结束，前面可以选择回车 (CR)。返回行中不包含 CR 和 LF 字符。事实上，所有 CR 字符都被该模式忽略。</li>
<li><code>*a</code>：从套接字读取直到连接关闭。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回值：</p>
<ul>
<li>data：接收到的数据。出错时是 nil。</li>
<li>err：出错时的错误信息。</li>
<li>partial：出错时返回当前以接收到的数据。</li>
</ul>
</li>
<li>
<p>作用：根据读取模式或大小从 socket 连接上接收数据。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>可通过 <code>settimeout</code> 指定读取超时时间。（发送时，也可用此函数指定发送超时时间）。</li>
</ul>
</li>
</ul>
<h3 id=tcpsocksettimeout>tcpsock:settimeout</h3>
<ul>
<li>
<p>语法：<code>tcpsock:settimeout(time)</code></p>
</li>
<li>
<p>参数：</p>
<ul>
<li>time：超时时间，单位是毫秒。</li>
</ul>
</li>
<li>
<p>作用：为接下来的操作设置超时时间。</p>
<ul>
<li>读取时，设置的是读取超时时间。</li>
<li>发送时，设置的是发送超时时间。</li>
<li>连接时，设置的是连接超时时间。</li>
</ul>
</li>
<li>
<p>注意：设置 keepalive 超时需使用 <code>setkeepalive</code> 方法。</p>
</li>
</ul>
<h3 id=tcpsockclose>tcpsock:close</h3>
<ul>
<li>
<p>语法：<code>ok, err = tcpsock:close()</code></p>
</li>
<li>
<p>返回值：</p>
<ul>
<li>ok：成功时返回 <code>1</code>，失败时返回 <code>nil</code>。</li>
<li>err：失败时的错误信息。</li>
</ul>
</li>
<li>
<p>作用：关闭当前 socket 套接字。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>调用过 setkeepalive 的 socket 对象，不用再调用 close，因为 socket 对象已经关闭并且连接已经被保存到内置连接池中。</li>
<li>没有调用 close 方法的 socket 对象（以及关联的连接）将在 Lua GC 释放 socket 对象或当前客户端 HTTP 请求处理完毕时关闭。</li>
</ul>
</li>
</ul>
<h3 id=使用示例>使用示例</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=kd>local</span> <span class=n>sock</span> <span class=o>=</span> <span class=n>ngx.socket</span><span class=p>.</span><span class=n>tcp</span><span class=p>()</span>
<span class=c1>-- bind 接口在更新的版本才有</span>
<span class=c1>-- local ok, err = sock:bind(&#34;172.22.49.3&#34;)</span>
<span class=c1>-- if not ok then</span>
<span class=c1>--     ngx.say(&#34;failed to bind&#34;)</span>
<span class=c1>--     return</span>
<span class=c1>-- end</span>

<span class=kd>local</span> <span class=n>ok</span><span class=p>,</span> <span class=n>err</span> <span class=o>=</span> <span class=n>sock</span><span class=p>:</span><span class=n>connect</span><span class=p>(</span><span class=s2>&#34;172.64.138.14&#34;</span><span class=p>,</span> <span class=mi>80</span><span class=p>)</span>
<span class=kr>if</span> <span class=ow>not</span> <span class=n>ok</span> <span class=kr>then</span>
    <span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;failed to connect server: &#34;</span><span class=p>,</span> <span class=n>err</span><span class=p>)</span>
    <span class=kr>return</span>
<span class=kr>end</span>
<span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;successfully connected!&#34;</span><span class=p>)</span>

<span class=kd>local</span> <span class=n>req</span> <span class=o>=</span> <span class=s2>&#34;GET / HTTP/1.1</span><span class=se>\r\n</span><span class=s2>&#34;</span>
            <span class=o>..</span> <span class=s2>&#34;Host: ifconfig.io</span><span class=se>\r\n</span><span class=s2>&#34;</span>
            <span class=o>..</span> <span class=s2>&#34;User-Agent: curl/7.68.0</span><span class=se>\r\n</span><span class=s2>&#34;</span>
            <span class=o>..</span> <span class=s2>&#34;Accept: */*</span><span class=se>\r\n\r\n</span><span class=s2>&#34;</span>

<span class=c1>-- send</span>
<span class=n>sock</span><span class=p>:</span><span class=n>settimeout</span><span class=p>(</span><span class=mi>3000</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>bytes</span><span class=p>,</span> <span class=n>err</span> <span class=o>=</span> <span class=n>sock</span><span class=p>:</span><span class=n>send</span><span class=p>(</span><span class=n>req</span><span class=p>)</span>
<span class=kr>if</span> <span class=ow>not</span> <span class=n>bytes</span> <span class=kr>then</span>
    <span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;failed to send data to server: &#34;</span><span class=p>,</span> <span class=n>err</span><span class=p>)</span>
    <span class=kr>return</span>
<span class=kr>end</span>

<span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;successfully sent, bytes: &#34;</span><span class=p>,</span> <span class=n>bytes</span><span class=p>)</span>

<span class=c1>-- receive</span>
<span class=n>sock</span><span class=p>:</span><span class=n>settimeout</span><span class=p>(</span><span class=mi>3000</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>data</span><span class=p>,</span> <span class=n>err</span><span class=p>,</span> <span class=n>partial</span> <span class=o>=</span> <span class=n>sock</span><span class=p>:</span><span class=n>receive</span><span class=p>()</span>
<span class=kr>if</span> <span class=ow>not</span> <span class=n>data</span> <span class=kr>then</span>
    <span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;failed to read data from server: &#34;</span><span class=p>,</span> <span class=n>err</span><span class=p>)</span>
    <span class=kr>return</span>
<span class=kr>end</span>

<span class=n>ngx.say</span><span class=p>(</span><span class=s2>&#34;successfully read: &#34;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span>

<span class=n>sock</span><span class=p>:</span><span class=n>close</span><span class=p>()</span>
</code></pre></div><h2 id=实现>实现</h2>
<h3 id=lua-接口注入>Lua 接口注入</h3>
<p>毫无疑问，还是类似的注入方式</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=o>-</span> <span class=n>main</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_init_cycle</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_conf_parse</span>
            <span class=err>\</span><span class=o>-</span> <span class=n>ngx_conf_handler</span>
                <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_block</span>
                    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_init</span>
                        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_init_vm</span>
                            <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_new_state</span>
                                <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_init_globals</span>
                                    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_inject_ngx_api</span>
                                        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_inject_socket_tcp_api</span>
</code></pre></div><ul>
<li>ngx_http_lua_inject_socket_tcp_api 的执行流程</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=o>-</span> <span class=n>ngx_http_lua_inject_socket_tcp_api</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_createtable</span><span class=p>:</span> <span class=err>创建</span> <span class=n>ngx.socket</span> <span class=err>表</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_setfield</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=o>-</span><span class=mi>3</span><span class=p>,</span> <span class=s2>&#34;tcp&#34;</span><span class=p>)</span><span class=err>：注入</span> <span class=n>ngx.socket</span><span class=p>.</span><span class=n>tcp</span><span class=err>，以及</span> <span class=n>ngx.socket</span><span class=p>.</span><span class=n>stream</span><span class=p>,</span> <span class=n>ngx.socket</span><span class=p>.</span><span class=n>connect</span> <span class=err>等</span> <span class=n>ngx.socket</span> <span class=err>系列接口</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_pushlightuserdata</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>ngx_http_lua_lightudata_mask</span><span class=p>(</span><span class=n>req_socket_metatable_key</span><span class=p>))</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_createtable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>0</span> <span class=o>/*</span> <span class=n>narr</span> <span class=o>*/</span><span class=p>,</span> <span class=mi>6</span> <span class=o>/*</span> <span class=n>nrec</span> <span class=o>*/</span><span class=p>)</span><span class=err>：创建元表并注入通过</span> <span class=n>ngx.req</span><span class=p>.</span><span class=n>socket</span><span class=p>()</span> <span class=err>得到的对象的相关接口</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_pushlightuserdata</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>ngx_http_lua_lightudata_mask</span><span class=p>(</span><span class=n>raw_req_socket_metatable_key</span><span class=p>))</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_createtable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>0</span> <span class=o>/*</span> <span class=n>narr</span> <span class=o>*/</span><span class=p>,</span> <span class=mi>7</span> <span class=o>/*</span> <span class=n>nrec</span> <span class=o>*/</span><span class=p>)</span><span class=err>：创建元表并注入通过</span> <span class=n>ngx.req</span><span class=p>.</span><span class=n>socket</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span> <span class=err>得到的对象的相关接口</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_pushlightuserdata</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>ngx_http_lua_lightudata_mask</span><span class=p>(</span><span class=n>tcp_socket_metatable_key</span><span class=p>))</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_createtable</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>0</span> <span class=o>/*</span> <span class=n>narr</span> <span class=o>*/</span><span class=p>,</span> <span class=mi>14</span> <span class=o>/*</span> <span class=n>nrec</span> <span class=o>*/</span><span class=p>)</span><span class=err>：创建元表并注入</span> <span class=n>tcp</span> <span class=err>对象（通过</span> <span class=n>ngx.socket</span><span class=p>.</span><span class=n>tcp</span> <span class=err>创建）的接口</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>upstream_udata_metatable_key</span><span class=err>：还有以下这些元表，不再赘述，如有必要，直接通过这些</span> <span class=n>key</span> <span class=err>在源码中搜索，即可知道如何使用。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>downstream_udata_metatable_key</span><span class=err>：例如这个在</span> <span class=n>ngx.req</span><span class=p>.</span><span class=n>socket</span> <span class=err>调用时使用</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>pool_udata_metatable_key</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>pattern_udata_metatable_key</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ssl_session_metatable_key</span>
</code></pre></div><p>以 tcp 为例，
调用 ngx.socket.tcp() 函数创建 tcp 对象时，实际调用了 ngx_http_lua_socket_tcp 函数，
此函数中，会新建一个表，然后设置 ngx_http_lua_inject_socket_tcp_api 中创建的表（以 tcp_socket_metatable_key 标识）为元表。</p>
<p>接下来，我们也以 tcp 为例，跟踪了解 cosocket 的实现方式。</p>
<h3 id=创建对象>创建对象</h3>
<p>创建对象的函数是 ngx_http_lua_socket_tcp，比较简单，主要完成以下操作：</p>
<ul>
<li>获取请求</li>
<li>获取模块 ctx</li>
<li>检查 ctx 是否是可以 YIELD 的</li>
<li>创建新表</li>
<li>设置新表的元表为前面张杰中注入的元表， key：tcp_socket_metatable_key。</li>
<li>返回新表</li>
</ul>
<h3 id=创建连接>创建连接</h3>
<p>创建 TCP 连接的函数是 ngx_http_lua_socket_tcp_connect，我们来跟踪一下。</p>
<p>注释版代码见 <a class=link href=https://github.com/isshe/lua-nginx-module/blob/isshe/src/ngx_http_lua_socket_tcp.c#L964 target=_blank rel=noopener>src/ngx_http_lua_socket_tcp.c</a></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=o>-</span> <span class=n>ngx_http_lua_socket_tcp_connect</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>lua_type</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>==</span> <span class=n>LUA_TTABLE</span><span class=p>)</span><span class=err>：检查最后一个参数是不是</span> <span class=n>table</span> <span class=err>类型，是的话就是有选项参数（</span><span class=n>sock</span><span class=p>:</span><span class=n>connect</span> <span class=err>的最后一个参数）。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>lua_getfield</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=s2>&#34;pool_size&#34;</span><span class=p>)</span><span class=err>：从选项参数表中取出</span> <span class=n>pool_size</span><span class=err>，并检查合法性，需要</span> <span class=err>大于</span> <span class=mi>0</span> <span class=err>或者等于</span> <span class=kc>nil</span><span class=err>。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>lua_getfield</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=s2>&#34;backlog&#34;</span><span class=p>)</span><span class=err>：从选项参数表中取出</span> <span class=n>backlog</span><span class=err>，并检查合法性，需大于等于</span> <span class=mi>0</span><span class=err>。如果只设置了</span> <span class=n>backlog</span><span class=err>，没有设置</span> <span class=n>pool_size</span><span class=err>，则把默认</span> <span class=n>pool_size</span> <span class=err>值设置成</span> <span class=n>pool_size</span><span class=err>。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>lua_getfield</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=s2>&#34;pool&#34;</span><span class=p>)</span><span class=err>：从选项参数表中取值</span> <span class=n>pool</span><span class=err>，如果值是数字，就转成字符串，并继续按字符串处理；如果是字符串，就设置到</span> <span class=n>tcp</span> <span class=err>对象的指定的</span> <span class=n>key</span> <span class=err>下面（</span><span class=n>SOCKET_KEY_INDEX</span><span class=err>）；如果是</span> <span class=kc>nil</span><span class=err>，就从堆栈弹出</span> <span class=n>pool</span> <span class=err>相关参数；其他值报错返回。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>3</span> <span class=o>&amp;&amp;</span> <span class=n>lua_isnumber</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span><span class=err>：检查</span> <span class=n>port</span><span class=err>，不合法就退出，报错退出。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_rawgeti</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>SOCKET_CTX_INDEX</span><span class=p>)</span><span class=err>：取出</span> <span class=n>upstream_t</span><span class=err>，</span> <span class=err>如果没有就分配一个并设置到</span> <span class=n>tcp</span> <span class=err>对象的</span> <span class=n>SOCKET_CTX_INDEX</span><span class=err>；如果有了，就检查这个上游对象的有效性，有效就复用。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_memzero</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>ngx_http_lua_socket_tcp_upstream_t</span><span class=p>))</span><span class=err>：把拿到的上游对象初始化一下：清空，设置相关字段。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_rawgeti</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>SOCKET_CONNECT_TIMEOUT_INDEX</span><span class=p>)</span><span class=err>：把超时参数从</span> <span class=n>TCP</span> <span class=err>对象中取出压入栈中，设置超时到上游对象的连接超时、发送超时、读取超时字段中。（</span><span class=n>TCP</span> <span class=err>对象中的超时参数是</span> <span class=n>settimeouts</span><span class=err>、</span><span class=n>settimeout</span> <span class=err>函数设置的）</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>lua_pushlightuserdata</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=n>ngx_http_lua_lightudata_mask</span><span class=p>(</span><span class=n>socket_pool_key</span><span class=p>))</span><span class=err>：根据</span> <span class=n>pool</span> <span class=err>参数或者</span> <span class=n>host</span><span class=p>:</span><span class=n>port</span> <span class=err>为</span> <span class=n>key</span> <span class=err>取出对应连接池，如果有就直接用；如果没有，就创建（</span><span class=n>ngx_http_lua_socket_tcp_create_socket_pool</span><span class=err>）这个连接池。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_tcp_connect_helper</span><span class=err>：进入包裹函数，继续处理</span>
        <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>spool</span> <span class=err>!</span><span class=o>=</span> <span class=n>NULL</span><span class=p>)</span><span class=err>：检查是否指定了连接池；指定了，就从连接池中取出</span> <span class=n>keepalive</span> <span class=err>连接，取到了就直接返回。这里会限制连接池中总连接数不能超过</span> <span class=err>连接池大小</span> <span class=n>size</span> <span class=o>+</span> <span class=n>backlog</span><span class=err>。如果超过了</span> <span class=n>size</span><span class=err>，但小于</span> <span class=n>size</span> <span class=o>+</span> <span class=n>backlog</span><span class=err>，意味着是</span> <span class=n>backlog</span> <span class=err>连接，从</span> <span class=n>backlog</span> <span class=err>队列的从中取出或创建连接操作上下文（</span><span class=n>ngx_http_lua_socket_tcp_conn_op_ctx_t</span><span class=err>）放到队列中。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>host.data</span> <span class=o>=</span> <span class=n>ngx_palloc</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pool</span><span class=p>,</span> <span class=n>host_len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span><span class=err>：分配内存存</span> <span class=n>host</span><span class=err>，用于通过</span> <span class=n>ngx_parse_url</span> <span class=err>创建</span> <span class=n>sockaddr</span><span class=err>。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>resolved</span> <span class=o>=</span> <span class=n>ngx_pcalloc</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pool</span><span class=p>,</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>ngx_http_upstream_resolved_t</span><span class=p>))</span><span class=err>：分配内存存放域名解析相关内容，如果需要解析，就放到</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>resolved</span><span class=o>-&gt;</span><span class=n>host</span> <span class=err>字段；不用就把前面创建的</span> <span class=n>sockaddr</span> <span class=err>放到</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>resolved</span><span class=o>-&gt;</span><span class=n>sockaddr</span> <span class=err>中。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>resolved</span><span class=o>-&gt;</span><span class=n>sockaddr</span><span class=p>)</span><span class=err>：有地址了，直接进行连接，然后返回。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_resolve_retval_handler</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>rctx</span> <span class=o>=</span> <span class=n>ngx_resolve_start</span><span class=p>(</span><span class=n>clcf</span><span class=o>-&gt;</span><span class=n>resolver</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>temp</span><span class=p>)</span><span class=err>：进行域名解析。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>ngx_resolve_name</span><span class=p>(</span><span class=n>rctx</span><span class=p>)</span> <span class=err>!</span><span class=o>=</span> <span class=n>NGX_OK</span><span class=p>)</span><span class=err>：正式开始。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>write_prepare_retvals</span> <span class=o>=</span> <span class=n>ngx_http_lua_socket_resolve_retval_handler</span><span class=err>：设置解析完成后的回调函数。</span>

<span class=o>-</span> <span class=n>ngx_http_lua_socket_resolve_retval_handler</span><span class=err>：解析结果返回了，开始正式发起连接。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>resolved</span><span class=o>-&gt;</span><span class=n>sockaddr</span><span class=p>)</span><span class=err>：如果有就是解析成功了，没有就是解析失败了，报错返回。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>rc</span> <span class=o>=</span> <span class=n>ngx_event_connect_peer</span><span class=p>(</span><span class=n>pc</span><span class=p>)</span><span class=err>：发起连接</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_ERROR</span><span class=p>)</span><span class=err>：连接出错了</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_conn_error_retval_handler</span><span class=err>：错误处理函数</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_BUSY</span><span class=p>)</span><span class=err>：没有存活连接</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_DECLINED</span><span class=p>)</span><span class=err>：</span><span class=n>socket</span> <span class=err>错误。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_conn_error_retval_handler</span><span class=err>：错误处理函数</span>
    <span class=err>\</span><span class=o>-</span> <span class=o>/*</span> <span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_OK</span> <span class=o>||</span> <span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_AGAIN</span> <span class=o>*/</span><span class=err>；接下来就是连接中或者连接成功的情况了。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>NGX_AGAIN</span><span class=err>：</span><span class=n>connect</span> <span class=err>返回</span> <span class=o>-</span><span class=mi>1</span><span class=err>，错误码是</span> <span class=n>NGX_EINPROGRESS</span><span class=err>，意思是正在连接中。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>write</span><span class=o>-&gt;</span><span class=n>handler</span> <span class=o>=</span> <span class=n>ngx_http_lua_socket_tcp_handler</span><span class=err>：添加读写事件的处理函数</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_OK</span><span class=p>)</span><span class=err>：如果是连接成功了，就去掉读写事件，免得浪费</span> <span class=n>CPU</span> <span class=err>周期。</span>
    <span class=err>\</span><span class=o>-</span> <span class=o>/*</span> <span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_AGAIN</span> <span class=o>*/</span><span class=err>：还没连接成功</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_add_timer</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>,</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>connect_timeout</span><span class=p>)</span><span class=err>：增加增加连接超时</span> <span class=n>timer</span><span class=err>。</span>
</code></pre></div><p>从 Lua 接口 <a class=link href=#tcpsock:connect>connect</a> 可以看到，该接口有 3 个参数，分别是 host、port、options_table。
（其实是 4 个参数，第一个是 tcpsock 自身：connect(tcpsock, host, port, options_table)）</p>
<p>连接步骤大致总结如下：</p>
<ul>
<li>检查选项参数（options_table）</li>
<li>如果没有连接池就创建连接池</li>
<li>从连接池中获取连接，没取到就直接进行连接；（后续可通过 setkeepalive 放回到连接池中）</li>
<li>通过 ngx_parse_url 解析 host，看是不是域名，不是域名会直接创建 sockaddr</li>
<li>如果是域名，就进行域名解析</li>
<li>解析完成调用 ngx_event_connect_peer 进行连接</li>
<li>如果返回 NGX_OK，就是连接成功了</li>
<li>如果返回 NGX_AGAIN，c 函数 connect 的错误码是 EINPROGRESS，表示正在连接中，设置读写事件，等待写事件即可。（连接成功后，套接字会变为可写状态，事件模块会调用写事件处理函数）</li>
</ul>
<h3 id=发送请求>发送请求</h3>
<p>接口注入：</p>
<pre tabindex=0><code>- ngx_http_lua_inject_socket_tcp_api
    \- ngx_http_lua_socket_tcp_send
</code></pre><p>拿到注入的接口名称后，我们来跟踪一下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=o>-</span> <span class=n>ngx_http_lua_socket_tcp_send</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>==</span> <span class=n>NULL</span> <span class=o>||</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>peer.connection</span> <span class=o>==</span> <span class=n>NULL</span> <span class=o>||</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>write_closed</span><span class=p>)</span><span class=err>：先检查连接还在不在，不在就报错返回。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>body_downstream</span><span class=p>)</span><span class=err>：检查是不是想要写请求对应的</span> <span class=n>socket</span><span class=err>（</span><span class=n>ngx.req</span><span class=p>.</span><span class=n>socket</span><span class=err>），是的话，报错返回，不允许写。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>type</span> <span class=o>=</span> <span class=n>lua_type</span><span class=p>(</span><span class=n>L</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span><span class=err>：获取并检查第二个参数（也就是发送的数据）的类型；计算出最大发送长度。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_chain_get_free_buf</span><span class=err>：看下还有没有空间能放得下这么长的数据；没有会返回</span> <span class=n>NULL</span><span class=err>。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>switch</span> <span class=p>(</span><span class=n>type</span><span class=p>)</span><span class=err>：把要发送的数据写入获取到的</span> <span class=n>buffer</span> <span class=err>中。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>clcf</span><span class=o>-&gt;</span><span class=n>tcp_nodelay</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>tcp_nodelay</span> <span class=o>==</span> <span class=n>NGX_TCP_NODELAY_UNSET</span><span class=p>)</span><span class=err>：看有没有选项需要设置。</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_send</span><span class=err>：进行发送。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>b</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>request_bufs</span><span class=o>-&gt;</span><span class=n>buf</span><span class=err>：获取要发送的</span> <span class=n>buffer</span><span class=err>。</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>n</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>pos</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>last</span> <span class=o>-</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>pos</span><span class=p>)</span><span class=err>：进行发送，如果发送失败或者阻塞了，就立即退出死循环；否则就一直发送到发送完为止。</span>
        <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=n>NGX_ERROR</span><span class=p>)</span><span class=err>：如果是出错，就进行错误处理，然后返回</span> <span class=n>NGX_ERROR</span>
        <span class=err>\</span><span class=o>-</span> <span class=kr>else</span><span class=err>：否则就是</span> <span class=n>n</span> <span class=o>==</span> <span class=n>NGX_AGAIN</span><span class=err>，还在发送中</span>
            <span class=err>\</span><span class=o>-</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>write_event_handler</span> <span class=o>=</span> <span class=n>ngx_http_lua_socket_send_handler</span><span class=err>：设置写事件处理函数。</span>
            <span class=err>\</span><span class=o>-</span> <span class=n>ngx_add_timer</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>,</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>send_timeout</span><span class=p>)</span><span class=err>：增加定时器。</span>
            <span class=err>\</span><span class=o>-</span> <span class=n>ngx_handle_write_event</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>,</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>conf</span><span class=o>-&gt;</span><span class=n>send_lowat</span><span class=p>)</span><span class=err>：监听写事件。</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_ERROR</span><span class=p>)</span><span class=err>：出错了就进行错误处理并返回</span>
        <span class=err>\</span><span class=o>-</span> <span class=n>ngx_http_lua_socket_write_error_retval_handler</span>
    <span class=err>\</span><span class=o>-</span> <span class=kr>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_OK</span><span class=p>)</span><span class=err>：成功了直接返回</span>
    <span class=err>\</span><span class=o>-</span> <span class=o>/*</span> <span class=n>rc</span> <span class=o>==</span> <span class=n>NGX_AGAIN</span> <span class=o>*/</span><span class=err>：还在发送中</span>
    <span class=err>\</span><span class=o>-</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>write_prepare_retvals</span> <span class=o>=</span> <span class=n>ngx_http_lua_socket_tcp_send_retval_handler</span><span class=err>：设置好回调函数，</span><span class=n>yield</span> <span class=err>出去等待可写事件发生。</span>
</code></pre></div><p>经过前面 connect 的整理，send 就简单了很多，都是一样的套路：返回 NGX_AGAIN 就 yield，继续加入到事件循环中，等待下次事件触发，继续处理，都完成以后，在 resume 回去 lua 代码。</p>
<p>步骤大致总结如下：</p>
<ul>
<li>计算发送的长度；</li>
<li>复制数据到指定的 buffer 中；</li>
<li>进行发送，如果一直发送成功，就一直发送；否则就退出循环。</li>
<li>如果是出错了，就进行错误处理，然后退出。</li>
<li>如果是阻塞了，就设置写处理函数并监听写事件，yield 出去等待下次可写。</li>
</ul>
<h3 id=接收响应>接收响应</h3>
<p>接口注入：</p>
<pre tabindex=0><code>- ngx_http_lua_inject_socket_tcp_api
    \- ngx_http_lua_socket_tcp_receive
</code></pre><p>原理和前面发送类似，大致步骤如下：</p>
<ul>
<li>处理参数，判断是数字还是字符串；数字表示要接收的字节数量，是字符串表示模式，是 <code>*a</code> 还是 <code>*l</code>。根据不同的模式设置不同的 input_filter。如果没有指定第二个参数，就是默认的行模式。</li>
<li>检查缓冲区有没有空间，没有就重新获取一个</li>
<li>开始读取，出错或者成功，就直接返回。</li>
<li>如果是 NGX_AGAIN，就设置好处理函数，yiele 了继续等待事件发生。</li>
</ul>
<h3 id=关闭连接>关闭连接</h3>
<p>如果请求没有忙于读、写、连接，则调用 ngx_http_lua_socket_tcp_finalize 关闭连接。</p>
<h2 id=总结>总结</h2>
<h3 id=1nginx-是如何进行域名解析的-ngx_resolve_startngx_resolve_name是异步的吗会等待解析结果吗>1.Nginx 是如何进行域名解析的？ ngx_resolve_start、ngx_resolve_name，是异步的吗，会等待解析结果吗？</h3>
<p>答：详见 <a class=link href=../../Nginx/Nginx%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90/7-nginx-dns-resolve.md>Nginx 是如何进行 DNS 解析的？</a>。</p>
<h3 id=2如何进行连接的>2.如何进行连接的？</h3>
<p>答：进行非阻塞连接，返回 rc == -1 && err == NGX_EINPROGRESS 时，表示连接正在进行中。openresty 设置好读写事件，在 ngx_http_lua_socket_connected_handler 中检查连接实际是否成功。</p>
<p>更多参考 <a class=link href=../../../B.%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/Linux/Application/7.IO%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8/IO%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e4%b8%8e%e9%9d%9e%e9%98%bb%e5%a1%9e%e8%bf%9e%e6%8e%a5/README.md>I/O多路复用与非阻塞连接</a></p>
<h3 id=3tcp-连接进行中ngx_again时yield-出去后会在哪里恢复>3.TCP 连接进行中（NGX_AGAIN）时，yield 出去后，会在哪里恢复？</h3>
<p>答：</p>
<ul>
<li><a class=link href=https://github.com/isshe/lua-nginx-module/blob/isshe/src/ngx_http_lua_socket_tcp.c#L840 target=_blank rel=noopener>https://github.com/isshe/lua-nginx-module/blob/isshe/src/ngx_http_lua_socket_tcp.c#L840</a></li>
<li>此时 Lua 正在调用 connect。</li>
<li>yield 以后，继续返回到 ngx_http_lua_run_thread，最后回到事件循环中，等待事件发生，重新 resume。</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// yield 后也就是 lua_resume 返回了
</span><span class=c1></span><span class=n>rv</span> <span class=o>=</span> <span class=n>lua_resume</span><span class=p>(</span><span class=n>orig_coctx</span><span class=o>-&gt;</span><span class=n>co</span><span class=p>,</span> <span class=n>nrets</span><span class=p>);</span>
</code></pre></div><ul>
<li>事件发生（c->write 写事件）后，调用 ngx_http_lua_socket_tcp_handler。</li>
</ul>
<p>连接成功后的调用栈：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=o>#</span><span class=mi>0</span>  <span class=n>ngx_http_lua_run_thread</span> <span class=p>(</span><span class=n>L</span><span class=o>=</span><span class=mh>0x55efffa60640</span> <span class=o>&lt;</span><span class=n>cached_syslog_time</span><span class=o>+</span><span class=mi>800</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>r</span><span class=o>=</span><span class=mh>0x55efff9d0280</span><span class=p>,</span>
    <span class=n>ctx</span><span class=o>=</span><span class=mh>0x55efff7be452</span> <span class=o>&lt;</span><span class=n>ngx_sprintf</span><span class=o>+</span><span class=mi>192</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>nrets</span><span class=o>=</span><span class=mi>32766</span><span class=p>)</span>
    <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_util.c</span><span class=p>:</span><span class=mi>1112</span>
<span class=o>#</span><span class=mi>1</span>  <span class=mh>0x000055efff945315</span> <span class=kr>in</span> <span class=n>ngx_http_lua_socket_tcp_resume_helper</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mh>0x55f001716120</span><span class=p>,</span>
    <span class=n>socket_op</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_socket_tcp.c</span><span class=p>:</span><span class=mi>5991</span>
<span class=o>#</span><span class=mi>2</span>  <span class=mh>0x000055efff945082</span> <span class=kr>in</span> <span class=n>ngx_http_lua_socket_tcp_conn_resume</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mh>0x55f001716120</span><span class=p>)</span>
    <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_socket_tcp.c</span><span class=p>:</span><span class=mi>5897</span>
<span class=o>#</span><span class=mi>3</span>  <span class=mh>0x000055efff92e8bf</span> <span class=kr>in</span> <span class=n>ngx_http_lua_content_wev_handler</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mh>0x55f001716120</span><span class=p>)</span>
    <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_contentby.c</span><span class=p>:</span><span class=mi>152</span>
<span class=o>#</span><span class=mi>4</span>  <span class=mh>0x000055efff93f72a</span> <span class=kr>in</span> <span class=n>ngx_http_lua_socket_handle_conn_success</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mh>0x55f001716120</span><span class=p>,</span>
    <span class=n>u</span><span class=o>=</span><span class=mh>0x7f868af3adc8</span><span class=p>)</span> <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_socket_tcp.c</span><span class=p>:</span><span class=mi>3451</span>
<span class=o>#</span><span class=mi>5</span>  <span class=mh>0x000055efff9401b6</span> <span class=kr>in</span> <span class=n>ngx_http_lua_socket_connected_handler</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mh>0x55f001716120</span><span class=p>,</span>
    <span class=n>u</span><span class=o>=</span><span class=mh>0x7f868af3adc8</span><span class=p>)</span> <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_socket_tcp.c</span><span class=p>:</span><span class=mi>3719</span>
<span class=o>#</span><span class=mi>6</span>  <span class=mh>0x000055efff93efd0</span> <span class=kr>in</span> <span class=n>ngx_http_lua_socket_tcp_handler</span> <span class=p>(</span><span class=n>ev</span><span class=o>=</span><span class=mh>0x55f0017a73b0</span><span class=p>)</span>
    <span class=n>at</span> <span class=o>../</span><span class=n>ngx_lua</span><span class=o>-</span><span class=mf>0.10.21</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>ngx_http_lua_socket_tcp.c</span><span class=p>:</span><span class=mi>3239</span>
<span class=p>...</span>
</code></pre></div><h3 id=4什么是-cosocket-呢-cosocket-是如何实现的呢>4.什么是 cosocket 呢？ cosocket 是如何实现的呢？</h3>
<p>答：cosocket 是一种基于协程的高性能、低延迟的 I/O 模型。cosocket 基于事件驱动和异步 I/O，使用 Nginx 事件驱动框架监听套接字事件，通过异步 I/O 读写套接字数据，实现面向协议编程（解析/处理协议）的目的。</p>
<ul>
<li>协程：利用 yield、resume 对协程进行调度。</li>
<li>事件驱动：发生事件是，调用事先设置好的处理程序。</li>
<li>异步 IO：不进行阻塞调用，条件没就绪也立即返回。根据不同的返回值，进行处理。如果返回值是 NGX_AGAIN 意味着条件不满足，需要继续监听事件，并且 yield 当前的 Lua 调用，等待条件满足再返回。</li>
</ul>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/%E5%B7%A5%E5%85%B7/>工具</a>
<a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
<a href=/tags/nginx/>nginx</a>
<a href=/tags/openresty/>OpenResty</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/p/openresty-%E7%BA%BF%E7%A8%8B/>
<div class=article-image>
<img src=/p/openresty-%E7%BA%BF%E7%A8%8B/image.fa3460183bd6813650702a42985e6c2f_hu818ee36d4363169fc9a3aaeaa8549fc5_273897_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OpenResty 线程" data-hash="md5-+jRgGDvWgTZQcCpCmF5sLw==">
</div>
<div class=article-details>
<h2 class=article-title>OpenResty 线程</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/>
<div class=article-image>
<img src=/p/openresty-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/image.96f45fc9989fb02948258bb53138a3eb_huff93e60677c963a35780fae817fe9703_270013_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OpenResty 核心技术点" data-hash="md5-lvRfyZifsClIJYu1MTij6w==">
</div>
<div class=article-details>
<h2 class=article-title>OpenResty 核心技术点</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/>
<div class=article-image>
<img src=/p/openresty-%E4%BF%A1%E5%8F%B7%E9%87%8F/image.d2df3a759985085045023169d51d50d8_hud257672d761052d10876c00530251082_250335_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OpenResty 信号量" data-hash="md5-0t86dZmFCFBFAjFp1R1Q2A==">
</div>
<div class=article-details>
<h2 class=article-title>OpenResty 信号量</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/>
<div class=article-image>
<img src=/p/openresty-lua-vm-%E5%88%9D%E5%A7%8B%E5%8C%96/image.591812376bdff8e1b336034bbbe4c01b_hu8b1a295022397cfd38b972b1dd920be7_248987_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OpenResty Lua VM 初始化" data-hash="md5-WRgSN2vf+OGzNgNLu+TAGw==">
</div>
<div class=article-details>
<h2 class=article-title>OpenResty Lua VM 初始化</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/>
<div class=article-image>
<img src=/p/openresty-%E5%85%B1%E4%BA%AB%E5%AD%97%E5%85%B8%E5%86%85%E5%AD%98/image.e836eb48dfa8209123106b8a15c78e8c_hub58aa43631c748bc46260e35845799bd_220559_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OpenResty 共享字典（内存）" data-hash="md5-6DbrSN+oIJEjEGuKFceOjA==">
</div>
<div class=article-details>
<h2 class=article-title>OpenResty 共享字典（内存）</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div id=gitalk-container></div>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script>
<script>const gitalk=new Gitalk({clientID:"7e9427059aca5b5e1496",clientSecret:"05b62531357375142bd7b06096ec194ee4db119c",repo:"isshe.github.io",owner:"isshe",admin:["isshe"],distractionFreeMode:!1,id:md5(location.pathname)});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}gitalk.render("gitalk-container")})()</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 -
2023 树深时间录
</section>
<section class=powerby>
相信美好的事情即将发生。 <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#使用>使用</a>
<ol>
<li><a href=#ngxsockettcp>ngx.socket.tcp</a></li>
<li><a href=#tcpsockbind>tcpsock:bind</a></li>
<li><a href=#tcpsockconnect>tcpsock:connect</a></li>
<li><a href=#tcpsocksend>tcpsock:send</a></li>
<li><a href=#tcpsockreceive>tcpsock:receive</a></li>
<li><a href=#tcpsocksettimeout>tcpsock:settimeout</a></li>
<li><a href=#tcpsockclose>tcpsock:close</a></li>
<li><a href=#使用示例>使用示例</a></li>
</ol>
</li>
<li><a href=#实现>实现</a>
<ol>
<li><a href=#lua-接口注入>Lua 接口注入</a></li>
<li><a href=#创建对象>创建对象</a></li>
<li><a href=#创建连接>创建连接</a></li>
<li><a href=#发送请求>发送请求</a></li>
<li><a href=#接收响应>接收响应</a></li>
<li><a href=#关闭连接>关闭连接</a></li>
</ol>
</li>
<li><a href=#总结>总结</a>
<ol>
<li><a href=#1nginx-是如何进行域名解析的-ngx_resolve_startngx_resolve_name是异步的吗会等待解析结果吗>1.Nginx 是如何进行域名解析的？ ngx_resolve_start、ngx_resolve_name，是异步的吗，会等待解析结果吗？</a></li>
<li><a href=#2如何进行连接的>2.如何进行连接的？</a></li>
<li><a href=#3tcp-连接进行中ngx_again时yield-出去后会在哪里恢复>3.TCP 连接进行中（NGX_AGAIN）时，yield 出去后，会在哪里恢复？</a></li>
<li><a href=#4什么是-cosocket-呢-cosocket-是如何实现的呢>4.什么是 cosocket 呢？ cosocket 是如何实现的呢？</a></li>
</ol>
</li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>